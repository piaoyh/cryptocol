// Copyright 2023, 2024 PARK Youngho.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your option.
// This file may not be copied, modified, or distributed
// except according to those terms.

#![allow(missing_docs)]
#![allow(rustdoc::missing_doc_code_examples)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
pub fn main()
{
    biguint_quick_start_main();
    biguint_constructors_main();
    biguint_get_size_main();
    biguint_get_set_check_main();
    biguint_check_bits_main();
    biguint_comparison_uint_main();
    biguint_comparison_biguint_main();
    biguint_arithmatic_operation_uint_main();
    biguint_miscellaneous_arithmatic_operation_uint_main();
    biguint_exponentiation_logarithm_uint_main();
    biguint_arithmatic_operation_biguint_main();
    biguint_exponentiation_logarithm_biguint_main();
    biguint_miscellaneous_arithmatic_operation_main();
    biguint_bit_operation_main();
    biguint_conversion_main();
    biguint_flag_manipulation_main();
    biguint_operators_arithmatic_main();
    biguint_operators_bit_operation_main();
    biguint_operators_miscellaneous_main();
    biguint_implementation_miscellaneous_main();
}

fn biguint_quick_start_main()
{
    biguint_quick_start1();
    biguint_quick_start2();
}

fn biguint_quick_start1()
{
    println!("biguint_quick_start1");
    use std::str::FromStr;
    use cryptocol::number::*;

    type U1024 = BigUInt::<u128, 8>;

    let a_biguint = U1024::from([1_u128; 8]);
    println!("a_biguint = {:?}\nOverflow: {}\nUnderflow: {}\nInfiniity: {}\nUndefined: {}\nDivided_by_Zero: {}\nLeft_Carry: {}\nRight_Carry: {}", a_biguint.get_number(), a_biguint.is_overflow(), a_biguint.is_underflow(), a_biguint.is_infinity(), a_biguint.is_undefined(), a_biguint.is_divided_by_zero(), a_biguint.is_left_carry(), a_biguint.is_right_carry());
    assert_eq!(*a_biguint.get_number(), [1, 1, 1, 1, 1, 1, 1, 1]);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    println!("a_biguint = {}", a_biguint);
    let txt = format!("{}", a_biguint);
    assert_eq!(txt, "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173406846268890965642294205800438269168685095342047538166014444022988625525970748234723644093345682544597060157565694902273");

    println!("a_biguint = {:#x}", a_biguint);
    let txt = format!("{:#x}", a_biguint);
    assert_eq!(txt, "0x100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001");

    let b_biguint = U1024::from_string("528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173406846268890965642294205800438269168685095342047538166014444022988625525970748234723644093345682544597060157565694902273").unwrap();
    println!("b_biguint = {:?}\nOverflow: {}\nUnderflow: {}\nInfiniity: {}\nUndefined: {}\nDivided_by_Zero: {}\nLeft_Carry: {}\nRight_Carry: {}", b_biguint.get_number(), b_biguint.is_overflow(), b_biguint.is_underflow(), b_biguint.is_infinity(), b_biguint.is_undefined(), b_biguint.is_divided_by_zero(), b_biguint.is_left_carry(), b_biguint.is_right_carry());
    assert_eq!(*b_biguint.get_number(), [1, 1, 1, 1, 1, 1, 1, 1]);
    assert_eq!(b_biguint.is_overflow(), false);
    assert_eq!(b_biguint.is_underflow(), false);
    assert_eq!(b_biguint.is_infinity(), false);
    assert_eq!(b_biguint.is_undefined(), false);
    assert_eq!(b_biguint.is_divided_by_zero(), false);
    assert_eq!(b_biguint.is_left_carry(), false);
    assert_eq!(b_biguint.is_right_carry(), false);

    println!("b_biguint = {}", b_biguint);
    assert_eq!(b_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173406846268890965642294205800438269168685095342047538166014444022988625525970748234723644093345682544597060157565694902273");

    println!("b_biguint = {:X}", b_biguint);
    assert_eq!(a_biguint.to_string_with_radix(16).unwrap(), "100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001");

    let c_biguint = U1024::from_str("1234567891234567879123456789111111111222222222333333333444444444555555555666666666777777777888888888999999999000000000").unwrap();

    println!("c_biguint_biguint_biguint = {}", c_biguint);
    assert_eq!(c_biguint.to_string(), "1234567891234567879123456789111111111222222222333333333444444444555555555666666666777777777888888888999999999000000000");

    let mut d_biguint = b_biguint.clone() + c_biguint.clone();
    println!("b_biguint + c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173408080836782200210173329257227380279796317564269871499347888467433181081526414901390421871123571433486060157564694902273");

    d_biguint = b_biguint.clone() - c_biguint.clone();
    println!("b_biguint - c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173405611700999731074415082343649158057573873119825204832680999578544069970415081568056866315567793655708060157566694902273");

    d_biguint = c_biguint.clone() - b_biguint.clone();
    println!("c_biguint_biguint - b_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "179769313486231590772930519078902473361269403363094992027077741372816159198980563288580055091344426332604977474759407049726638194120401741388541284402205712176239488954006474494558295411072688507752083221010590686494501524284889008354087905708146237584806440714171216671890379622911922649127296172057529234943");

    d_biguint = c_biguint.clone() * b_biguint.clone();
    println!("c_biguint_biguint * b_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "59830717854030867758075123183163555064720825939616846267926369121354707541167863856429897315021801292311343603281484761713479005341939688693125073345149826515313989515871501605159397439048630578377892313876159164289859563003628270426845234033215692532247483706885131175507859004610238546564083383732338767360");

    d_biguint = b_biguint.clone() / c_biguint.clone();
    println!("b_biguint / c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "427918573686029304066254243786715892164567464161173266402914429285403265969001177679575353202952599315891695262671719654199608368852942773933951103642477");

    d_biguint = b_biguint.clone() % c_biguint.clone();
    println!("b_biguint % c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "974831854472745921484474959642423157588012401465652792186214606232572248263942179693215574222740495163800042694902273");

    d_biguint = b_biguint.clone() + 5_u128;
    println!("b_biguint + 5 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173406846268890965642294205800438269168685095342047538166014444022988625525970748234723644093345682544597060157565694902278");

    d_biguint = b_biguint.clone() - 1_u128;
    println!("b_biguint - 1 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173406846268890965642294205800438269168685095342047538166014444022988625525970748234723644093345682544597060157565694902272");

    d_biguint = b_biguint.clone() * 42_u128;
    println!("b_biguint * 42 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "22188370307697940346798270966493697473856793453393733704650606917635729014703424933150366137148625006380858141965273312464192987776078452833244815987283087543293420556976356643618407305084774004365996602972606648965522272090771425858393051920518666873076526617759185895466");

    d_biguint = b_biguint.clone() / 5_u128;
    println!("b_biguint / 5 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "105658906227133049270467956983303321304079968825684446212621937703027281022397261586430314938802976220861229247453682440305680894171802156348784838034681369253778193128458841160087653833737019068409507633202888804597725105194149646944728818669136508919412031513138980454");

    let e_uint = b_biguint.clone() % 5_u128;
    println!("b_uint % 5 = {}", e_uint);
    assert_eq!(e_uint, 3);
    println!("-------------------------------");
}

fn biguint_quick_start2()
{
    println!("biguint_quick_start2()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    
    define_utypes_with!(u128);

    let a_biguint = U1024::from([1; 8]);
    let b_biguint = U1024::from_str_radix("00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001__00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001__00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001__00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001__00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001__00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001__00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001__00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001", 2).unwrap();
    let c_biguint = UU128::from_str("1234567891234567879123456789111111111222222222333333333444444444555555555666666666777777777888888888999999999000000000").unwrap();

    println!("a_biguint = {:?}\nOverflow: {}\nUnderflow: {}\nInfiniity: {}\nDivided_by_Zero: {}", a_biguint.get_number(), a_biguint.is_overflow(), a_biguint.is_underflow(), a_biguint.is_infinity(), a_biguint.is_divided_by_zero());
    assert_eq!(*a_biguint.get_number(), [1, 1, 1, 1, 1, 1, 1, 1]);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    println!("a_biguint = {}", a_biguint.to_string_with_radix(16).unwrap());
    assert_eq!(a_biguint.to_string_with_radix(16).unwrap(), "100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001");

    println!("b_biguint = {:?}\nOverflow: {}\nUnderflow: {}\nInfiniity: {}\nDivided_by_Zero: {}", b_biguint.get_number(), b_biguint.is_overflow(), b_biguint.is_underflow(), b_biguint.is_infinity(), b_biguint.is_divided_by_zero());
    assert_eq!(*b_biguint.get_number(), [1, 1, 1, 1, 1, 1, 1, 1]);
    assert_eq!(b_biguint.is_overflow(), false);
    assert_eq!(b_biguint.is_underflow(), false);
    assert_eq!(b_biguint.is_infinity(), false);
    assert_eq!(b_biguint.is_divided_by_zero(), false);

    println!("b_biguint = {}", b_biguint.to_string_with_radix(16).unwrap());
    assert_eq!(b_biguint.to_string_with_radix(16).unwrap(), "100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001");

    println!("c_biguint_biguint = {}", c_biguint);
    assert_eq!(c_biguint.to_string(), "1234567891234567879123456789111111111222222222333333333444444444555555555666666666777777777888888888999999999000000000");

    let mut d_biguint = c_biguint.wrapping_add(&b_biguint);
    println!("b_biguint + c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173408080836782200210173329257227380279796317564269871499347888467433181081526414901390421871123571433486060157564694902273");

    d_biguint = b_biguint.wrapping_sub(&c_biguint);
    println!("b_biguint - c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173405611700999731074415082343649158057573873119825204832680999578544069970415081568056866315567793655708060157566694902273");

    d_biguint = c_biguint.wrapping_sub(&b_biguint);
    println!("c_biguint - b_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "179769313486231590772930519078902473361269403363094992027077741372816159198980563288580055091344426332604977474759407049726638194120401741388541284402205712176239488954006474494558295411072688507752083221010590686494501524284889008354087905708146237584806440714171216671890379622911922649127296172057529234943");

    d_biguint = c_biguint.wrapping_mul(&b_biguint);
    println!("c_biguint * b_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "59830717854030867758075123183163555064720825939616846267926369121354707541167863856429897315021801292311343603281484761713479005341939688693125073345149826515313989515871501605159397439048630578377892313876159164289859563003628270426845234033215692532247483706885131175507859004610238546564083383732338767360");

    d_biguint = b_biguint.wrapping_div(&c_biguint);
    println!("b_biguint / c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "427918573686029304066254243786715892164567464161173266402914429285403265969001177679575353202952599315891695262671719654199608368852942773933951103642477");

    d_biguint = b_biguint.wrapping_rem(&c_biguint);
    println!("b_biguint % c_biguint = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "974831854472745921484474959642423157588012401465652792186214606232572248263942179693215574222740495163800042694902273");

    d_biguint = b_biguint.wrapping_add_uint(5_u128);
    println!("b_biguint + 5 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173406846268890965642294205800438269168685095342047538166014444022988625525970748234723644093345682544597060157565694902278");

    d_biguint = b_biguint.wrapping_sub_uint(1_u128);
    println!("b_biguint - 1 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "528294531135665246352339784916516606520399844128422231063109688515136405111986307932151574694014881104306146237268412201528404470859010781743924190173406846268890965642294205800438269168685095342047538166014444022988625525970748234723644093345682544597060157565694902272");

    d_biguint = b_biguint.wrapping_mul_uint(42_u128);
    println!("b_biguint * 42 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "22188370307697940346798270966493697473856793453393733704650606917635729014703424933150366137148625006380858141965273312464192987776078452833244815987283087543293420556976356643618407305084774004365996602972606648965522272090771425858393051920518666873076526617759185895466");

    d_biguint = b_biguint.wrapping_div_uint(5_u128);
    println!("b_biguint / 5 = {}", d_biguint);
    assert_eq!(d_biguint.to_string(), "105658906227133049270467956983303321304079968825684446212621937703027281022397261586430314938802976220861229247453682440305680894171802156348784838034681369253778193128458841160087653833737019068409507633202888804597725105194149646944728818669136508919412031513138980454");

    let e_uint = b_biguint.wrapping_rem_uint(5_u128);
    println!("b_biguint % 5 = {}", e_uint);
    assert_eq!(e_uint, 3);
    println!("-------------------------------");
}

fn biguint_constructors_main()
{
    biguint_new();
    biguint_zero();
    biguint_one();
    biguint_max();
    biguint_submax();
    biguint_halfmax();
    biguint_from_uint();
    biguint_from_array();
    biguint_from_biguint();
    biguint_from_be();
    biguint_from_be_bytes();
    biguint_from_le();
    biguint_from_le_bytes();
    biguint_from_string();
    biguint_from_str_radix();
    biguint_generate_check_bits_();
    biguint_generate_check_bits();
}

fn biguint_new()
{
    println!("biguint_new");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let obj = U256::new();
    println!("obj = {}", obj);
    assert_eq!(obj.to_string(), "0");
    println!("-------------------------------");
}

fn biguint_zero()
{
    println!("biguint_zero");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let zero = U256::zero();
    println!("zero = {}", zero);
    assert_eq!(zero.to_string(), "0");
    println!("-------------------------------");
}

fn biguint_one()
{
    println!("biguint_one");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let one = U256::one();
    println!("one = {}", one);
    assert_eq!(one.to_string(), "1");
    println!("-------------------------------");
}

fn biguint_max()
{
    println!("biguint_max");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let maximum = U256::max();
    println!("maximum =\t{}", maximum);
    assert_eq!(maximum.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639935");
    assert_eq!(maximum.wrapping_add_uint(1_u16), U256::zero());
    println!("---------------------------");
}

fn biguint_submax()
{
    println!("biguint_submax");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let half = U256::submax(128_usize);
    println!("half maximum = \t{}", half);
    println!("half maximum = \t{}", half.to_string_with_radix_and_stride(16, 4).unwrap());
    assert_eq!(half.to_string(), "340282366920938463463374607431768211455");
    assert_eq!(half.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF");
    println!("---------------------------");
}

fn biguint_halfmax()
{
    println!("biguint_halfmax");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let half = U256::halfmax();
    println!("half maximum = \t{}", half);
    println!("half maximum = \t{}", half.to_string_with_radix_and_stride(16, 4).unwrap());
    assert_eq!(half.to_string(), "340282366920938463463374607431768211455");
    assert_eq!(half.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF");
    println!("---------------------------");
}

fn biguint_from_uint()
{
    println!("biguint_from_uint");
    use cryptocol::define_utypes_with_u16;
    define_utypes_with_u16!();

    let a_from_u8 = U512::from_uint(123_u8);
    let b_from_u16 = U512::from_uint(12345_u16);
    let c_from_u32 = U512::from_uint(1234567890_u32);
    let d_from_u64 = U512::from_uint(12345678901234567890_u64);
    let e_from_u128 = U512::from_uint(123456789012345678901234567890123456789_u128);
    let f_from_usize = U512::from_uint(123_usize);

    println!("a_from_u8 = {}", a_from_u8);
    println!("b_from_u16 = {}", b_from_u16);
    println!("c_from_u32 = {}", c_from_u32);
    println!("d_from_u64 = {}", d_from_u64);
    println!("e_from_u128 = {}", e_from_u128);
    println!("f_from_usize = {}", f_from_usize);

    assert_eq!(a_from_u8.into_u8(), 123_u8);
    assert_eq!(b_from_u16.into_u16(), 12345_u16);
    assert_eq!(c_from_u32.into_u32(), 1234567890_u32);
    assert_eq!(d_from_u64.into_u64(), 12345678901234567890_u64);
    assert_eq!(e_from_u128.into_u128(), 123456789012345678901234567890123456789_u128);
    assert_eq!(f_from_usize.into_usize(), 123_usize);
    println!("---------------------------");
}

fn biguint_from_array()
{
    println!("biguint_from_array");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let big_num = U256::from_array([10_u8;32]);
    println!("big_num = {}", big_num.to_string_with_radix(16).unwrap());
    assert_eq!(big_num.to_string_with_radix(16).unwrap(), "A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A");
    println!("---------------------------");
}

fn biguint_from_biguint()
{
    println!("biguint_from_biguint");
    use std::str::FromStr;
    use cryptocol::number::*;

    let a_u512_with_u8 = U512_with_u8::from_str("123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789").unwrap();

    // Example for the same length
    let b_u512_with_u8 = U512_with_u8::from_biguint(&a_u512_with_u8);
    println!("a_u512_with_u8 = {}", a_u512_with_u8);
    println!("b_u512_with_u8 = {}", b_u512_with_u8);
    assert_eq!(a_u512_with_u8.to_string(), "123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789");
    assert_eq!(b_u512_with_u8.to_string(), "123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789");

    // Example for the shorter length
    let b_u256_with_u8 = U256_with_u16::from_biguint(&a_u512_with_u8);
    println!("a_u512_with_u8 = {}", a_u512_with_u8);
    println!("b_u256_with_u8 = {}", b_u256_with_u8);
    assert_eq!(a_u512_with_u8.to_string(), "123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789");
    assert_eq!(b_u256_with_u8.to_string(), "98633800081229720571026865697976779988382011787853764870844783447569204535061");

    // Example for the longer length
    let b_u1024_with_u8 = U1024_with_u16::from_biguint(&a_u512_with_u8);
    println!("a_u512_with_u8 = {}", a_u512_with_u8);
    println!("b_u1024_with_u8 = {}", b_u1024_with_u8);
    assert_eq!(a_u512_with_u8.to_string(), "123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789");
    assert_eq!(b_u1024_with_u8.to_string(), "123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789");
    println!("---------------------------");
}

fn biguint_from_be()
{
    println!("biguint_from_be");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let be = U256::from_array([0x1234, 0x5678, 0x90ab, 0xcdef,
                                0x1122, 0x3344, 0x5566, 0x7788,
                                0x9900, 0xaabb, 0xccdd, 0xeeff,
                                0x1f2e, 0x3d4c, 0x5b6a, 0x7089]);
    let le = U256::from_be(be.clone());
    println!("be = 0x{}", be.to_string_with_radix(16).unwrap());
    println!("le = 0x{}", le.to_string_with_radix(16).unwrap());
    #[cfg(target_endian = "little")]
    {
        assert_eq!(be.to_string_with_radix(16).unwrap(), "70895B6A3D4C1F2EEEFFCCDDAABB99007788556633441122CDEF90AB56781234");
        assert_eq!(le.to_string_with_radix(16).unwrap(), "34127856AB90EFCD22114433665588770099BBAADDCCFFEE2E1F4C3D6A5B8970");        
    }
    #[cfg(target_endian = "big")]
    {
        assert_eq!(be.to_string_with_radix(16).unwrap(), "1234567890ABCDEF11223344556677889900AABBCCDDEEFF1F2E3D4C5B6A7089");
        assert_eq!(le.to_string_with_radix(16).unwrap(), "1234567890ABCDEF11223344556677889900AABBCCDDEEFF1F2E3D4C5B6A7089");        
    }
    println!("---------------------------");
}

fn biguint_from_be_bytes()
{
    println!("biguint_from_be_bytes");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let be_array = [0x12345678, 0x90abcdef, 0x11223344, 0x55667788,
                    0x9900aabb, 0xccddeeff, 0x1f2e3d4c, 0x5b6a7089];
    let le = U256::from_be_bytes(be_array.clone());
    print!("be_array = ");
    for elem in be_array
        { print!("0x{:8x} ", elem); }
    println!();
    println!("le = 0x{}", le.to_string_with_radix_and_stride_and_delimiter(16, 8, " 0x").unwrap());
    #[cfg(target_endian = "little")]    assert_eq!(le.to_string_with_radix_and_stride(16, 8).unwrap(), "78563412_EFCDAB90_44332211_88776655_BBAA0099_FFEEDDCC_4C3D2E1F_89706A5B");
    #[cfg(target_endian = "big")]       assert_eq!(le.to_string_with_radix(16).unwrap(), "12345678_90ABCDEF_11223344_55667788_9900AABB_CCDDEEFF_1F2E3D4C_5B6A7089");
    println!("---------------------------");
}

fn biguint_from_le()
{
    println!("biguint_from_le");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let le1 = U256::from_array([0x1234, 0x5678, 0x90ab, 0xcdef,
                    0x1122, 0x3344, 0x5566, 0x7788,
                    0x9900, 0xaabb, 0xccdd, 0xeeff,
                    0x1f2e, 0x3d4c, 0x5b6a, 0x7089]);
    let le2 = U256::from_le(le1.clone());
    println!("le1 = 0x{}", le1.to_string_with_radix(16).unwrap());
    println!("le2 = 0x{}", le2.to_string_with_radix(16).unwrap());
    #[cfg(target_endian = "little")]
    {
        assert_eq!(le1.to_string_with_radix(16).unwrap(), "70895B6A3D4C1F2EEEFFCCDDAABB99007788556633441122CDEF90AB56781234");
        assert_eq!(le2.to_string_with_radix(16).unwrap(), "70895B6A3D4C1F2EEEFFCCDDAABB99007788556633441122CDEF90AB56781234");
    }
    #[cfg(target_endian = "big")]
    {
        assert_eq!(le1.to_string_with_radix(16).unwrap(), "1234567890ABCDEF11223344556677889900AABBCCDDEEFF1F2E3D4C5B6A7089");
        assert_eq!(le2.to_string_with_radix(16).unwrap(), "34127856AB90EFCD22114433665588770099BBAADDCCFFEE2E1F4C3D6A5B8970");
    }
    println!("---------------------------");
}

fn biguint_from_le_bytes()
{
    println!("biguint_from_le_bytes");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let le_array = [0x12345678, 0x90abcdef, 0x11223344, 0x55667788,
                    0x9900aabb, 0xccddeeff, 0x1f2e3d4c, 0x5b6a7089];
    let le = U256::from_le_bytes(le_array.clone());
    print!("le_array = ");
    for elem in le_array
        { print!("0x{:8x} ", elem); }
    println!();
    println!("le = 0x{}", le.to_string_with_radix_and_stride_and_delimiter(16, 8, " 0x").unwrap());
    #[cfg(target_endian = "little")]    assert_eq!(le.to_string_with_radix_and_stride(16, 8).unwrap(), "5B6A7089_1F2E3D4C_CCDDEEFF_9900AABB_55667788_11223344_90ABCDEF_12345678");
    #[cfg(target_endian = "big")]       assert_eq!(le.to_string_with_radix(16).unwrap(), "12345678_90ABCDEF_11223344_55667788_9900AABB_CCDDEEFF_1F2E3D4C_5B6A7089");
    println!("---------------------------");
}

fn biguint_from_string()
{
    println!("biguint_from_string");
    use std::fmt::Write as _;
    use cryptocol::number::NumberErr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Example for correct case
    let a_correct = U256::from_string("1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890");
    match a_correct
    {
        Ok(n) => {
                println!("a_correct = {}", n);
                assert_eq!(n.to_string(), "1234567890123456789012345678901234567890123456789012345678901234567890");
            },
        Err(e) => {
                match e
                {
                    NumberErr::NotAlphaNumeric =>  { println!("Failed: Not alphanumeric!") },
                    NumberErr::NotFitToRadix =>    { println!("Failed: Not decimal number!") },
                    NumberErr::TooBigNumber =>     { println!("Failed: Too big number!") },
                    _ => {},
                }
            },
    }

    // Example for NumberErr::NotAlphaNumeric case
    let b_contains_non_alphanumeric = U256::from_string("12345+67890");
    match b_contains_non_alphanumeric
    {
        Ok(n) =>  { println!("a_correct = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::NotAlphaNumeric => {
                        println!("Failed: Not alphanumeric!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", b_contains_non_alphanumeric).unwrap();
                        assert_eq!(txt, "Err(NotAlphaNumeric)");
                    },
                NumberErr::NotFitToRadix =>    { println!("Failed: Not decimal number!"); },
                NumberErr::TooBigNumber =>     { println!("Failed: Too big number!"); },
                _ => {},
            }
        },
    }
    
    // Example for NumberErr::NotFitToRadix case
    let c_constains_not_fit_to_radix = U256::from_string("1234567890a");
    match c_constains_not_fit_to_radix
    {
        Ok(n) =>  { println!("c_constains_not_fit_to_radix = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::NotAlphaNumeric =>  { println!("Failed: Not alphanumeric!"); },
                NumberErr::NotFitToRadix => {
                        println!("Failed: Not decimal number!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", c_constains_not_fit_to_radix).unwrap();
                        assert_eq!(txt, "Err(NotFitToRadix)");
                    },
                    NumberErr::TooBigNumber =>     { println!("Failed: Too big number!"); },
                _ => {},
            }
        },
    }

    // Example for NumberErr::TooBigNumber case
    let d_constains_too_big_number = U256::from_string("1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890");
    match d_constains_too_big_number
    {
        Ok(n) =>  { println!("c_constains_too_big_number = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::NotAlphaNumeric =>  { println!("Failed: Not alphanumeric!"); },
                NumberErr::NotFitToRadix =>    { println!("Failed: Not decimal number!"); },
                NumberErr::TooBigNumber => {
                        println!("Failed: Too big number!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", d_constains_too_big_number).unwrap();
                        assert_eq!(txt, "Err(TooBigNumber)");
                    },
                _ => {},
            }
        },
    }

    // Example for NumberErr::NotAlphaNumeric and NumberErr::NotFitToRadix case
    let e_contains_non_alphanumeric_not_fit_to_radix = U256::from_string("F12345+67890");
    match e_contains_non_alphanumeric_not_fit_to_radix
    {
        Ok(n) =>  { println!("e_contains_non_alphanumeric_not_fit_to_radix = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::NotAlphaNumeric => {
                        println!("Failed: Not alphanumeric!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", e_contains_non_alphanumeric_not_fit_to_radix).unwrap();
                        assert_eq!(txt, "Err(NotAlphaNumeric)");
                    },
                NumberErr::NotFitToRadix =>    { println!("Failed: Not decimal number!"); },
                NumberErr::TooBigNumber =>     { println!("Failed: Too big number!"); },
                _ => {},
            }
        },
    }
    println!("---------------------------");
}

fn biguint_from_str_radix()
{
    println!("biguint_from_str_radix");
    use std::fmt::Write as _;
    use cryptocol::number::NumberErr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Example for correct case
    let a_correct = U512::from_str_radix("1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0", 16);
    match a_correct
    {
        Ok(n) => {
                println!("a_correct = {}", n);
                assert_eq!(n.to_string_with_radix_and_stride(16, 4).unwrap(), "1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0");
            },
        Err(e) => {
                match e
                {
                    NumberErr::OutOfValidRadixRange =>  { println!("Failed: Out of Valid Radix Range!") },
                    NumberErr::NotAlphaNumeric =>       { println!("Failed: Not alphanumeric!") },
                    NumberErr::NotFitToRadix =>         { println!("Failed: Not decimal number!") },
                    NumberErr::TooBigNumber =>          { println!("Failed: Too big number!") },
                }
            },
    }

    // Example for NumberErr::OutOfValidRadixRange case
    let b_contains_out_of_valid_radix_range = U512::from_str_radix("1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0", 63);
    match b_contains_out_of_valid_radix_range
    {
        Ok(n) =>  { println!("a_correct = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::OutOfValidRadixRange => {
                        println!("Failed: Out of Valid Radix Range!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", b_contains_out_of_valid_radix_range).unwrap();
                        assert_eq!(txt, "Err(OutOfValidRadixRange)");
                    },
                NumberErr::NotAlphaNumeric =>   { println!("Failed: Not alphanumeric!"); },
                NumberErr::NotFitToRadix =>     { println!("Failed: Not decimal number!"); },
                NumberErr::TooBigNumber =>      { println!("Failed: Too big number!"); },
            }
        },
    }

    // Example for NumberErr::NotAlphaNumeric case
    let c_contains_non_alphanumeric = U512::from_str_radix("1234-5678-9ABC-DEF0-1234-5678-9ABC-DEF0-1234-5678-9ABC-DEF0-1234-5678-9ABC-DEF0-1234-5678-9ABC-DEF0-1234-5678-9ABC-DEF0-1234-5678-9ABC-DEF0-1234-5678-9ABC-DEF0", 16);
    match c_contains_non_alphanumeric
    {
        Ok(n) =>  { println!("a_correct = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::OutOfValidRadixRange => { println!("Failed: Out of Valid Radix Range!") },
                NumberErr::NotAlphaNumeric => {
                        println!("Failed: Not alphanumeric!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", c_contains_non_alphanumeric).unwrap();
                        assert_eq!(txt, "Err(NotAlphaNumeric)");
                    },
                NumberErr::NotFitToRadix => { println!("Failed: Not decimal number!"); },
                NumberErr::TooBigNumber =>  { println!("Failed: Too big number!"); },
            }
        },
    }
    
    // Example for NumberErr::NotFitToRadix case
    let d_constains_not_fit_to_radix = U512::from_str_radix("1234_5678_9ABC_DEFG_1234_5678_9ABC_DEFG_1234_5678_9ABC_DEFG_1234_5678_9ABC_DEFG_1234_5678_9ABC_DEFG_1234_5678_9ABC_DEFG_1234_5678_9ABC_DEFG_1234_5678_9ABC_DEFG", 16);
    match d_constains_not_fit_to_radix
    {
        Ok(n) =>  { println!("d_constains_not_fit_to_radix = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::OutOfValidRadixRange =>  { println!("Failed: Out of Valid Radix Range!") },
                NumberErr::NotAlphaNumeric =>       { println!("Failed: Not alphanumeric!"); },
                NumberErr::NotFitToRadix => {
                        println!("Failed: Not hexadecimal number!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", d_constains_not_fit_to_radix).unwrap();
                        assert_eq!(txt, "Err(NotFitToRadix)");
                    },
                    NumberErr::TooBigNumber =>     { println!("Failed: Too big number!"); },
            }
        },
    }

    // Example for NumberErr::TooBigNumber case
    let e_constains_too_big_number = U512::from_str_radix("1_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0_1234_5678_9ABC_DEF0", 16);
    match e_constains_too_big_number
    {
        Ok(n) =>  { println!("c_constains_too_big_number = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::OutOfValidRadixRange =>  { println!("Failed: Out of Valid Radix Range!") },
                NumberErr::NotAlphaNumeric =>       { println!("Failed: Not alphanumeric!"); },
                NumberErr::NotFitToRadix =>         { println!("Failed: Not decimal number!"); },
                NumberErr::TooBigNumber => {
                        println!("Failed: Too big number!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", e_constains_too_big_number).unwrap();
                        assert_eq!(txt, "Err(TooBigNumber)");
                    },
            }
        },
    }

    // Example for NumberErr::NotAlphaNumeric, NumberErr::NotFitToRadix, and NumberErr::TooBigNumber case
    let f_contains_non_alphanumeric_not_fit_to_radix = U512::from_str_radix("1,1234,5678,9ABC,DEFG,1234,5678,9ABC,DEFG,1234,5678,9ABC,DEFG,1234,5678,9ABC,DEFG,1234,5678,9ABC,DEFG,1234,5678,9ABC,DEFG,1234,5678,9ABC,DEFG,1234,5678,9ABC,DEFG", 16);
    match f_contains_non_alphanumeric_not_fit_to_radix
    {
        Ok(n) =>  { println!("f_contains_non_alphanumeric_not_fit_to_radix = {}", n); },
        Err(e) => {
            match e
            {
                NumberErr::OutOfValidRadixRange =>  { println!("Failed: Out of Valid Radix Range!") },
                NumberErr::NotAlphaNumeric => {
                        println!("Failed: Not alphanumeric!");
                        let mut txt = String::new();
                        write!(&mut txt, "{:?}", f_contains_non_alphanumeric_not_fit_to_radix).unwrap();
                        assert_eq!(txt, "Err(NotAlphaNumeric)");
                    },
                NumberErr::NotFitToRadix =>    { println!("Failed: Not decimal number!"); },
                NumberErr::TooBigNumber =>     { println!("Failed: Too big number!"); },
            }
        },
    }
    println!("---------------------------");
}

fn biguint_generate_check_bits()
{
    println!("biguint_generate_check_bits");
    use cryptocol::define_utypes_with_u32;
    define_utypes_with_u32!();

    let a_0 = U256::generate_check_bits(0).unwrap();
    println!("a_0 = {}", a_0.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(a_0.to_string_with_radix_and_stride(2, 10).unwrap(), "1");
    
    let a_12 = U256::generate_check_bits(12).unwrap();
    println!("a_12 = {}", a_12.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(a_12.to_string_with_radix_and_stride(2, 10).unwrap(), "100_0000000000");

    let a_255 = U256::generate_check_bits(255).unwrap();
    println!("a_255 = {}", a_255.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(a_255.to_string_with_radix_and_stride(2, 10).unwrap(), "100000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000");

    let a_256 = U256::generate_check_bits(256);
    println!("a_256 = {:?}", a_256);
    assert_eq!(a_256, None);
    println!("---------------------------");
}

fn biguint_generate_check_bits_()
{
    println!("biguint_generate_check_bits_");
    use cryptocol::define_utypes_with_u32;
    define_utypes_with_u32!();

    let a_0 = U256::generate_check_bits_(0);
    println!("a_0 = {}", a_0.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(a_0.to_string_with_radix_and_stride(2, 10).unwrap(), "1");
    
    let a_12 = U256::generate_check_bits_(12);
    println!("a_12 = {}", a_12.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(a_12.to_string_with_radix_and_stride(2, 10).unwrap(), "100_0000000000");

    let a_255 = U256::generate_check_bits_(255);
    println!("a_255 = {}", a_255.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(a_255.to_string_with_radix_and_stride(2, 10).unwrap(), "100000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000_0000000000");

    #[cfg(test)] // It will panic.
    biguint_should_panic_generate_check_bits_();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_generate_check_bits_()
{
    use cryptocol::define_utypes_with_u32;
    define_utypes_with_u32!();

    let _a_256 = U256::generate_check_bits_(256);
}

fn biguint_get_size_main()
{
    biguint_size_in_bytes();
    biguint_size_in_bits();
    biguint_length_in_bytes();
    biguint_length_in_bits();
}

fn biguint_size_in_bytes()
{
    println!("biguint_size_in_bytes");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    println!("U256 is {}-byte integer.", U256::size_in_bytes());
    assert_eq!(U256::size_in_bytes(), 32);
    println!("---------------------------");
}

fn biguint_size_in_bits()
{
    println!("biguint_size_in_bits");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    println!("U256 is {}-bit integer.", U256::size_in_bits());
    assert_eq!(U256::size_in_bits(), 256);
    println!("---------------------------");
}

fn biguint_length_in_bytes()
{
    println!("biguint_length_in_bytes");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a = U256::from_str_radix("A16F", 16).unwrap();
    println!("a is {}-byte integer.", a.length_in_bytes());
    assert_eq!(a.length_in_bytes(), 32);
    println!("---------------------------");
}

fn biguint_length_in_bits()
{
    println!("biguint_length_in_bits");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a = U256::from_str_radix("A16F", 16).unwrap();
    println!("a is {}-bit integer.", a.length_in_bits());
    assert_eq!(a.length_in_bits(), 256);
    println!("---------------------------");
}

fn biguint_get_set_check_main()
{
    biguint_turn_check_bits();
    biguint_is_bit_set();
    biguint_is_bit_set_();
    biguint_get_upper_portion();
    biguint_get_lower_portion();
    biguint_get_num();
    biguint_get_num_();
    biguint_set_num();
    biguint_set_num_();
    biguint_get_number();
    #[cfg(target_endian = "big")]   biguint_get_number_mut();
    biguint_set_number();
    // biguint_copy_within();
    biguint_set_zero();
    biguint_is_zero();
    biguint_set_one();
    biguint_is_one();
    biguint_is_zero_or_one();
    biguint_set_max();
    biguint_set_submax();
    biguint_set_halfmax();
    biguint_is_max();
    biguint_set_msb();
    biguint_set_lsb();
    biguint_set_uint();
    biguint_is_uint();
    biguint_is_odd();
    biguint_is_even();
    biguint_is_msb_set();
}

fn biguint_turn_check_bits()
{
    println!("biguint_turn_check_bits");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a = U256::from_string("256487951236974125896345564889974258").unwrap();
    println!("a = {}", a.to_string_with_radix_and_stride(2, 8).unwrap());
    a.turn_check_bits(102);
    println!("a = {}", a.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a, U256::from_str_radix("1000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000", 2).unwrap());

    #[cfg(test)] // It will panic.
    biguint_should_panic_turn_check_bits();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_turn_check_bits()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut _a = U256::from_string("256487951236974125896345564889974258").unwrap();
    println!("a = {}", _a.to_string_with_radix_and_stride(2, 8).unwrap());
    _a.turn_check_bits(256);
}

fn biguint_is_bit_set()
{
    println!("biguint_is_bit_set");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a = U256::from_string("12345678912345678912345678912345678912345678912345678912345678912345678912345").unwrap();
    println!("a = {}_U256", a.to_string_with_radix_and_stride(2, 10).unwrap());
    let mut res = a.is_bit_set(151);
    match res
    {
        Some(r) => {
            println!("The {}th bit is set: {}", 151, r);
            assert_eq!(a.is_bit_set(151).unwrap(), true);
        },
        None => { println!("{}_U256 does not have the {}th bit.", a, 151); }
    }

    res = a.is_bit_set(200);
    match res
    {
        Some(r) => {
            println!("The {}th bit is set: {}", 200, r);
            assert_eq!(a.is_bit_set(200).unwrap(), false);
        },
        None => { println!("{}_U256 does not have the {}th bit.", a, 200); }
    }

    res = a.is_bit_set(300);
    match res
    {
        Some(r) => { println!("The {}th bit is set: {}", 300, r); },
        None => {
            println!("{}_U256 does not have the {}th bit.", a, 300);
            assert_eq!(a.is_bit_set(300), None);
        }
    }
    println!("---------------------------");
}

fn biguint_is_bit_set_()
{
    println!("biguint_is_bit_set_");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a = U256::from_string("12345678912345678912345678912345678912345678912345678912345678912345678912345").unwrap();
    println!("a = {}_U256", a.to_string_with_radix_and_stride(2, 10).unwrap());
    println!("The {}th bit is set: {}", 151, a.is_bit_set_(151));
    assert_eq!(a.is_bit_set_(151), true);
    println!("The {}th bit is set: {}", 200, a.is_bit_set_(200));
    assert_eq!(a.is_bit_set_(200), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_is_bit_set_();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_is_bit_set_()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let _a = U256::from_string("12345678912345678912345678912345678912345678912345678912345678912345678912345").unwrap();
    println!("The {}th bit is set: {}", 300, _a.is_bit_set_(300));
}

fn biguint_get_upper_portion()
{
    println!("biguint_get_upper_portion");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a = U256::from_string("12345678912345678912345678912345678912345678912345678912345678912345678912345").unwrap();
    let b = a.get_upper_portion(10);
    println!("The 10-bit upper portion of {}_U256 is {}_U256", a.to_string_with_radix_and_stride(2, 10).unwrap(), b.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(b.to_string_with_radix_and_stride(2, 10).unwrap(), "1101101001");
    println!("---------------------------");
}

fn biguint_get_lower_portion()
{
    println!("biguint_get_lower_portion");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a = U256::from_string("12345678912345678912345678912345678912345678912345678912345678912345678912340").unwrap();
    let b = a.get_lower_portion(10);
    println!("The 10-bit lower portion of {}_U256 is {}_U256", a.to_string_with_radix_and_stride(2, 10).unwrap(), b.to_string_with_radix_and_stride(2, 10).unwrap());
    assert_eq!(b.to_string_with_radix_and_stride(2, 10).unwrap(), "1101010100");
    println!("---------------------------");
}

fn biguint_get_num()
{
    println!("biguint_get_num");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a = U256::from([0_u32, 10, 20, 30, 40, 50, 60, 70]);
    match a.get_num(3)
    {
        Some(num) => {
            println!("a.get_num(3).unwrap() = {}", num);
            assert_eq!(num, 30);
        },
        None => {
            println!("There is no third element.");
        },
    }

    let f = a.get_num(8);
    match f
    {
        Some(num) => {
            println!("a.get_num(3).unwrap() = {}", num);
        },
        None => {
            println!("There is no third element.");
            assert_eq!(f, None);
        },
    }
    println!("---------------------------");
}

fn biguint_get_num_()
{
    println!("biguint_get_num_");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a = U256::from([0_u32, 10, 20, 30, 40, 50, 60, 70]);
    let b = a.get_num_(3);
    println!("a.get_num_(3) = {}", b);
    assert_eq!(b, 30);

    #[cfg(test)] // It will panic.
    biguint_should_panic_get_num_();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_get_num_()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _a = U256::from([0_u32, 10, 20, 30, 40, 50, 60, 70]);
    let _c = _a.get_num_(8);
}

fn biguint_set_num()
{
    println!("biguint_set_num");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a = U256::from([0_u64, 10, 20, 30]);
    let mut num = a.get_num_(3);
    println!("a.get_num(3).unwrap() = {}", num);
    let b = a.set_num(3, 0);
    assert!(b);
    num = a.get_num_(3);
    println!("a.get_num(3).unwrap() = {}", num);
    assert_eq!(num, 0);

    let c = a.set_num(4, 0);
    if !c
        { println!("There is no fourth element."); }
    assert!(!c);
    println!("---------------------------");
}

fn biguint_set_num_()
{
    println!("biguint_set_num_");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a = U256::from([10_u128, 20]);
    let mut num = a.get_num_(1);
    println!("a.get_num_(1) = {}", num);
    a.set_num_(1, 0);
    num = a.get_num_(1);
    println!("a.get_num_(1) = {}", num);
    assert_eq!(num, 0);

    #[cfg(test)] // It will panic.
    biguint_should_panic_set_num_();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_set_num_()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut _a = U256::from([10_u128, 20]);
    let _b = _a.set_num_(4, 0);
}

fn biguint_get_number()
{
    println!("biguint_get_number");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    if let Ok(a) = "12345678909876543210123456789098765432101234567890987654321012345678909876543".parse::<U256>()
    {
        let arr = a.get_number();
        println!("arr = {:?}", arr);
        assert_eq!(arr, &[169027903, 1302152522, 3897323189, 3259190507, 1179716839, 4196280276, 2015458651, 457926681]);
    }
    println!("---------------------------");
}

#[cfg(target_endian = "big")]
fn biguint_get_number_mut()
{
    println!("biguint_get_number_mut");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    if let Ok(a) = "12345678909876543210123456789098765432101234567890987654321012345678909876543".parse::<U256>()
    {
        let arr = a.get_number_mut();
        println!("arr = {:?}", arr);
        assert_eq!(arr, &[169027903, 1302152522, 3897323189, 3259190507, 1179716839, 4196280276, 2015458651, 457926681]);
    }
    println!("---------------------------");
}

fn biguint_set_number()
{
    println!("biguint_set_number");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a = U256::new();
    println!("arr = {:?}", a);
    let arr = [1_u16, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
    a.set_number(&arr);
    println!("arr = {:?}", a);
    assert_eq!(a.get_number(), &arr);
    println!("---------------------------");
}

// fn biguint_copy_within()
// {
//     println!("biguint_copy_within");
//     use cryptocol::define_utypes_with;
//     define_utypes_with!(u16);
//     let mut a = U256::new();
//     a.set_number(&[0_u16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
//     println!("a = {:?}", a);
//     a.copy_within(3..10, 6);
//     println!("a = {:?}", a);
//     assert_eq!(a.get_number(), &[0, 1, 2, 3, 4, 5, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15]);
//     println!("---------------------------");
// }

fn biguint_set_zero()
{
    println!("biguint_set_zero");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a = U256::new();
    a.set_number(&[1_u16, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
    println!("a = {}", a);
    a.set_zero();
    println!("a = {}", a);
    assert_eq!(a, U256::zero());
    println!("---------------------------");
}

fn biguint_is_zero()
{
    println!("biguint_is_zero");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a = U1024::zero();
    let mut b_zero = a.is_zero();
    if b_zero
    {
        println!("a is Zero");
        assert_eq!(b_zero, true);
    }
    else
    {
        println!("a is Not Zero");
    }

    a.set_one();
    b_zero = a.is_zero();
    if b_zero
    {
        println!("a is Zero");
    }
    else
    {
        println!("a is Not Zero");
        assert_eq!(b_zero, false);
    }
    println!("---------------------------");
}

fn biguint_set_one()
{
    println!("biguint_set_one");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a = U256::new();
    a.set_number(&[1_u16, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
    println!("a = {}", a);
    a.set_one();
    println!("a = {}", a);
    assert_eq!(a, U256::one());
    println!("---------------------------");
}

fn biguint_is_one()
{
    println!("biguint_is_one");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    
    let mut a = U256::one();
    let mut b_one = a.is_one();
    if b_one
    {
        println!("a is One");
        assert_eq!(b_one, true);
    }
    else
    {
        println!("a is Not One");
    }

    a.set_max();
    b_one = a.is_one();
    if b_one
    {
        println!("a is One");
    }
    else
    {
        println!("a is Not One");
        assert_eq!(b_one, false);
    }
    println!("---------------------------");
}

fn biguint_is_zero_or_one()
{
    println!("biguint_is_zero_or_one");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a = U256::zero();
    println!("a = {}", a);
    let b_zero_or_one = a.is_zero_or_one();
    if b_zero_or_one
    {
        println!("a is One or Zero.");
        assert_eq!(b_zero_or_one, true);
    }
    else
    {
        println!("a is Neither One nor Zero.");
    }

    let a = U256::one();
    println!("a = {}", a);
    let b_zero_or_one = a.is_zero_or_one();
    if b_zero_or_one
    {
        println!("a is One or Zero.");
    }
    else
    {
        println!("a is Neither One nor Zero.");
        assert_eq!(b_zero_or_one, true);
    }

    let mut a = U256::one();
    a.wrapping_add_assign_uint(1_u8);
    println!("a = {}", a);
    let b_zero_or_one = a.is_zero_or_one();
    if b_zero_or_one
    {
        println!("a is One or Zero.");
    }
    else
    {
        println!("a is Neither One nor Zero.");
        assert_eq!(b_zero_or_one, false);
    }
    println!("---------------------------");
}

fn biguint_set_max()
{
    println!("biguint_set_max");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a = U256::new();
    println!("a = {}", a);
    a.set_max();
    println!("a = {}", a.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(a.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF");
    println!("---------------------------");
}

fn biguint_set_submax()
{
    println!("biguint_set_submax");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a = U256::new();
    println!("a = {}", a);
    a.set_submax(200_usize);
    println!("a = {}", a.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(a.to_string_with_radix_and_stride(16, 8).unwrap(), "FF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF");
    println!("---------------------------");
}

fn biguint_set_halfmax()
{
    println!("biguint_set_halfmax");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a = U256::new();
    println!("a = {}", a);
    a.set_halfmax();
    println!("a = {}", a.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(a.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF");
    println!("---------------------------");
}

fn biguint_is_max()
{
    println!("biguint_is_max");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a = U256::max();
    println!("Is {} a 256-bit maximum? - {}", a, a.is_max());
    assert_eq!(a.is_max(), true);

    let b = U256::max().wrapping_sub_uint(1_u8);
    println!("Is {} a 256-bit maximum? - {}", b, b.is_max());
    assert_eq!(b.is_max(), false);
    println!("---------------------------");
}

fn biguint_set_msb()
{
    println!("biguint_set_msb");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a = U256::new();
    println!("a = {}", a);
    a.set_msb();
    println!("a = {}", a);
    assert_eq!(a.to_string_with_radix_and_stride(2, 8).unwrap(), "10000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    println!("---------------------------");
}

fn biguint_set_lsb()
{
    println!("biguint_set_lsb");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a = U256::new();
    println!("a = {}", a);
    a.set_lsb();
    println!("a = {}", a);
    assert_eq!(a.to_string_with_radix_and_stride(2, 8).unwrap(), "1");
    println!("---------------------------");
}

fn biguint_set_uint()
{
    println!("biguint_set_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a = U1024::new();
    println!("a = {}", a);
    a.set_uint(340282366920938463453374607431768211455_u128);
    println!("a = {}", a);
    assert_eq!(a.to_string(), "340282366920938463453374607431768211455");
    println!("---------------------------");
}

fn biguint_is_uint()
{
    println!("biguint_is_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a = U1024::one() + 50_u16;
    println!("Question: Is a 51?\nAnswer: {}", a.is_uint(51_u32));
    assert_eq!(a.is_uint(51_u16), true);
    assert_eq!(a.is_uint(50_u16), false);
    println!("---------------------------");
}

fn biguint_is_odd()
{
    println!("biguint_is_odd");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a = U256::new();
    a.set_uint(340282366920938463453374697431768211455_u128);
    if a.is_odd()
        { println!("{} is odd", a); }
    else
        { println!("{} is even", a); }
    assert_eq!(a.is_odd(), true);

    a <<= 1;
    if a.is_odd()
        { println!("{} is odd", a); }
    else
        { println!("{} is even", a); }
    assert_eq!(a.is_odd(), false);
    println!("---------------------------");
}

fn biguint_is_even()
{
    println!("biguint_is_even");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a = U256::new();
    a.set_uint(169743176821145534028236692093846345739_u128);
    if a.is_even()
        { println!("{} is even", a); }
    else
        { println!("{} is odd", a); }
    assert_eq!(a.is_even(), false);

    a <<= 1;
    if a.is_even()
        { println!("{} is even", a); }
    else
        { println!("{} is odd", a); }
    assert_eq!(a.is_even(), true);
    println!("---------------------------");
}

fn biguint_is_msb_set()
{
    println!("fn biguint_is_msb_set()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    
    let mut a = U256::new();
    a.set_uint(169743176821145534028236692093846345739_u128);
    if a.is_msb_set()
        { println!("{} is greater than halfmax ({}).", a, U256::halfmax()); }
    else
        { println!("{} is less than or equal to halfmax ({}).", a, U256::halfmax()); }
    assert_eq!(a.is_msb_set(), false);

    a.set_msb();
    if a.is_msb_set()
        { println!("{} is greater than halfmax ({}).", a, U256::halfmax()); }
    else
        { println!("{} is less than or equal to halfmax ({}).", a, U256::halfmax()); }
    assert_eq!(a.is_msb_set(), true);
    println!("---------------------------");
}

fn biguint_check_bits_main()
{
    biguint_count_ones();
    biguint_count_zeros();
    biguint_leading_ones();
    biguint_leading_zeros();
    biguint_trailing_ones();
    biguint_trailing_zeros();
    biguint_leading_max_elements();
    biguint_leading_zero_elements();
    biguint_trailing_max_elements();
    biguint_trailing_zero_elements();
}

fn biguint_count_ones()
{
    println!("biguint_count_ones");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a = U256::from_str("100000000000000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    println!("{} is {} in binary and has {} ones in binary.", a, a.to_string_with_radix_and_stride(2, 10).unwrap(), a.count_ones());
    assert_eq!(a.count_ones(), 107);
    println!("---------------------------");
}

fn biguint_count_zeros()
{
    println!("biguint_count_zeros");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a = "100000000000000000000000000000000000000000000000000000000000000000000000000000".parse::<U256>().unwrap();
    println!("{} is {} in binary and has {} zeros in binary.", a, a.to_string_with_radix_and_stride(2, 10).unwrap(), a.count_zeros());
    assert_eq!(a.count_zeros(), 149);
    println!("---------------------------");
}

fn biguint_leading_ones()
{
    println!("biguint_leading_ones");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a = U256::from_str("100000000000000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    println!("{} is {} in binary and has {} leading ones in binary.", a, a.to_string_with_radix_and_stride(2, 10).unwrap(), a.leading_ones());
    assert_eq!(a.leading_ones(), 2);
    println!("---------------------------");
}

fn biguint_leading_zeros()
{
    println!("biguint_leading_zeros");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a = "100000000000000000000000000000000000000000000000000000000000000000000000000000".parse::<U256>().unwrap();
    println!("{} is {} in binary and has {} leading zeros in binary.", a, a.to_string_with_radix_and_stride(2, 10).unwrap(), a.leading_zeros());
    assert_eq!(a.leading_zeros(), 0);
    println!("---------------------------");
}

fn biguint_trailing_ones()
{
    println!("biguint_trailing_ones");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a = U256::from_str("111111111111111111111111111111111111111111111111111111111111111111111111111111").unwrap();
    println!("{} is {} in binary and has {} trailing ones in binary.", a, a.to_string_with_radix_and_stride(2, 10).unwrap(), a.trailing_ones());
    assert_eq!(a.trailing_ones(), 3);
    println!("---------------------------");
}

fn biguint_trailing_zeros()
{
    println!("biguint_trailing_zeros");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a = "111111111111111111111111111111111111111111111111111111111111111111111111111111".parse::<U256>().unwrap();
    println!("{} is {} in binary and has {} trailing zeros in binary.", a, a.to_string_with_radix_and_stride(2, 10).unwrap(), a.trailing_zeros());
    assert_eq!(a.trailing_zeros(), 0);
    println!("---------------------------");
}

fn biguint_leading_max_elements()
{
    println!("biguint_leading_max_elements");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a = U256::from_str_radix("FFFFFFFF_EEEEEEEE_DDDDDDDD_CCCCCCCC_BBBBBBBB_AAAAAAAA_99999999_88888888", 16).unwrap();
    println!("{} is {} in hexadecimal and has {} leading max elements in array.", a, a.to_string_with_radix_and_stride(16, 2).unwrap(), a.leading_max_elements());
    assert_eq!(a.leading_max_elements(), 4);
    println!("---------------------------");
}

fn biguint_leading_zero_elements()
{
    println!("biguint_leading_zero_elements");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a = U256::from_str_radix("00000000_FFFFFFFF_EEEEEEEE_DDDDDDDD_CCCCCCCC_BBBBBBBB_AAAAAAAA_99999999", 16).unwrap();
    println!("{} is {} in hexadecimal and has {} leading zero elements in array.", a, a.to_string_with_radix_and_stride(16, 8).unwrap(), a.leading_zero_elements());
    assert_eq!(a.leading_zero_elements(), 1);
    println!("---------------------------");
}

fn biguint_trailing_max_elements()
{
    println!("biguint_trailing_max_elements");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a = U256::from_str_radix("88888888_99999999_AAAAAAAA_BBBBBBBB_CCCCCCCC_DDDDDDDD_EEEEEEEE_FFFFFFFF", 16).unwrap();
    println!("{} is {} in hexadecimal and has {} trailing max elements in array.", a, a.to_string_with_radix_and_stride(16, 4).unwrap(),a.trailing_max_elements());
    assert_eq!(a.trailing_max_elements(), 2);
    println!("---------------------------");
}

fn biguint_trailing_zero_elements()
{
    println!("biguint_trailing_zero_elements");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a = U256::from_str_radix("FFFFFFFF_EEEEEEEE_DDDDDDDD_CCCCCCCC_BBBBBBBB_AAAAAAAA_9999999_900000000", 16).unwrap();
    println!("{} is {} in hexadecimal and has {} trailing zero elements in array.", a, a.to_string_with_radix_and_stride(16, 2).unwrap(),a.trailing_zero_elements());
    assert_eq!(a.trailing_zero_elements(), 4);
    println!("---------------------------");
}

fn biguint_comparison_uint_main()
{
    biguint_partial_cmp_uint();
    biguint_lt_uint();
    biguint_gt_uint();
    biguint_le_uint();
    biguint_ge_uint();
    biguint_eq_uint();
}

fn biguint_partial_cmp_uint()
{
    println!("biguint_partial_cmp_uint");
    use std::cmp::Ordering;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let res = UU32::from_uint(100_u8).partial_cmp_uint(90_u128).unwrap();
    match res
    {
        Ordering::Greater => { println!("100 > 90"); }
        Ordering::Less => { println!("100 < 90"); }
        Ordering::Equal => { println!("100 = 90"); }
    }
    assert_eq!(res, Ordering::Greater);

    let res = UU32::from_uint(100_u8).partial_cmp_uint(110_u128).unwrap();
    match res
    {
        Ordering::Greater => { println!("100 > 110"); }
        Ordering::Less => { println!("100 < 110"); }
        Ordering::Equal => { println!("100 = 110"); }
    }
    assert_eq!(res, Ordering::Less);

    let res = UU32::from_uint(100_u8).partial_cmp_uint(100_u128).unwrap();
    match res
    {
        Ordering::Greater => { println!("100 > 100"); }
        Ordering::Less => { println!("100 < 100"); }
        Ordering::Equal => { println!("100 = 100"); }
    }
    assert_eq!(res, Ordering::Equal);
    println!("---------------------------");
}

fn biguint_lt_uint()
{
    println!("biguint_lt_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint.lt_uint(b_uint);
    if res
        { println!("{} < {}", a_biguint, b_uint); }
    else
        { println!("{} >= {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint.lt_uint(b_uint);
    if res
        { println!("{} < {}", a_biguint, b_uint); }
    else
        { println!("{} >= {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint.lt_uint(b_uint);
    if res
        { println!("{} < {}", a_biguint, b_uint); }
    else
        { println!("{} >= {}", a_biguint, b_uint); }
    assert_eq!(res, false);
    println!("---------------------------");
}

fn biguint_gt_uint()
{
    println!("biguint_gt_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint.gt_uint(b_uint);
    if res
        { println!("{} > {}", a_biguint, b_uint); }
    else
        { println!("{} <= {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint.gt_uint(b_uint);
    if res
        { println!("{} > {}", a_biguint, b_uint); }
    else
        { println!("{} <= {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint.gt_uint(b_uint);
    if res
        { println!("{} > {}", a_biguint, b_uint); }
    else
        { println!("{} <= {}", a_biguint, b_uint); }
    assert_eq!(res, false);
    println!("---------------------------");
}

fn biguint_le_uint()
{
    println!("biguint_le_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint.le_uint(b_uint);
    if res
        { println!("{} <= {}", a_biguint, b_uint); }
    else
        { println!("{} > {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint.le_uint(b_uint);
    if res
        { println!("{} <= {}", a_biguint, b_uint); }
    else
        { println!("{} > {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint.le_uint(b_uint);
    if res
        { println!("{} <= {}", a_biguint, b_uint); }
    else
        { println!("{} > {}", a_biguint, b_uint); }
    assert_eq!(res, true);
    println!("---------------------------");
}

fn biguint_ge_uint()
{
    println!("biguint_ge_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint.ge_uint(b_uint);
    if res
        { println!("{} >= {}", a_biguint, b_uint); }
    else
        { println!("{} < {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint.ge_uint(b_uint);
    if res
        { println!("{} >= {}", a_biguint, b_uint); }
    else
        { println!("{} < {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint.ge_uint(b_uint);
    if res
        { println!("{} >= {}", a_biguint, b_uint); }
    else
        { println!("{} < {}", a_biguint, b_uint); }
    assert_eq!(res, true);
    println!("---------------------------");
}

fn biguint_eq_uint()
{
    println!("biguint_eq_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint.eq_uint(b_uint);
    if res
        { println!("{} == {}", a_biguint, b_uint); }
    else
        { println!("{} != {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint.eq_uint(b_uint);
    if res
        { println!("{} == {}", a_biguint, b_uint); }
    else
        { println!("{} != {}", a_biguint, b_uint); }
    assert_eq!(res, false);
    println!("---------------------------");
}

fn biguint_comparison_biguint_main()
{
    biguint_eq();
    biguint_partial_cmp();
    biguint_lt();
    biguint_gt();
    biguint_le();
    biguint_ge();
    biguint_eq();
}

fn biguint_partial_cmp()
{
    println!("biguint_partial_cmp");
    use std::cmp::Ordering;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let num_str1 = "70000000000000000000000000000000000000000000000000000000000000000000000000000";
    let num_str2 = "60000000000000000000000000000000000000000000000000000000000000000000000000000";
    let num_str3 = "80000000000000000000000000000000000000000000000000000000000000000000000000000";
    let num1 = num_str1.parse::<UU32>().unwrap();
    let num2 = num_str2.parse::<UU32>().unwrap();
    let num3 = num_str3.parse::<UU32>().unwrap();

    let res = num1.partial_cmp(&num2).unwrap();
    match res
    {
        Ordering::Greater => { println!("{} > {}", num1, num2); }
        Ordering::Less => { println!("{} < {}", num1, num2); }
        Ordering::Equal => { println!("{} = {}", num1, num2); }
    }
    assert_eq!(res, Ordering::Greater);

    let res = num1.partial_cmp(&num3).unwrap();
    match res
    {
        Ordering::Greater => { println!("{} > {}", num1, num3); }
        Ordering::Less => { println!("{} < {}", num1, num3); }
        Ordering::Equal => { println!("{} = {}", num1, num3); }
    }
    assert_eq!(res, Ordering::Less);

    let res = num1.partial_cmp(&num1).unwrap();
    match res
    {
        Ordering::Greater => { println!("{0} > {0}", num1); }
        Ordering::Less => { println!("{0} < {0}", num1); }
        Ordering::Equal => { println!("{0} = {0}", num1); }
    }
    assert_eq!(res, Ordering::Equal);
    println!("---------------------------");
}

fn biguint_lt()
{
    println!("biguint_lt");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint.lt(&b_biguint);
    if res
        { println!("{} < {}", a_biguint, b_biguint); }
    else
        { println!("{} >= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.lt(&b_biguint);
    if res
        { println!("{} < {}", a_biguint, b_biguint); }
    else
        { println!("{} >= {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.lt(&b_biguint);
    if res
        { println!("{} < {}", a_biguint, b_biguint); }
    else
        { println!("{} >= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);
    println!("---------------------------");
}

fn biguint_gt()
{
    println!("biguint_gt");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint.gt(&b_biguint);
    if res
        { println!("{} > {}", a_biguint, b_biguint); }
    else
        { println!("{} <= {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.gt(&b_biguint);
    if res
        { println!("{} > {}", a_biguint, b_biguint); }
    else
        { println!("{} <= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.gt(&b_biguint);
    if res
        { println!("{} > {}", a_biguint, b_biguint); }
    else
        { println!("{} <= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);
    println!("---------------------------");
}

fn biguint_le()
{
    println!("biguint_le_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint.le(&b_biguint);
    if res
        { println!("{} <= {}", a_biguint, b_biguint); }
    else
        { println!("{} > {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.le(&b_biguint);
    if res
        { println!("{} <= {}", a_biguint, b_biguint); }
    else
        { println!("{} > {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.le(&b_biguint);
    if res
        { println!("{} <= {}", a_biguint, b_biguint); }
    else
        { println!("{} > {}", a_biguint, b_biguint); }
    assert_eq!(res, true);
    println!("---------------------------");
}

fn biguint_ge()
{
    println!("biguint_ge");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint.ge(&b_biguint);
    if res
        { println!("{} >= {}", a_biguint, b_biguint); }
    else
        { println!("{} < {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.ge(&b_biguint);
    if res
        { println!("{} >= {}", a_biguint, b_biguint); }
    else
        { println!("{} < {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.ge(&b_biguint);
    if res
        { println!("{} >= {}", a_biguint, b_biguint); }
    else
        { println!("{} < {}", a_biguint, b_biguint); }
    assert_eq!(res, true);
    println!("---------------------------");
}

fn biguint_eq()
{
    println!("biguint_eq");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint.eq(&b_biguint);
    if res
        { println!("{} = {}", a_biguint, b_biguint); }
    else
        { println!("{} != {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint.eq(&b_biguint);
    if res
        { println!("{} = {}", a_biguint, b_biguint); }
    else
        { println!("{} != {}", a_biguint, b_biguint); }
    assert_eq!(res, false);
    println!("---------------------------");
}


fn biguint_arithmatic_operation_uint_main()
{
    biguint_add_uint();
    biguint_sub_uint();
    biguint_mul_uint();
    biguint_div_uint();
    biguint_rem_uint();
    biguint_next_multiple_uint();
}

fn biguint_add_uint()
{
    biguint_carrying_add_uint();
    biguint_carrying_add_assign_uint();
    biguint_wrapping_add_uint();
    biguint_wrapping_add_assign_uint();
    biguint_overflowing_add_uint();
    biguint_overflowing_add_assign_uint();
    biguint_checked_add_uint();
    biguint_unchecked_add_uint();
    biguint_saturating_add_uint();
    biguint_saturating_add_assign_uint();
    biguint_modular_add_uint();
    biguint_modular_add_assign_uint();
    biguint_panic_free_modular_add_uint();
    biguint_panic_free_modular_add_assign_uint();
}

fn biguint_carrying_add_uint()
{
    println!("biguint_carrying_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let num1 = UU32::from_str_radix(num_str1, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFF_u128;

    let (sum, carry) = num1.carrying_add_uint(num_uint, false);
    println!("{} + {} = {}\ncarry = {}", num1, num_uint, sum, carry);
    assert_eq!(sum.to_string(), "115761816335569101403435733562708448393664880666628652711615198738168793722605");
    assert_eq!(carry, false);
    assert_eq!(sum.is_overflow(), false);
    assert_eq!(sum.is_underflow(), false);
    assert_eq!(sum.is_divided_by_zero(), false);
    assert_eq!(sum.is_infinity(), false);
    assert_eq!(sum.is_undefined(), false);

    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let num1 = UU32::from_str_radix(num_str1, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFF_u128;

    let (sum, carry) = num1.carrying_add_uint(num_uint, true);
    println!("{} + {} = {}\ncarry = {}", num1, num_uint, sum, carry);
    assert_eq!(sum.to_string(), "115761816335569101403435733562708448393664880666628652711615198738168793722606");
    assert_eq!(carry, false);
    assert_eq!(sum.is_overflow(), false);
    assert_eq!(sum.is_underflow(), false);
    assert_eq!(sum.is_divided_by_zero(), false);
    assert_eq!(sum.is_infinity(), false);
    assert_eq!(sum.is_undefined(), false);

    let num_str2 = "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF";
    let num2 = UU32::from_str_radix(num_str2, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFF_u128;

    let (sum, carry) = num2.carrying_add_uint(num_uint, false);
    println!("{} + {} = {}\ncarry = {}", num2, num_uint, sum, carry);
    assert_eq!(sum.to_string(), "22774453838368691933710012711845097214");
    assert_eq!(carry, true);
    assert_eq!(sum.is_overflow(), true);
    assert_eq!(sum.is_underflow(), false);
    assert_eq!(sum.is_divided_by_zero(), false);
    assert_eq!(sum.is_infinity(), false);
    assert_eq!(sum.is_undefined(), false);

    let num_str2 = "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF";
    let num2 = UU32::from_str_radix(num_str2, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFF_u128;

    let (sum, carry) = num2.carrying_add_uint(num_uint, true);
    println!("{} + {} = {}\ncarry = {}", num2, num_uint, sum, carry);
    assert_eq!(sum.to_string(), "22774453838368691933710012711845097215");
    assert_eq!(carry, true);
    assert_eq!(sum.is_overflow(), true);
    assert_eq!(sum.is_underflow(), false);
    assert_eq!(sum.is_divided_by_zero(), false);
    assert_eq!(sum.is_infinity(), false);
    assert_eq!(sum.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_carrying_add_assign_uint()
{
    println!("biguint_carrying_add_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let num_uint = 0x9900AABB_CCDDEEFF_u64;
    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let mut num1 = U256::from_str_radix(num_str1, 16).unwrap();
    println!("Originally, num1 = {}", num1);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let carry = num1.carrying_add_assign_uint(num_uint, false);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    println!("After num1 += {},\tnum1 = {}\tcarry = {}", num_uint, num1, carry);
    assert_eq!(num1.to_string(), "115761816335569101403435733562708448393642106212790284019692513725068324302573");
    assert_eq!(carry, false);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let num_uint = 0x9900AABB_CCDDEEFF_u64;
    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let mut num1 = U256::from_str_radix(num_str1, 16).unwrap();
    println!("Originally, num1 = {}", num1);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let carry = num1.carrying_add_assign_uint(num_uint, true);
    println!("After num1 += {},\tnum1 = {}\tcarry = {}", num_uint, num1, carry);
    assert_eq!(num1.to_string(), "115761816335569101403435733562708448393642106212790284019692513725068324302574");
    assert_eq!(carry, false);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let num_uint = 0x9900AABB_CCDDEEFF_u64;
    let num_str2 = "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF";
    let mut num2 = U256::from_str_radix(num_str2, 16).unwrap();
    println!("Originally, num2 = {}", num2);
    assert_eq!(num2.is_overflow(), false);
    assert_eq!(num2.is_underflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);

    let carry = num2.carrying_add_assign_uint(num_uint, false);
    println!("After num2 += {},\tnum2 = {}\tcarry = {}", num_uint, num2, carry);
    assert_eq!(num2.to_string(), "11024999611375677182");
    assert_eq!(carry, true);
    assert_eq!(num2.is_overflow(), true);
    assert_eq!(num2.is_underflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);

    let num_uint = 0x9900AABB_CCDDEEFF_u64;
    let num_str2 = "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF";
    let mut num2 = U256::from_str_radix(num_str2, 16).unwrap();
    println!("Originally, num2 = {}", num2);
    assert_eq!(num2.is_overflow(), false);
    assert_eq!(num2.is_underflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);

    let carry = num2.carrying_add_assign_uint(num_uint, true);
    println!("After num2 += {},\tnum2 = {}\tcarry = {}", num_uint, num2, carry);
    assert_eq!(num2.to_string(), "11024999611375677183");
    assert_eq!(carry, true);
    assert_eq!(num2.is_overflow(), true);
    assert_eq!(num2.is_underflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_add_uint()
{
    println!("biguint_wrapping_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let res = a_biguint.wrapping_add_uint(1_u8);
    println!("{} + 1 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let res = a_biguint.wrapping_add_uint(2_u8);
    println!("{} + 2 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let res = a_biguint.wrapping_add_uint(3_u8);
    println!("{} + 3 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_add_assign_uint()
{
    println!("biguint_wrapping_add_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = UU64::max().wrapping_sub_uint(1_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_add_assign_uint(1_u8);
    println!("After a_biguint.wrapping_add_assign_uint(1_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint, UU64::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let mut a_biguint = UU64::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_add_assign_uint(1_u8);
    println!("After a_biguint.wrapping_add_assign_uint(1_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_add_assign_uint(1_u8);
    println!("After a_biguint.wrapping_add_assign_uint(1_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_add_uint()
{
    println!("biguint_overflowing_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let (res, overflow) = a_biguint.overflowing_add_uint(1_u8);
    println!("{} + 1 = {}\noverflow = {}", a_biguint, res, overflow);
    assert_eq!(res, U512::max());
    assert_eq!(overflow, false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let (res, overflow) = a_biguint.overflowing_add_uint(2_u8);
    println!("{} + 2 = {}\noverflow = {}", a_biguint, res, overflow);
    assert_eq!(res.to_string(), "0");
    assert_eq!(overflow, true);
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let (res, overflow) = a_biguint.overflowing_add_uint(3_u8);
    println!("{} + 3 = {}\noverflow = {}", a_biguint, res, overflow);
    assert_eq!(res.to_string(), "1");
    assert_eq!(overflow, true);
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_add_assign_uint()
{
    println!("biguint_overflowing_add_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU64::max().wrapping_sub_uint(1_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let overflow = a_biguint.overflowing_add_assign_uint(1_u8);
    println!("After a_biguint.overflowing_add_assign_uint(1_u8), a_biguint = {}\noverflow = {}", a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint, UU64::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU64::max().wrapping_sub_uint(1_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut overflow = a_biguint.overflowing_add_assign_uint(2_u8);
    println!("After a_biguint.overflowing_add_assign_uint(2_u8), a_biguint = {}\noverflow = {}", a_biguint, overflow);
    assert_eq!(overflow, true);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    overflow = a_biguint.overflowing_add_assign_uint(2_u8);
    println!("After a_biguint.overflowing_add_assign_uint(2_u8), a_biguint = {}\noverflow = {}", a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_checked_add_uint()
{
    println!("biguint_checked_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let res = a_biguint.checked_add_uint(1_u8);
    match res
    {
        Some(num) => {
            println!("{} + 1 = {}", a_biguint, num);
            assert_eq!(num, U512::max());
            assert_eq!(num.is_overflow(), false);
            assert_eq!(num.is_underflow(), false);
            assert_eq!(num.is_divided_by_zero(), false);
            assert_eq!(num.is_infinity(), false);
            assert_eq!(num.is_undefined(), false);
        },
        None => {
            println!("{} + 1 = overflow", a_biguint);
        }
    }

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let res = a_biguint.checked_add_uint(2_u8);
    match res
    {
        Some(num) => {
            println!("{} + 2 = {}", a_biguint, num);
        },
        None => {
            println!("{} + 2 = overflow", a_biguint);
            assert_eq!(res, None);
        }
    }

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let res = a_biguint.checked_add_uint(3_u8);
    match res
    {
        Some(num) => {
            println!("{} + 3 = {}", a_biguint, num);
        },
        None => {
            println!("{} + 3 = overflow", a_biguint);
            assert_eq!(res, None);
        }
    }
    println!("---------------------------");
}

fn biguint_unchecked_add_uint()
{
    println!("biguint_unchecked_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = UU64::max().wrapping_sub_uint(1_u8);
    let res = a_biguint.unchecked_add_uint(1_u8);
    println!("{} + 1 = {}", a_biguint, res);
    assert_eq!(res, UU64::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_unchecked_add_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_unchecked_add_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _a_biguint = UU64::max().wrapping_sub_uint(1_u8);
    let _res = _a_biguint.unchecked_add_uint(2_u8);
}

fn biguint_saturating_add_uint()
{
    println!("biguint_saturating_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U512::max().wrapping_sub_uint(2_u8);
    let res = a_biguint.saturating_add_uint(1_u8);
    println!("{} + 1 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max().wrapping_sub_uint(2_u8);
    let res = a_biguint.saturating_add_uint(2_u8);
    println!("{} + 2 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max().wrapping_sub_uint(2_u8);
    let res = a_biguint.saturating_add_uint(3_u8);
    println!("{} + 3 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_saturating_add_assign_uint()
{
    println!("biguint_saturating_add_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = UU64::max().wrapping_sub_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_add_assign_uint(1_u8);
    println!("After a_biguint.saturating_add_assign_uint(1_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let mut a_biguint = UU64::max().wrapping_sub_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_add_assign_uint(2_u8);
    println!("After a_biguint.saturating_add_assign_uint(2_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint, UU64::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU64::max().wrapping_sub_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_add_assign_uint(3_u8);
    println!("After a_biguint.saturating_add_assign_uint(3_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint, UU64::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_modular_add_uint()
{
    println!("biguint_modular_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 1_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "76801874298166903427690031858186486050853753882811946569946433649007");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 2_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 3
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 3_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == Self::max()
    let a_biguint = U256::max().wrapping_sub_uint(2_u8);
    let m = U256::max();
    let rhs = 3_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}", a_biguint, rhs, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_add_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_add_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::zero();
    let _rhs = 3_u8;
    let _res = _a_biguint.modular_add_uint(_rhs, &_m);

    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::one();
    let _rhs = 3_u8;
    let _res = _a_biguint.modular_add_uint(_rhs, &_m);
}

fn biguint_modular_add_assign_uint()
{
    println!("biguint_modular_add_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 1_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490061");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 2_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    println!("Originally,a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 3_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.modular_add_assign_uint(1_u8, &m);
    println!("After a.modular_add_assign_uint(1_u8, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == Self::max()
    let mut a_biguint = U256::max().wrapping_sub_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::max();
    let three = U256::from_uint(3_u8);
    a_biguint.modular_add_assign(&three, &m);
    println!("After a_biguint.modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "150");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.modular_add_assign_uint(rhs, &m);
    println!("After a.modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_add_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_add_assign_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::zero();
    let _rhs = 1_u8;
   
    _a_biguint.modular_add_assign_uint(_rhs, &_m);

    let mut _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::one();
    let _rhs = 1_u8;
    _a_biguint.modular_add_assign_uint(_rhs, &_m);
}

fn biguint_panic_free_modular_add_uint()
{
    println!("biguint_panic_free_modular_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 1_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "76801874298166903427690031858186486050853753882811946569946433649007");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 2_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 3
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::zero();
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // modulo == 1
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::one();
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
    println!("{} + {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // collectively
    for a_biguint in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [0_u8, 3_u8, 50_u8]
        {
            for m in [U256::zero(), U256::one()]
            {
                let res = a_biguint.panic_free_modular_add_uint(rhs, &m);
                println!("{} + {} = {} (mod {})", a_biguint, rhs, res, m);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_add_assign_uint()
{
    println!("biguint_panic_free_modular_add_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 1_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490061");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 2_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8);
    println!("Originally, a = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_modular_add_assign_uint(1_u8, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint(1_u8, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "150");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == 0
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    let m = U256::zero();
    println!("Originally, a = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // modulo == 1
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    let m = U256::one();
    println!("Originally, a = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490060");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // collectively
    for a in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [0_u8, 3_u8, 50_u8]
        {
            for m in [U256::zero(), U256::one()]
            {
                let mut a_biguint = a.clone();
                println!("Originally, a = {}", a_biguint);
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), false);
            
                a_biguint.panic_free_modular_add_assign_uint(rhs, &m);
                println!("After a_biguint.panic_free_modular_add_assign_uint({}, &{}), a_biguint = {}", rhs, a_biguint, m);
                assert_eq!(a_biguint.to_string(), "0");
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}


fn biguint_sub_uint()
{
    biguint_borrowing_sub_uint();
    biguint_borrowing_sub_assign_uint();
    biguint_wrapping_sub_uint();
    biguint_wrapping_sub_assign_uint();
    biguint_overflowing_sub_uint();
    biguint_overflowing_sub_assign_uint();
    biguint_checked_sub_uint();
    biguint_unchecked_sub_uint();
    biguint_saturating_sub_uint();
    biguint_saturating_sub_assign_uint();
    biguint_modular_sub_uint();
    biguint_modular_sub_assign_uint();
    biguint_panic_free_modular_sub_uint();
    biguint_panic_free_modular_sub_assign_uint();
    biguint_abs_diff_uint();
}

fn biguint_borrowing_sub_uint()
{
    println!("biguint_borrowing_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let num1 = UU32::from_str_radix(num_str1, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFf_u128;

    let (dif, borrow) = num1.borrowing_sub_uint(num_uint, false);
    println!("{} - {} = {}\nborrow = {}", num1, num_uint, dif, borrow);
    assert_eq!(dif.to_string(), "115761816335569101403435733562708448393619331758951915327747778712745103528175");
    assert_eq!(borrow, false);
    assert_eq!(dif.is_underflow(), false);
    assert_eq!(dif.is_overflow(), false);
    assert_eq!(dif.is_divided_by_zero(), false);
    assert_eq!(dif.is_infinity(), false);
    assert_eq!(dif.is_undefined(), false);

    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let num1 = UU32::from_str_radix(num_str1, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFf_u128;

    let (dif, borrow) = num1.borrowing_sub_uint(num_uint, true);
    println!("{} - {} = {}\nborrow = {}", num1, num_uint, dif, borrow);
    assert_eq!(dif.to_string(), "115761816335569101403435733562708448393619331758951915327747778712745103528174");
    assert_eq!(borrow, false);
    assert_eq!(dif.is_underflow(), false);
    assert_eq!(dif.is_overflow(), false);
    assert_eq!(dif.is_divided_by_zero(), false);
    assert_eq!(dif.is_infinity(), false);
    assert_eq!(dif.is_undefined(), false);

    let num_str2 = "11223344_55667788_9900AABB_CCDDEEEe";
    let num2 = UU32::from_str_radix(num_str2, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFf_u128;

    let (dif, borrow) = num2.borrowing_sub_uint(num_uint, false);
    println!("{} - {} = {}\nborrow = {}", num2, num_uint, dif, borrow);
    assert_eq!(dif.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639919");
    assert_eq!(borrow, true);
    assert_eq!(dif.is_underflow(), true);
    assert_eq!(dif.is_overflow(), false);
    assert_eq!(dif.is_divided_by_zero(), false);
    assert_eq!(dif.is_infinity(), false);
    assert_eq!(dif.is_undefined(), false);

    let num_str2 = "11223344_55667788_9900AABB_CCDDEEEe";
    let num2 = UU32::from_str_radix(num_str2, 16).unwrap();
    let num_uint = 0x11223344_55667788_9900AABB_CCDDEEFf_u128;

    let (dif, borrow) = num2.borrowing_sub_uint(num_uint, true);
    println!("{} - {} = {}\nborrow = {}", num2, num_uint, dif, borrow);
    assert_eq!(dif.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639918");
    assert_eq!(borrow, true);
    assert_eq!(dif.is_underflow(), true);
    assert_eq!(dif.is_overflow(), false);
    assert_eq!(dif.is_divided_by_zero(), false);
    assert_eq!(dif.is_infinity(), false);
    assert_eq!(dif.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_borrowing_sub_assign_uint()
{
    println!("biguint_borrowing_sub_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let mut num1 = U256::from_str_radix(num_str1, 16).unwrap();
    let num_uint = 0x9900AABB_CCDDEEFf_u64;
    println!("Originally, num1 = {}", num1);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let borrow = num1.borrowing_sub_assign_uint(num_uint, false);
    println!("After num1 -= {},\tnum1 = {}\tborrow = {}", num_uint, num1, borrow);
    assert_eq!(num1.to_string(), "115761816335569101403435733562708448393642106212790284019670463725845572948207");
    assert_eq!(borrow, false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let num_str1 = "FFEEDDBB_AA998877_66554433_221100FF_EEDDBBAA_99887766_55443322_1100FFEE";
    let mut num1 = U256::from_str_radix(num_str1, 16).unwrap();
    let num_uint = 0x9900AABB_CCDDEEFf_u64;
    println!("Originally, num1 = {}", num1);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let borrow = num1.borrowing_sub_assign_uint(num_uint, true);
    println!("After num1 -= {},\tnum1 = {}\tcarry = {}", num_uint, num1, borrow);
    assert_eq!(num1.to_string(), "115761816335569101403435733562708448393642106212790284019670463725845572948206");
    assert_eq!(borrow, false);
    assert_eq!(num1.is_underflow(), false);
    assert_eq!(num1.is_overflow(), false);
    assert_eq!(num1.is_divided_by_zero(), false);
    assert_eq!(num1.is_infinity(), false);
    assert_eq!(num1.is_undefined(), false);

    let num_str2 = "9900AABB_CCDDEEFe";
    let mut num2 = U256::from_str_radix(num_str2, 16).unwrap();
    let num_uint = 0x9900AABB_CCDDEEFf_u64;
    println!("Originally, num2 = {}", num2);
    assert_eq!(num2.is_overflow(), false);
    assert_eq!(num2.is_underflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);

    let borrow = num2.borrowing_sub_assign_uint(num_uint, false);
    println!("After num2 -= {},\tnum2 = {}\tcarry = {}", num_uint, num2, borrow);
    assert_eq!(num2.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639935");
    assert_eq!(borrow, true);
    assert_eq!(num2.is_underflow(), true);
    assert_eq!(num2.is_overflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);

    let num_str2 = "9900AABB_CCDDEEFe";
    let mut num2 = U256::from_str_radix(num_str2, 16).unwrap();
    let num_uint = 0x9900AABB_CCDDEEFf_u64;
    println!("Originally, num2 = {}", num2);
    assert_eq!(num2.is_overflow(), false);
    assert_eq!(num2.is_underflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);

    let borrow = num2.borrowing_sub_assign_uint(num_uint, true);
    println!("After num2 -= {},\tnum2 = {}\tcarry = {}", num_uint, num2, borrow);
    assert_eq!(num2.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639934");
    assert_eq!(borrow, true);
    assert_eq!(num2.is_underflow(), true);
    assert_eq!(num2.is_overflow(), false);
    assert_eq!(num2.is_divided_by_zero(), false);
    assert_eq!(num2.is_infinity(), false);
    assert_eq!(num2.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_sub_uint()
{
    println!("biguint_wrapping_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U512::one();
    let res = a_biguint.wrapping_sub_uint(1_u8);
    println!("{} - 1 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let res = a_biguint.wrapping_sub_uint(2_u8);
    println!("{} - 2 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let res = a_biguint.wrapping_sub_uint(3_u8);
    println!("{} - 3 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_sub_assign_uint()
{
    println!("biguint_wrapping_sub_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = UU64::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    a_biguint.wrapping_sub_assign_uint(1_u8);
    println!("After a_biguint.wrapping_sub_assign_uint(1_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let mut a_biguint = UU64::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_sub_assign_uint(2_u8);
    println!("After a_biguint.wrapping_sub_assign_uint(2_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU64::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_sub_assign_uint(3_u8);
    println!("After a_biguint.wrapping_sub_assign_uint(3_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_sub_assign_uint(1_u8);
    println!("After a_biguint.wrapping_sub_assign_uint(1_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_sub_uint()
{
    println!("biguint_overflowing_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U512::one();
    let (res, underflow) = a_biguint.overflowing_sub_uint(1_u8);
    println!("{} - 1 = {}\nunderflow = {}", a_biguint, res, underflow);
    assert_eq!(res.to_string(), "0");
    assert_eq!(underflow, false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let (res, underflow) = a_biguint.overflowing_sub_uint(2_u8);
    println!("{} - 2 = {}\nunderflow = {}", a_biguint, res, underflow);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(underflow, true);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let (res, underflow) = a_biguint.overflowing_sub_uint(3_u8);
    println!("{} - 3 = {}\nunderflow = {}", a_biguint, res, underflow);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(underflow, true);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_sub_assign_uint()
{
    println!("biguint_overflowing_sub_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU64::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let underflow = a_biguint.overflowing_sub_assign_uint(1_u8);
    println!("After a_biguint.overflowing_sub_assign_uint(1_u8), a_biguint = {}\nunderflow = {}", a_biguint, underflow);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(underflow, false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU64::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let underflow = a_biguint.overflowing_sub_assign_uint(2_u8);
    println!("After a_biguint.overflowing_sub_assign_uint(2_u8), a_biguint = {}\nunderflow = {}", a_biguint, underflow);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(underflow, true);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU64::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let underflow = a_biguint.overflowing_sub_assign_uint(3_u8);
    println!("After a_biguint.overflowing_sub_assign_uint(3_u8), a_biguint = {}\nunderflow = {}", a_biguint, underflow);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(underflow, true);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let underflow = a_biguint.overflowing_sub_assign_uint(1_u8);
    println!("After a_biguint.overflowing_sub_assign_uint(1_u8), a_biguint = {}\nunderflow = {}", a_biguint, underflow);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(underflow, false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_checked_sub_uint()
{
    println!("biguint_checked_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U512::one();
    let res = a_biguint.checked_sub_uint(1_u8);
    match res
    {
        Some(num) => {
            println!("{} - 1 = {}", a_biguint, num);
            assert_eq!(num.to_string(), "0");
            assert_eq!(num.is_underflow(), false);
            assert_eq!(num.is_overflow(), false);
            assert_eq!(num.is_divided_by_zero(), false);
            assert_eq!(num.is_infinity(), false);
            assert_eq!(num.is_undefined(), false);
        },
        None => {
            println!("{} - 1 = overflow", a_biguint);
        }
    }

    let a_biguint = U512::one();
    let res = a_biguint.checked_sub_uint(2_u8);
    match res
    {
        Some(num) => {
            println!("{} - 2 = {}", a_biguint, num);
        },
        None => {
            println!("{} - 2 = overflow", a_biguint);
            assert_eq!(res, None);
        }
    }

    let a_biguint = U512::one();
    let res = a_biguint.checked_sub_uint(3_u8);
    match res
    {
        Some(num) => {
            println!("{} - 3 = {}", a_biguint, num);
        },
        None => {
            println!("{} - 3 = overflow", a_biguint);
            assert_eq!(res, None);
        }
    }
    println!("---------------------------");
}

fn biguint_unchecked_sub_uint()
{
    println!("biguint_unchecked_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = UU64::one();
    let res = a_biguint.unchecked_sub_uint(1_u8);
    println!("{} - 1 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "0");

    #[cfg(test)] // It will panic.
    biguint_should_panic_unchecked_sub_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_unchecked_sub_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _a_biguint = UU64::one();
    let _res = _a_biguint.unchecked_sub_uint(2_u8);
}

fn biguint_saturating_sub_uint()
{
    println!("biguint_saturating_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    
    let a_biguint = U512::from_uint(2_u8);
    let res = a_biguint.saturating_sub_uint(1_u8);
    println!("{} - 1 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::from_uint(2_u8);
    let res = a_biguint.saturating_sub_uint(2_u8);
    println!("{} - 2 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::from_uint(2_u8);
    let res = a_biguint.saturating_sub_uint(3_u8);
    println!("{} - 3 = {}", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_saturating_sub_assign_uint()
{
    println!("biguint_saturating_sub_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = UU64::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_sub_assign_uint(1_u8);
    println!("After a_biguint.saturating_sub_assign_uint(1_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let mut a_biguint = UU64::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_sub_assign_uint(2_u8);
    println!("After a_biguint.saturating_sub_assign_uint(2_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let mut a_biguint = UU64::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_sub_assign_uint(3_u8);
    println!("After a_biguint.saturating_sub_assign_uint(3_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_modular_sub_uint()
{
    println!("biguint_modular_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 1_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 2_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 3
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 3_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == Self::max()
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::max();
    let rhs = 3_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res, U256::max().wrapping_sub_uint(1_u8));
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_sub_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_sub_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let _a_biguint = U256::from_uint(2_u8);
    let _m = U256::zero();
    let _rhs = 3_u8;
    let _res = _a_biguint.modular_sub_uint(_rhs, &_m);

    let _a_biguint = U256::from_uint(2_u8);
    let _m = U256::one();
    let _rhs = 3_u8;
    let _res = _a_biguint.modular_sub_uint(_rhs, &_m);
}

fn biguint_modular_sub_assign_uint()
{
    println!("biguint_modular_sub_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 1_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
 
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 2_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
 
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 3_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084090");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == Self::max()
    let mut a_biguint = U256::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::max();
    let rhs = 3_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint, U256::max().wrapping_sub_uint(1_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    a_biguint.modular_sub_assign_uint(rhs, &m);
    println!("After a.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_sub_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_sub_assign_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut _a_biguint = U256::from_uint(2_u8);
    let _m = U256::zero();
    let _rhs = 1_u8;
    _a_biguint.modular_sub_assign_uint(_rhs, &_m);

    let mut _a_biguint = U256::from_uint(2_u8);
    let _m = U256::one();
    let _rhs = 1_u8;
    _a_biguint.modular_sub_assign_uint(_rhs, &_m);
}

fn biguint_panic_free_modular_sub_uint()
{
    println!("biguint_panic_free_modular_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 1_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 2_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 3
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 3_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = 0_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let rhs = 250_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == 0
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::zero();
    let rhs = 1_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // modulo == 1
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::one();
    let rhs = 1_u8;
    let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // collectively
    for a_biguint in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [0_u8, 3_u8, 50_u8]
        {
            for m in [U256::zero(), U256::one()]
            {
                let res = a_biguint.panic_free_modular_sub_uint(rhs, &m);
                println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_sub_assign_uint()
{
    println!("biguint_panic_free_modular_sub_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let mut a_biguint = UU32::from_uint(2_u8);
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 1_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = UU32::from_uint(2_u8);
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 2_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
 
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = UU32::from_uint(2_u8);
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = 3_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
 
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "150");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == 0
    let mut a_biguint = U256::from_uint(2_u8);
    let m = U256::zero();
    let rhs = 3_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
 
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // modulo == 1
    let mut a_biguint = U256::from_uint(2_u8);
    let m = U256::one();
    let rhs = 3_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
 
    a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // collectively
    for a in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [0_u8, 3_u8, 50_u8]
        {
            for m in [U256::zero(), U256::one()]
            {
                let mut a_biguint = a.clone();
                println!("Originally, a = {}", a_biguint);
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), false);
            
                a_biguint.panic_free_modular_sub_assign_uint(rhs, &m);
                println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &{}), a_biguint = {}", rhs, a_biguint, m);
                assert_eq!(a_biguint.to_string(), "0");
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_abs_diff_uint()
{
    println!("biguint_abs_diff_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let num_str1 = "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF";
    let num1 = U256::from_str_radix(num_str1, 16).unwrap();
    let num_uint = 0x9900AABB_CCDDEEFF_9900AABB_CCDDEEFF_u128;
    let res = num1.abs_diff_uint(num_uint);
    println!("| {} - {} | = {}", num1, num_uint, res);
    assert_eq!(res.to_string(), "115792089237316195423570985008687907853066609319396769656704041438214461985024");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let num_str2 = "12345678_9ABCDEF0_12345678_9ABCDEF0";
    let num2 = U256::from_str_radix(num_str2, 16).unwrap();
    let num_uint = 0x9900AABB_CCDDEEFF_9900AABB_CCDDEEFF_u128;
    let res = num2.abs_diff_uint(num_uint);
    println!("| {} - {} | = {}", num2, num_uint, res);
    assert_eq!(res.to_string(), "179177489040527647888749252028162707471");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let num_str3 = "9900AABB_CCDDEEFF_9900AABB_CCDDEEFF";
    let num3 = U256::from_str_radix(num_str3, 16).unwrap();
    let num_uint = 0x9900AABB_CCDDEEFF_9900AABB_CCDDEEFF_u128;
    let res = num3.abs_diff_uint(num_uint);
    println!("| {} - {} | = {}", num3, num_uint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}


fn biguint_mul_uint()
{
    biguint_carrying_mul_uint();
    biguint_carrying_mul_assign_uint();
    biguint_widening_mul_uint();
    biguint_widening_mul_assign_uint();
    biguint_wrapping_mul_uint();
    biguint_wrapping_mul_assign_uint();
    biguint_overflowing_mul_uint();
    biguint_overflowing_mul_assign_uint();
    biguint_checked_mul_uint();
    biguint_unchecked_mul_uint();
    biguint_saturating_mul_uint();
    biguint_saturating_mul_assign_uint();
    biguint_modular_mul_uint();
    biguint_modular_mul_assign_uint();
    biguint_panic_free_modular_mul_uint();
    biguint_panic_free_modular_mul_assign_uint();
}

fn biguint_carrying_mul_uint()
{
    println!("biguint_carrying_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case
    let a_low_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_high_biguint = UU32::from_string("75388281194656994643364900608409476801874298166903427690031858186486050853").unwrap();
    let b_uint = 225_u8;
    let (res_low, res_high) = a_low_biguint.carrying_mul_uint(b_uint, UU32::zero());
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);

    let (res_high, res_higher) = a_high_biguint.carrying_mul_uint(b_uint, res_high);
    println!("{}:{} X {} = {}:{}:{}", a_high_biguint, a_low_biguint, b_uint, res_higher, res_high, res_low);
    assert_eq!(res_higher.to_string(), "0");
    assert_eq!(res_higher.is_overflow(), false);
    assert_eq!(res_higher.is_underflow(), false);
    assert_eq!(res_higher.is_divided_by_zero(), false);
    assert_eq!(res_higher.is_infinity(), false);
    assert_eq!(res_higher.is_undefined(), false);
    assert_eq!(res_high.to_string(), "16962363268797823794757102636892132280421717087553271230257168091959361441925");
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);
    assert_eq!(res_low.to_string(), "17280421717087553271230257168091959361442094623632687978237947571026368921150");
    assert_eq!(res_low.is_overflow(), false);
    assert_eq!(res_low.is_underflow(), false);
    assert_eq!(res_low.is_divided_by_zero(), false);
    assert_eq!(res_low.is_infinity(), false);
    assert_eq!(res_low.is_undefined(), false);

    // Maximum case
    let a_low_biguint = U256::max();
    let a_high_biguint = UU32::max();
    let b_uint = u64::MAX;
    let (res_low, res_high) = a_low_biguint.carrying_mul_uint(b_uint, UU32::zero());
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);

    let (res_high, res_higher) = a_high_biguint.carrying_mul_uint(b_uint, res_high);
    println!("{}:{} X {:X} = {}:{}:{}", a_high_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), a_low_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), b_uint, res_higher.to_string_with_radix_and_stride(16, 8).unwrap(), res_high.to_string_with_radix_and_stride(16, 8).unwrap(), res_low.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(res_higher.to_string_with_radix_and_stride(16, 8).unwrap(), "3F");
    assert_eq!(res_higher.is_overflow(), false);
    assert_eq!(res_higher.is_underflow(), false);
    assert_eq!(res_higher.is_divided_by_zero(), false);
    assert_eq!(res_higher.is_infinity(), false);
    assert_eq!(res_higher.is_undefined(), false);
    assert_eq!(res_high.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_00000000_00000040");
    assert_eq!(res_high.is_overflow(), true);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);
    assert_eq!(res_low.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_00000000_00000001");
    assert_eq!(res_low.is_overflow(), true);
    assert_eq!(res_low.is_underflow(), false);
    assert_eq!(res_low.is_divided_by_zero(), false);
    assert_eq!(res_low.is_infinity(), false);
    assert_eq!(res_low.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_carrying_mul_assign_uint()
{
    println!("biguint_carrying_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case
    let mut a_low_biguint = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mut a_high_biguint = U256::from_string("75388281194656994643364900608409476801874298166903427690031858186486050853").unwrap();
    let b_uint = 225_u8;

    println!("Originally, a_low_biguint = {}", a_low_biguint);
    assert_eq!(a_low_biguint.is_overflow(), false);
    assert_eq!(a_low_biguint.is_underflow(), false);
    assert_eq!(a_low_biguint.is_divided_by_zero(), false);
    assert_eq!(a_low_biguint.is_infinity(), false);
    assert_eq!(a_low_biguint.is_undefined(), false);
    println!("Originally, a_high_biguint = {}", a_high_biguint);
    assert_eq!(a_high_biguint.is_overflow(), false);
    assert_eq!(a_high_biguint.is_underflow(), false);
    assert_eq!(a_high_biguint.is_divided_by_zero(), false);
    assert_eq!(a_high_biguint.is_infinity(), false);
    assert_eq!(a_high_biguint.is_undefined(), false);

    let res_high = a_low_biguint.carrying_mul_assign_uint(b_uint, UU32::zero());
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);
    println!("After a_low_biguint.carrying_mul_assign_uint(225_u8, 0),\na_low_biguint = {}", a_low_biguint);
    assert_eq!(a_low_biguint.to_string(), "17280421717087553271230257168091959361442094623632687978237947571026368921150");
    assert_eq!(a_low_biguint.is_overflow(), false);
    assert_eq!(a_low_biguint.is_underflow(), false);
    assert_eq!(a_low_biguint.is_divided_by_zero(), false);
    assert_eq!(a_low_biguint.is_infinity(), false);
    assert_eq!(a_low_biguint.is_undefined(), false);
    let res_higher = a_high_biguint.carrying_mul_assign_uint(b_uint, res_high);
    println!("After a_high_biguint.carrying_mul_assign_uint(225_u8, res_higher),\na_high_biguint = {}\nres_higher = {}", a_high_biguint, res_higher);
    assert_eq!(a_high_biguint.to_string(), "16962363268797823794757102636892132280421717087553271230257168091959361441925");
    assert_eq!(res_higher.to_string(), "0");
    assert_eq!(res_higher.is_overflow(), false);
    assert_eq!(res_higher.is_underflow(), false);
    assert_eq!(res_higher.is_divided_by_zero(), false);
    assert_eq!(res_higher.is_infinity(), false);
    assert_eq!(res_higher.is_undefined(), false);
    assert_eq!(a_high_biguint.is_overflow(), false);
    assert_eq!(a_high_biguint.is_underflow(), false);
    assert_eq!(a_high_biguint.is_divided_by_zero(), false);
    assert_eq!(a_high_biguint.is_infinity(), false);
    assert_eq!(a_high_biguint.is_undefined(), false);

    // Maximum case
    let mut a_low_biguint = U256::max();
    let mut a_high_biguint = UU32::max();
    let b_uint = u64::MAX;

    println!("Originally, a_low_biguint = {}", a_low_biguint);
    assert_eq!(a_low_biguint.is_overflow(), false);
    assert_eq!(a_low_biguint.is_underflow(), false);
    assert_eq!(a_low_biguint.is_divided_by_zero(), false);
    assert_eq!(a_low_biguint.is_infinity(), false);
    assert_eq!(a_low_biguint.is_undefined(), false);
    println!("Originally, a_high_biguint = {}", a_high_biguint);
    assert_eq!(a_high_biguint.is_overflow(), false);
    assert_eq!(a_high_biguint.is_underflow(), false);
    assert_eq!(a_high_biguint.is_divided_by_zero(), false);
    assert_eq!(a_high_biguint.is_infinity(), false);
    assert_eq!(a_high_biguint.is_undefined(), false);

    let res_high = a_low_biguint.carrying_mul_assign_uint(b_uint, UU32::zero());
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);
    println!("After a_low_biguint.carrying_mul_assign_uint(u64:MAX, 0),\na_low_biguint = {}", a_low_biguint.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(a_low_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_00000000_00000001");
    assert_eq!(a_low_biguint.is_overflow(), true);
    assert_eq!(a_low_biguint.is_underflow(), false);
    assert_eq!(a_low_biguint.is_divided_by_zero(), false);
    assert_eq!(a_low_biguint.is_infinity(), false);
    assert_eq!(a_low_biguint.is_undefined(), false);
    let res_higher = a_high_biguint.carrying_mul_assign_uint(b_uint, res_high);
    println!("After a_high_biguint.carrying_mul_assign_uint(u64:MAX, res_higher),\na_high_biguint = {}\nres_higher = {}", a_high_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), res_higher.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(a_high_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_00000000_00000040");
    assert_eq!(a_high_biguint.is_overflow(), true);
    assert_eq!(a_high_biguint.is_underflow(), false);
    assert_eq!(a_high_biguint.is_divided_by_zero(), false);
    assert_eq!(a_high_biguint.is_infinity(), false);
    assert_eq!(res_higher.to_string_with_radix_and_stride(16, 8).unwrap(), "3F");
    assert_eq!(res_higher.is_overflow(), false);
    assert_eq!(res_higher.is_underflow(), false);
    assert_eq!(res_higher.is_divided_by_zero(), false);
    assert_eq!(res_higher.is_infinity(), false);
    println!("---------------------------");
}

fn biguint_widening_mul_uint()
{
    println!("biguint_widening_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case
    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_uint = 248_u128;
    let (res_low, res_high) = a_biguint.widening_mul_uint(b_uint);
    println!("{} X {} = {}:{}", a_biguint, b_uint, res_high, res_low);
    assert_eq!(res_high.to_string(), "1");
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);
    assert_eq!(res_low.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(res_low.is_overflow(), true);
    assert_eq!(res_low.is_underflow(), false);
    assert_eq!(res_low.is_divided_by_zero(), false);
    assert_eq!(res_low.is_infinity(), false);
    assert_eq!(res_low.is_undefined(), false);

    // Maximum case
    let a_biguint = U256::max();
    let b_uint = u128::MAX;
    let (res_low, res_high) = a_biguint.widening_mul_uint(b_uint);
    println!("{} X {:X} = {}:{}", a_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), b_uint, res_high.to_string_with_radix_and_stride(16, 8).unwrap(), res_low.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(res_high.to_string_with_radix_and_stride(16, 8).unwrap(), "7F");
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);
    assert_eq!(res_low.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_00000000_00000000_00000000_00000001");
    assert_eq!(res_low.is_overflow(), true);
    assert_eq!(res_low.is_underflow(), false);
    assert_eq!(res_low.is_divided_by_zero(), false);
    assert_eq!(res_low.is_infinity(), false);
    assert_eq!(res_low.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_widening_mul_assign_uint()
{
    println!("biguint_widening_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case
    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_uint = 248_u64;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "876801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let res_high = a_biguint.widening_mul_assign_uint(b_uint);
    println!("After a_biguint.widening_mul_assign_uint(248_u8),\na_biguint = {}\nres_high = {}", a_biguint, res_high);
    assert_eq!(a_biguint.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(res_high.to_string(), "1");
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);

    // Maximum case
    let mut a_biguint = UU32::max();
    let b_uint = u64::MAX;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let res_high = a_biguint.widening_mul_assign_uint(b_uint);
    println!("After a_biguint.widening_mul_assign_uint(u64::MAX),\na_biguint = {}\nres_high = {}", a_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), res_high.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(res_high.to_string_with_radix_and_stride(16, 8).unwrap(), "3F");
    assert_eq!(res_high.is_overflow(), false);
    assert_eq!(res_high.is_underflow(), false);
    assert_eq!(res_high.is_divided_by_zero(), false);
    assert_eq!(res_high.is_infinity(), false);
    assert_eq!(res_high.is_undefined(), false);
    assert_eq!(a_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_00000000_00000001");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_mul_uint()
{
    println!("biguint_wrapping_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_uint = 248_u16;
    let res = a_biguint.wrapping_mul_uint(b_uint);
    println!("{} X {} = {}", a_biguint, b_uint, res);
    assert_eq!(res.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let res = b_biguint.wrapping_mul_uint(b_uint);
    println!("{} X {} = {}", b_biguint, b_uint, res);
    assert_eq!(res.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_mul_assign_uint()
{
    println!("biguint_wrapping_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = UU32::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_uint = 248_u16;

    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "12380187429816690342769003185818648605085375388281194656994643364900608");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_mul_assign_uint(b_uint);
    println!("After a_biguint.wrapping_mul_assign_uint(248_u16), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "876801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_mul_assign_uint(b_uint);
    println!("After a_biguint.wrapping_mul_assign_uint(248_u16), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_mul_uint()
{
    println!("biguint_overflowing_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_string("1874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_uint = 248_u8;
    let (res, overflow) = a_biguint.overflowing_mul_uint(b_uint);
    println!("{} X {} = {}, {}", a_biguint, b_uint, res, overflow);
    assert_eq!(res.to_string(), "464825945392050067127900830248540611730962937362749346715544953508855312");
    assert_eq!(overflow, false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let (res, overflow) = a_biguint.overflowing_mul_uint(b_uint);
    println!("{} X {} = {}, {}", a_biguint, b_uint, res, overflow);
    assert_eq!(res.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(overflow, true);
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_mul_assign_uint()
{
    println!("biguint_overflowing_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU32::from_string("1874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_uint = 248_u128;

    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let overflow = a_biguint.overflowing_mul_assign_uint(b_uint);
    println!("After a_biguint.overflowing_mul_assign_uint(248_u16), a_biguint = {}, {}", a_biguint, overflow);
    assert_eq!(a_biguint.to_string(), "464825945392050067127900830248540611730962937362749346715544953508855312");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "876801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let overflow = a_biguint.overflowing_mul_assign_uint(b_uint);
    println!("After a_biguint.overflowing_mul_assign_uint(248_u16), a_biguint = {}, {}", a_biguint, overflow);
    assert_eq!(a_biguint.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(overflow, true);
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_checked_mul_uint()
{
    println!("biguint_checked_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mut b_uint = 248_u16;
    let res = a_biguint.checked_mul_uint(b_uint);
    match &res
    {
        Some(r) => { println!("{} X {} = {}", a_biguint, b_uint, r); },
        None => {
            println!("Overflow happend!");
            assert_eq!(res, None);
        },
    }

    b_uint = 5_u16;
    let res = a_biguint.checked_mul_uint(b_uint);
    match &res
    {
        Some(r) => {
            println!("{} X {} = {}", a_biguint, b_uint, r);
            assert_eq!(r.to_string(), "4384009371490834517138450159290932430254268769414059732849732168245030420470");
            assert_eq!(r.is_overflow(), false);
            assert_eq!(r.is_underflow(), false);
            assert_eq!(r.is_divided_by_zero(), false);
            assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
        },
        None => { println!("Overflow happend!"); },
    }
    println!("---------------------------");
}

fn biguint_unchecked_mul_uint()
{
    println!("biguint_unchecked_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let res = a_biguint.unchecked_mul_uint(5_u8);
    println!("{} X {} = {}", a_biguint, 5_u8, res);
    assert_eq!(res.to_string(), "4384009371490834517138450159290932430254268769414059732849732168245030420470");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_unchecked_mul_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_unchecked_mul_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let _res = _a_biguint.unchecked_mul_uint(248_u8);
}

fn biguint_saturating_mul_uint()
{
    println!("biguint_saturating_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let res = a_biguint.saturating_mul_uint(5_u8);
    println!("{} X {} = {}", a_biguint, 5_u8, res);
    assert_eq!(res.to_string(), "4384009371490834517138450159290932430254268769414059732849732168245030420470");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let res = a_biguint.saturating_mul_uint(248_u8);
    println!("{} X {} = {}", a_biguint, 248_u8, res);
    assert_eq!(res.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639935");
    assert_eq!(res, UU32::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_saturating_mul_assign_uint()
{
    println!("biguint_saturating_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_mul_assign_uint(5_u8);
    println!("After a_biguint.saturating_mul_assign_uint(5_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "4384009371490834517138450159290932430254268769414059732849732168245030420470");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_mul_assign_uint(248_u8);
    println!("After a_biguint.saturating_mul_assign_uint(248_u8), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint, UU32::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_modular_mul_uint()
{
    println!("biguint_modular_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let mul_uint = 5_u8;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let mul_uint = 248_u8;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "55975706890540585964020877768978822316880213476032380583548819983093801176");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_uint = 5_u8;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 = multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_uint = 5_u8;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_uint = 0_u8;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let mul_uint = 4321000_u32;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_uint = 0_u8;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_uint = 4321000_u32;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_uint = 0_u8;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_uint = 4321000_u32;
    let res = a_biguint.modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_mul_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_mul_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // modulo == 0
    let _m = UU32::zero();
    let _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let _mul_uint = 248_u8;
    let _res = _a_biguint.modular_mul_uint(_mul_uint, &_m);

    // modulo == 1
    let _m = UU32::one();
    let _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let _mul_uint = 248_u8;
    let _res = _a_biguint.modular_mul_uint(_mul_uint, &_m);
}

fn biguint_modular_mul_assign_uint()
{
    println!("biguint_modular_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mul_uint = 5_u16;
    a_biguint.modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mul_uint = 248_u16;
    a_biguint.modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "55975706890540585964020877768978822316880213476032380583548819983093801176");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mul_uint = 248_u16;
    a_biguint.modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "55975706890540585964020877768978822316880213476032380583548819983093801176");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mul_uint = 2_u16;
    a_biguint.modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "35149539482914268500351723679771158582906673069252814597151206317181518258");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.modular_mul_assign_uint(rhs, &m);
    println!("After a.modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.modular_mul_assign_uint(rhs, &m);
    println!("After a.modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.modular_mul_assign_uint(rhs, &m);
    println!("After a.modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.modular_mul_assign_uint(rhs, &m);
    println!("After a.modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.modular_mul_assign_uint(rhs, &m);
    println!("After a.modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.modular_mul_assign_uint(rhs, &m);
    println!("After a.modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "150");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.modular_mul_assign_uint(rhs, &m);
    println!("After a.modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_mul_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_mul_assign_uint()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let _m = UU32::zero();
    let _mul_uint = 248_u8;
    _a_biguint.modular_mul_assign_uint(_mul_uint, &_m);

    let mut _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let _m = UU32::one();
    let _mul_uint = 248_u8;
    _a_biguint.modular_mul_assign_uint(_mul_uint, &_m);
}

fn biguint_panic_free_modular_mul_uint()
{
    println!("biguint_panic_free_modular_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case 1
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_uint = 5_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_uint = 248_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "55975706890540585964020877768978822316880213476032380583548819983093801176");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_uint = 5_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 = multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_uint = 5_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_uint = 0_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let mul_uint = 4321000_u32;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_uint = 0_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_uint = 4321000_u32;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_uint = 0_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_uint = 4321000_u32;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == 0
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::zero();
    let mul_uint = 248_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // modulo == 1
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::one();
    let mul_uint = 248_u8;
    let res = a_biguint.panic_free_modular_mul_uint(mul_uint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_uint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // collectively
    for a_biguint in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [0_u8, 3_u8, 50_u8]
        {
            for m in [U256::zero(), U256::one()]
            {
                let res = a_biguint.panic_free_modular_mul_uint(rhs, &m);
                println!("{} * {} = {} (mod {})", a_biguint, rhs, res, m);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_mul_assign_uint()
{
    println!("biguint_panic_free_modular_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_uint = 5_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_uint = 248_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "55975706890540585964020877768978822316880213476032380583548819983093801176");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mul_uint = 248_u16;
    a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "55975706890540585964020877768978822316880213476032380583548819983093801176");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mul_uint = 2_u16;
    a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "35149539482914268500351723679771158582906673069252814597151206317181518258");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
    println!("After a.panic_free_modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 3_u8;
    a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
    println!("After a.panic_free_modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
    println!("After a.panic_free_modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
    println!("After a.panic_free_modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
    println!("After a.panic_free_modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "750");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 0_u8;
    a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
    println!("After a.panic_free_modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "150");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let rhs = 250_u8;
    a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
    println!("After a.panic_free_modular_mul_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == 0
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::zero();
    let mul_uint = 248_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // modulo == 1
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::one();
    let mul_uint = 248_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign_uint(mul_uint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // collectively
    for a in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [0_u8, 3_u8, 50_u8]
        {
            for m in [U256::zero(), U256::one()]
            {
                let mut a_biguint = a.clone();
                println!("Originally, a = {}", a_biguint);
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), false);
            
                a_biguint.panic_free_modular_mul_assign_uint(rhs, &m);
                println!("After a_biguint.panic_free_modular_mul_assign_uint({}, &{}), a_biguint = {}", rhs, a_biguint, m);
                assert_eq!(a_biguint.to_string(), "0");
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_div_uint()
{
    biguint_divide_fully_uint();
    biguint_panic_free_divide_fully_uint();
    biguint_wrapping_div_uint();
    biguint_wrapping_div_assign_uint();
    biguint_overflowing_div_uint();
    biguint_overflowing_div_assign_uint();
    biguint_checked_div_uint();
    biguint_unchecked_div_uint();
    biguint_saturating_div_uint();
    biguint_saturating_div_assign_uint();
    biguint_panic_free_div_uint();
    biguint_panic_free_div_assign_uint();
    biguint_modular_div_uint();
    biguint_modular_div_assign_uint();
    biguint_panic_free_modular_div_uint();
    biguint_panic_free_modular_div_assign_uint();
}

fn biguint_divide_fully_uint()
{
    println!("biguint_divide_fully_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let (quotient, remainder) = dividend.divide_fully_uint(divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = 87_u8;
    let (quotient, remainder) = dividend.divide_fully_uint(divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_divide_fully_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_divide_fully_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let (_quotient, _remainder) = _dividend.divide_fully_uint(_divisor);

    let _dividend = UU32::zero();
    let _divisor = 0_u8;
    let (_quotient, _remainder) = _dividend.divide_fully_uint(_divisor);
}

fn biguint_panic_free_divide_fully_uint()
{
    println!("biguint_panic_free_divide_fully_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let (quotient, remainder) = dividend.panic_free_divide_fully_uint(divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // Normal case 2
    let dividend = UU32::zero();
    let divisor = 87_u8;
    let (quotient, remainder) = dividend.panic_free_divide_fully_uint(divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // dividend != 0 and divisor == 0
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 0_u8;
    let (quotient, remainder) = dividend.panic_free_divide_fully_uint(divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient, UU32::max());
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // dividend == 0 and divisor == 0
    let dividend = UU32::zero();
    let divisor = 0_u8;
    let (quotient, remainder) = dividend.panic_free_divide_fully_uint(divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_wrapping_div_uint()
{
    println!("biguint_wrapping_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let quotient = dividend.wrapping_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = U256::zero();
    let divisor = 87_u8;
    let quotient = dividend.wrapping_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_wrapping_div_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_wrapping_div_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _quotient = _dividend.wrapping_div_uint(_divisor);

    let _dividend = U256::zero();
    let _divisor = 0_u8;
    let _quotient = _dividend.wrapping_div_uint(_divisor);
}

fn biguint_wrapping_div_assign_uint()
{
    println!("biguint_wrapping_div_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.wrapping_div_assign_uint(divisor);
    println!("After a_biguint.wrapping_div_assign_uint(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.wrapping_div_assign_uint(divisor);
    println!("After a_biguint.wrapping_div_assign_uint(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_wrapping_div_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_wrapping_div_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    _a_biguint.wrapping_div_assign_uint(_divisor);

    let mut _a_biguint = UU32::zero();
    let _divisor = 0_u8;
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    _a_biguint.wrapping_div_assign_uint(_divisor);
}

fn biguint_overflowing_div_uint()
{
    println!("biguint_overflowing_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let (quotient, overflow) = dividend.overflowing_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(overflow, false);
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = U256::zero();
    let divisor = 87_u8;
    let (quotient, overflow) = dividend.overflowing_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(overflow, false);
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_overflowing_div_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_overflowing_div_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let (_quotient, _overflow) = _dividend.overflowing_div_uint(_divisor);

    let _dividend = U256::zero();
    let _divisor = 0_u8;
    let (_quotient, _overflow) = _dividend.overflowing_div_uint(_divisor);
}

fn biguint_overflowing_div_assign_uint()
{
    println!("biguint_overflowing_div_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let overflow = a_biguint.overflowing_div_assign_uint(divisor);
    println!("After a_biguint.overflowing_div_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let overflow = a_biguint.overflowing_div_assign_uint(divisor);
    println!("After a_biguint.overflowing_div_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();

    #[cfg(test)] // It will panic.
    biguint_should_panic_overflowing_div_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_overflowing_div_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _overflow = _a_biguint.overflowing_div_assign_uint(_divisor);

    let mut _a_biguint = UU32::zero();
    let _divisor = 0_u8;
    let _overflow = _a_biguint.overflowing_div_assign_uint(_divisor);
}

fn biguint_checked_div_uint()
{
    println!("biguint_checked_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let quotient = dividend.checked_div_uint(divisor);
    match quotient
    {
        Some(q) =>
            {
                println!("{} / {} = {}", dividend, divisor, q);
                assert_eq!(q.to_string(), "1419043551905275201680884938348044216837079832");
                assert_eq!(q.is_overflow(), false);
                assert_eq!(q.is_underflow(), false);
                assert_eq!(q.is_infinity(), false);
                assert_eq!(q.is_undefined(), false);
                assert_eq!(q.is_divided_by_zero(), false);
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = U256::zero();
    let divisor = 87_u8;
    let quotient = dividend.checked_div_uint(divisor);
    match quotient
    {
        Some(q) =>
            {
                println!("{} / {} = {}", dividend, divisor, q);
                assert_eq!(q.to_string(), "0");
                assert_eq!(q.is_overflow(), false);
                assert_eq!(q.is_underflow(), false);
                assert_eq!(q.is_infinity(), false);
                assert_eq!(q.is_undefined(), false);
                assert_eq!(q.is_divided_by_zero(), false);
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 0_u8;
    let quotient = dividend.checked_div_uint(divisor);
    match quotient
    {
        Some(q) => { println!("{} / {} = {}", dividend, divisor, q); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(quotient, None);
            },
    }

    let dividend = U256::zero();
    let divisor = 0_u8;
    let quotient = dividend.checked_div_uint(divisor);
    match quotient
    {
        Some(q) => { println!("{} / {} = {}", dividend, divisor, q); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(quotient, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_div_uint()
{
    println!("biguint_unchecked_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let quotient = dividend.unchecked_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = 87_u8;
    let quotient = dividend.unchecked_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_unchecked_div_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_unchecked_div_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _quotient = _dividend.unchecked_div_uint(_divisor);

    let _dividend = UU32::zero();
    let _divisor = 0_u8;
    let _quotient = _dividend.unchecked_div_uint(_divisor);
}

fn biguint_saturating_div_uint()
{
    println!("biguint_saturating_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let quotient = dividend.saturating_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = 87_u8;
    let quotient = dividend.saturating_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_saturating_div_uint();
    println!("---------------------------")
}

#[test]
#[should_panic]
fn biguint_should_panic_saturating_div_uint()
{
    println!("biguint_saturating_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _quotient = _dividend.saturating_div_uint(_divisor);

    let _dividend = UU32::zero();
    let _divisor = 0_u8;
    let _quotient = _dividend.saturating_div_uint(_divisor);
    println!("---------------------------")
}

fn biguint_saturating_div_assign_uint()
{
    println!("biguint_saturating_div_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.saturating_div_assign_uint(divisor);
    println!("After a_biguint.saturating_div_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.saturating_div_assign_uint(divisor);
    println!("After a_biguint.saturating_div_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_saturating_div_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_saturating_div_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    println!("Originally, _a_biguint = {}", _a_biguint);
    _a_biguint.saturating_div_assign_uint(_divisor);

    let mut _a_biguint = UU32::zero();
    let _divisor = 0_u8;
    println!("Originally, _a_biguint = {}", _a_biguint);
    _a_biguint.saturating_div_assign_uint(_divisor);
    println!("---------------------------");
}


fn biguint_panic_free_div_uint()
{
    println!("biguint_panic_free_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let quotient = dividend.panic_free_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // Normal case 2
    let dividend = U256::zero();
    let divisor = 87_u8;
    let quotient = dividend.panic_free_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // dividend != 0 and divisor = 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 0_u8;
    let quotient = dividend.panic_free_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient, U256::max());
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // dividend == 0 and divisor = 0
    let dividend = U256::zero();
    let divisor = 0_u8;
    let quotient = dividend.panic_free_div_uint(divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_panic_free_div_assign_uint()
{
    println!("biguint_panic_free_div_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u8;
    a_biguint.panic_free_div_assign_uint(divisor);
    println!("After a_biguint.panic_free_div_assign_uint(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u8;
    a_biguint.panic_free_div_assign_uint(divisor);
    println!("After a_biguint.panic_free_div_assign_uint(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    a_biguint.panic_free_div_assign_uint(divisor);
    println!("After a_biguint.panic_free_div_assign_uint(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint, UU32::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    a_biguint.panic_free_div_assign_uint(divisor);
    println!("After a_biguint.panic_free_div_assign_uint(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_modular_div_uint()
{
    println!("biguint_modular_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "3");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // dividend == 0
    let dividend = U256::zero();
    let modulo = U256::from_uint(250_u8);
    let divisor = 3_u8;
    let res = dividend.modular_div_uint(divisor, &modulo);
    println!("{} / {} = {}(mod {})", dividend, divisor, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // dividend == multiple of modulo
    let dividend = U256::from_uint(750_u16);
    let modulo = U256::from_uint(250_u8);
    let divisor = 3_u8;
    let res = dividend.modular_div_uint(divisor, &modulo);
    println!("{} / {} = {}(mod {})", dividend, divisor, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_div_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_div_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // op2 == 0
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::from_uint(250_u8);
    let _rhs = 0_u8;
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);

    // op2 == multiple of modulo
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::from_uint(50_u8);
    let _rhs = 250_u8;
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);

    // op1 == 0 and op2 == 0
    let _a_biguint = U256::zero();
    let _m = U256::from_uint(250_u8);
    let _rhs = 0_u8;
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);

    // op1 == multiple of modulo and op2 == 0
    let _a_biguint = U256::from_uint(750_u16);
    let _m = U256::from_uint(250_u8);
    let _rhs = 0_u8;
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);

    // op1 == 0 and op2 == multiple of modulo
    let _a_biguint = U256::zero();
    let _m = U256::from_uint(50_u8);
    let _rhs = 250_u8;
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let _a_biguint = U256::from_uint(150_u8);
    let _m = U256::from_uint(50_u8);
    let _rhs = 250_u8;
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);

    // modulo == 0
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 128_u8;
    let _modulo = U256::zero();
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);

    // modulo == 1
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 128_u8;
    let _modulo = U256::one();
    let _res = _a_biguint.modular_div_uint(_rhs, &_m);
}

fn biguint_modular_div_assign_uint()
{
    println!("biguint_modular_div_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_div_assign_uint({}, {}),\na_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // dividend == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 3_u8;
    let modulo = U256::from_uint(250_u8);
    a_biguint.modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_div_assign_uint({}, {}),\na_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // dividend == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let modulo = U256::from_uint(250_u8);
    let divisor = 3_u8;
    a_biguint.modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_div_assign_uint({}, {}),\na_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_div_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_div_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // op2 == 0
    let mut _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(250_u8);
    let _rhs = 0_u8;
    _a_biguint.modular_div_assign_uint(_rhs, &_m);

    // op2 == multiple of modulo
    let mut _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(50_u8);
    let _rhs = 250_u8;
    _a_biguint.modular_div_assign_uint(_rhs, &_m);

    // op1 == 0 and op2 == 0
    let mut _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(250_u8);
    let _rhs = 0_u8;
    _a_biguint.modular_div_assign_uint(_rhs, &_m);

    // op1 == multiple of modulo and op2 == 0
    let mut _a_biguint = U256::from_uint(750_u16);
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(250_u8);
    let _rhs = 0_u8;
    _a_biguint.modular_div_assign_uint(_rhs, &_m);

    // op1 == 0 and op2 == multiple of modulo
    let mut _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(50_u8);
    let _rhs = 250_u8;
    _a_biguint.modular_div_assign_uint(_rhs, &_m);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut _a_biguint = U256::from_uint(150_u8);
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(50_u8);
    let _rhs = 250_u8;
    _a_biguint.modular_div_assign_uint(_rhs, &_m);

    // modulo == 0
    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _divisor = 128_u8;
    let _modulo = U256::zero();
    _a_biguint.modular_div_assign_uint(_divisor, &_modulo);

    // modulo == 1
    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _divisor = 128_u8;
    let _modulo = U256::one();
    _a_biguint.modular_div_assign_uint(_divisor, &_modulo);
}

fn biguint_panic_free_modular_div_uint()
{
    println!("biguint_panic_free_modular_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case 1
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "3");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // Normal case 2 for modulo >= 2 and dividend == 0 and divisor != 0
    let dividend = U256::zero();
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // Normal case 3 for modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let dividend = U256::from_uint(10000_u16);
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // modulo >= 2 and divisor == 0 and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient, U256::max());
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == multiple of modulo and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient, U256::max());
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == 0 and dividend == multiple of modulo
    let dividend = U256::from_uint(30000_u16);
    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == multiple of modulo and dividend == 0
    let dividend = U256::zero();
    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == multiple of modulo and dividend == multiple of modulo
    let dividend = U256::from_uint(30000_u16);
    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo == 0 and divisor != 0 and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::zero();
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // modulo == 1 and divisor != 0 and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::one();
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // modulo == 0 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::zero();
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::one();
    let quotient = dividend.panic_free_modular_div_uint(divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let op1 = U256::zero();
        let op2 = 0_u8;
        let res = op1.panic_free_modular_div_uint(op2, &modulo);
        println!("{} / {} = {} (mod {})", op1, op2, res, modulo);
        assert_eq!(res.to_string(), "0");
        assert_eq!(res.is_overflow(), false);
        assert_eq!(res.is_underflow(), false);
        assert_eq!(res.is_divided_by_zero(), true);
        assert_eq!(res.is_infinity(), false);
        assert_eq!(res.is_undefined(), true);
        
        for dividend in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let rhs = 0_u8;
            let res = dividend.panic_free_modular_div_uint(rhs, &modulo);
            println!("{} / {} = {} (mod {})", dividend, rhs, res, modulo);
            assert_eq!(res.to_string(), "0");
            assert_eq!(res.is_overflow(), false);
            assert_eq!(res.is_underflow(), false);
            assert_eq!(res.is_divided_by_zero(), true);
            assert_eq!(res.is_infinity(), true);
            assert_eq!(res.is_undefined(), true);

            for divisor in [3_u8, 50_u8]
            {
                let res = dividend.panic_free_modular_div_uint(divisor, &modulo);
                println!("{} / {} = {} (mod {})", dividend, divisor, res, modulo);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_div_assign_uint()
{
    println!("biguint_panic_free_modular_div_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2 for modulo >= 2 and self == 0 and divisor != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 3 for modulo >= 2 and self == multiple of modulo and divisor != 0
    let mut a_biguint = U256::from_uint(10000_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self != 0 and divisor == 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639935");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self != 0 and divisor == multiple of modulo
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639935");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == multiple of modulo
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == 0
    let mut a_biguint = U256::from_uint(30000_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == multiple of modulo
    let mut a_biguint = U256::from_uint(30000_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 0 and divisor != 0 and dividend != 0
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = U256::zero();
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 1 and divisor != 0 and dividend != 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = U256::one();
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 0 and divisor == 0 and dividend == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::zero();
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and dividend == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::one();
    a_biguint.panic_free_modular_div_assign_uint(divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // Collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let mut dividend = U256::zero();
        println!("Originally, op1 = {}", dividend);
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), false);
        assert_eq!(dividend.is_divided_by_zero(), false);

        let divisor = 0_u8;
        dividend.panic_free_modular_div_assign_uint(divisor, &modulo);
        println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), op1 = {}", divisor, modulo, dividend);
        assert_eq!(dividend.to_string(), "0");
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_divided_by_zero(), true);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), true);
        
        for op in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let mut dividend = op.clone();
            println!("Originally, dividend = {}", dividend);
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_infinity(), false);
            assert_eq!(dividend.is_undefined(), false);
            assert_eq!(dividend.is_divided_by_zero(), false);

            let divisor = 0_u8;
            dividend.panic_free_modular_div_assign_uint(divisor, &modulo);
            println!("After op1.panic_free_modular_div_assign_uint({}, {}), dividend = {}", divisor, modulo, dividend);
            assert_eq!(dividend.to_string(), "0");
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_divided_by_zero(), true);
            assert_eq!(dividend.is_infinity(), true);
            assert_eq!(dividend.is_undefined(), true);

            for divisor in [3_u8, 50_u8]
            {
                let mut dividend = op.clone();
                println!("Originally, dividend = {}", dividend);
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
    
                dividend.panic_free_modular_div_assign_uint(divisor, &modulo);
                println!("After dividend.panic_free_modular_div_assign_uint({}, {}), dividend = {}", divisor, modulo, dividend);
                assert_eq!(dividend.to_string(), "0");
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_rem_uint()
{
    biguint_wrapping_rem_uint();
    biguint_wrapping_rem_assign_uint();
    biguint_overflowing_rem_uint();
    biguint_overflowing_rem_assign_uint();
    biguint_checked_rem_uint();
    biguint_unchecked_rem_uint();
    biguint_saturating_rem_uint();
    biguint_saturating_rem_assign_uint();
    biguint_panic_free_rem_uint();
    biguint_panic_free_rem_assign_uint();
    biguint_modular_rem_uint();
    biguint_modular_rem_assign_uint();
    biguint_panic_free_modular_rem_uint();
    biguint_panic_free_modular_rem_assign_uint();
}

fn biguint_wrapping_rem_uint()
{
    println!("biguint_wrapping_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let remainder = dividend.wrapping_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");

    let dividend = UU32::zero();
    let divisor = 87_u8;
    let remainder = dividend.wrapping_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");

    #[cfg(test)] // It will panic.
    biguint_should_panic_wrapping_rem_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_wrapping_rem_uint()
{
    println!("biguint_wrapping_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _remainder = _dividend.wrapping_rem_uint(_divisor);

    let _dividend = UU32::zero();
    let _divisor = 0_u8;
    let _remainder = _dividend.wrapping_rem_uint(_divisor);
}

fn biguint_wrapping_rem_assign_uint()
{
    println!("biguint_wrapping_rem_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u8;
    a_biguint.wrapping_rem_assign_uint(divisor);
    println!("After a_biguint.wrapping_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u8;
    a_biguint.wrapping_rem_assign_uint(divisor);
    println!("After a_biguint.wrapping_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_wrapping_rem_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_wrapping_rem_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    println!("Originally, a_biguint = {}", _a_biguint);
    _a_biguint.wrapping_rem_assign_uint(_divisor);

    let mut _a_biguint = U256::zero();
    let _divisor = 0_u8;
    println!("Originally, a_biguint = {}", _a_biguint);
    _a_biguint.wrapping_rem_assign_uint(_divisor);
}

fn biguint_overflowing_rem_uint()
{
    println!("biguint_overflowing_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let (remainder, overflow) = dividend.overflowing_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder, 8);
    assert_eq!(overflow, false);

    let dividend = UU32::zero();
    let divisor = 87_u8;
    let (remainder, overflow) = dividend.overflowing_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder, 0);
    assert_eq!(overflow, false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_overflowing_rem_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_overflowing_rem_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let (_remainder, _overflow) = _dividend.overflowing_rem_uint(_divisor);

    let _dividend = UU32::zero();
    let _divisor = 0_u8;
    let (_remainder, _overflow) = _dividend.overflowing_rem_uint(_divisor);
}

fn biguint_overflowing_rem_assign_uint()
{
    println!("biguint_overflowing_rem_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u16;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let overflow = a_biguint.overflowing_rem_assign_uint(divisor);
    println!("After a_biguint.overflowing_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    let divisor = 87_u16;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let overflow = a_biguint.overflowing_rem_assign_uint(divisor);
    println!("After a_biguint.overflowing_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_overflowing_rem_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_overflowing_rem_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u16;
    println!("Originally, a_biguint = {}", _a_biguint);
    let _overflow = _a_biguint.overflowing_rem_assign_uint(_divisor);

    let mut _a_biguint = U256::zero();
    let _divisor = 0_u16;
    println!("Originally, a_biguint = {}", _a_biguint);
    let _overflow = _a_biguint.overflowing_rem_assign_uint(_divisor);
}

fn biguint_checked_rem_uint()
{
    println!("biguint_checked_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let remainder = dividend.checked_rem_uint(divisor);
    match remainder
    {
        Some(r) =>
            {
                println!("{} % {} = {}", dividend, divisor, r);
                assert_eq!(r.to_string(), "8");
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = UU32::zero();
    let divisor = 87_u8;
    let remainder = dividend.checked_rem_uint(divisor);
    match remainder
    {
        Some(r) =>
            {
                println!("{} % {} = {}", dividend, divisor, r);
                assert_eq!(r.to_string(), "0");
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 0_u8;
    let remainder = dividend.checked_rem_uint(divisor);
    match remainder
    {
        Some(r) => { println!("{} % {} = {}", dividend, divisor, r); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(remainder, None);
            },
    }

    let dividend = UU32::zero();
    let divisor = 0_u8;
    let remainder = dividend.checked_rem_uint(divisor);
    match remainder
    {
        Some(r) => { println!("{} % {} = {}", dividend, divisor, r); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(remainder, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_rem_uint()
{
    println!("biguint_unchecked_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let remainder = dividend.unchecked_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");

    let dividend = U256::zero();
    let divisor = 87_u8;
    let remainder = dividend.unchecked_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");

    #[cfg(test)] // It will panic.
    biguint_should_panic_unchecked_rem_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_unchecked_rem_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _remainder = _dividend.unchecked_rem_uint(_divisor);

    let _dividend = U256::zero();
    let _divisor = 0_u8;
    let _remainder = _dividend.unchecked_rem_uint(_divisor);
}

fn biguint_saturating_rem_uint()
{
    println!("biguint_saturating_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let remainder = dividend.saturating_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");

    let dividend = UU32::zero();
    let divisor = 87_u8;
    let remainder = dividend.saturating_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");

    #[cfg(test)] // It will panic.
    biguint_should_panic_saturating_rem_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_saturating_rem_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _remainder = _dividend.saturating_rem_uint(_divisor);

    let _dividend = UU32::zero();
    let _divisor = 0_u8;
    let _remainder = _dividend.saturating_rem_uint(_divisor);
}

fn biguint_saturating_rem_assign_uint()
{
    println!("biguint_saturating_rem_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u16;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.saturating_rem_assign_uint(divisor);
    println!("After a_biguint.saturating_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    let divisor = 87_u16;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.saturating_rem_assign_uint(divisor);
    println!("After a_biguint.saturating_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_saturating_rem_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_saturating_rem_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u16;
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    _a_biguint.saturating_rem_assign_uint(_divisor);

    let mut _a_biguint = U256::zero();
    let _divisor = 0_u16;
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    _a_biguint.saturating_rem_assign_uint(_divisor);
}

fn biguint_panic_free_rem_uint()
{
    println!("biguint_panic_free_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    let remainder = dividend.panic_free_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);
    assert_eq!(remainder.is_undefined(), false);

    // Normal case 2
    let dividend = UU32::zero();
    let divisor = 87_u8;
    let remainder = dividend.panic_free_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);
    assert_eq!(remainder.is_undefined(), false);

    // dividend != 0 and divisor == 0
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 0_u8;
    let remainder = dividend.panic_free_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    assert_eq!(remainder.is_undefined(), false);
    
    // dividend == 0 and divisor == 0
    let dividend = UU32::zero();
    let divisor = 0_u8;
    let remainder = dividend.panic_free_rem_uint(divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    assert_eq!(remainder.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_panic_free_rem_assign_uint()
{
    println!("biguint_panic_free_rem_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case 1
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_rem_assign_uint(divisor);
    println!("After a_biguint.panic_free_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = U256::zero();
    let divisor = 87_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_rem_assign_uint(divisor);
    println!("After a_biguint.panic_free_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // dividend != 0 and divisor == 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let divisor = 0_u8;
    a_biguint.panic_free_rem_assign_uint(divisor);
    println!("After a_biguint.panic_free_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // dividend == 0 and divisor == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let divisor = 0_u8;
    a_biguint.panic_free_rem_assign_uint(divisor);
    println!("After a_biguint.panic_free_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_modular_rem_uint()
{
    println!("biguint_modular_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "8");

    // modulo >= 2 and dividend == 0 and divisor != 0
    let dividend = U256::zero();
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");

    // modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let dividend = U256::from_uint(200_u8);
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");

    #[cfg(test)] // It will panic.
    biguint_should_panic_modular_rem_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_modular_rem_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // modulo >= 2 and dividend != 0 and divisor == 0    
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend != 0 and divisor == multiple of modulo
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == 0
    let _dividend = U256::zero();
    let _divisor = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == multiple of modulo
    let _dividend = U256::zero();
    let _divisor = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == 0
    let _dividend = U256::from_uint(200_u8);
    let _divisor = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == multiple of modulo
    let _dividend = U256::from_uint(200_u8);
    let _divisor = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);

    // modulo == 0
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 128_u8;
    let _modulo = U256::zero();
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);

    // modulo == 1
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 128_u8;
    let _modulo = U256::one();
    let _quotient = _dividend.modular_rem_uint(_divisor, &_modulo);
}

fn biguint_modular_rem_assign_uint()
{
    println!("biguint_modular_rem_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == 0 and divisor != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    #[cfg(test)] // It will panic.
    biguint_hould_panic_modular_rem_assign_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_hould_panic_modular_rem_assign_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // modulo >= 2 and dividend != 0 and divisor == 0
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend != 0 and divisor == multiple of modulo
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == 0
    let _a_biguint = U256::zero();
    let _divisor = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == multiple of modulo
    let _a_biguint = U256::zero();
    let _divisor = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == 0
    let _a_biguint = U256::from_uint(200_u8);
    let _divisor = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == multiple of modulo
    let _a_biguint = U256::from_uint(200_u8);
    let _divisor = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);

    // modulo == 0
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 128_u8;
    let _modulo = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);

    // modulo == 1
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 128_u8;
    let _modulo = U256::one();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_rem_assign_uint(_divisor, &_modulo);
    println!("---------------------------");
}

fn biguint_panic_free_modular_rem_uint()
{
    println!("biguint_panic_free_modular_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == 0 and divisor != 0
    let dividend = U256::zero();
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let dividend = U256::from_uint(200_u8);
    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo >= 2 and dividend != 0 and divisor == 0    
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    
    // modulo >= 2 and dividend != 0 and divisor == multiple of modulo
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and dividend == 0 and divisor == multiple of modulo
    let dividend = U256::zero();
    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and dividend == multiple of modulo and divisor == 0
    let dividend = U256::from_uint(200_u8);
    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and dividend == multiple of modulo and divisor == multiple of modulo
    let dividend = U256::from_uint(200_u8);
    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo == 0 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::zero();
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::one();
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo == 0 and divisor != 0 and divisor != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::zero();
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo == 1 and divisor != 0 and divisor != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::one();
    let remainder = dividend.panic_free_modular_rem_uint(divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let op1 = U256::zero();
        let op2 = 0_u8;
        let res = op1.panic_free_modular_rem_uint(op2, &modulo);
        println!("{} % {} = {} (mod {})", op1, op2, res, modulo);
        assert_eq!(res.to_string(), "0");
        assert_eq!(res.is_overflow(), false);
        assert_eq!(res.is_underflow(), false);
        assert_eq!(res.is_divided_by_zero(), true);
        assert_eq!(res.is_infinity(), false);
        assert_eq!(res.is_undefined(), true);
        
        for dividend in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let rhs = 0_u8;
            let res = dividend.panic_free_modular_rem_uint(rhs, &modulo);
            println!("{} % {} = {} (mod {})", dividend, rhs, res, modulo);
            assert_eq!(res.to_string(), "0");
            assert_eq!(res.is_overflow(), false);
            assert_eq!(res.is_underflow(), false);
            assert_eq!(res.is_divided_by_zero(), true);
            assert_eq!(res.is_infinity(), false);
            assert_eq!(res.is_undefined(), true);

            for divisor in [3_u8, 50_u8]
            {
                let res = dividend.panic_free_modular_rem_uint(divisor, &modulo);
                println!("{} % {} = {} (mod {})", dividend, divisor, res, modulo);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_rem_assign_uint()
{
    println!("biguint_panic_free_modular_rem_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self == 0 and divisor != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self == multiple of modulo and divisor != 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 128_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self != 0 and divisor == 0  
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self != 0 and divisor == multiple of modulo
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == multiple of modulo
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 0_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == multiple of modulo
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 0 and self != 0 and divisor != 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 1 and self != 0 and divisor != 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 128_u8;
    let modulo = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 0 and divisor == 0 and self == 0
    let mut a_biguint = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and self == 0
    let mut a_biguint = U256::zero();
    let divisor = 0_u8;
    let modulo = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_modular_rem_assign_uint(divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // Collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let mut dividend = U256::zero();
        println!("Originally, op1 = {}", dividend);
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), false);
        assert_eq!(dividend.is_divided_by_zero(), false);

        let divisor = 0_u8;
        dividend.panic_free_modular_rem_assign_uint(divisor, &modulo);
        println!("After a_biguint.panic_free_modular_rem_assign_uint({}, {}), op1 = {}", divisor, modulo, dividend);
        assert_eq!(dividend.to_string(), "0");
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_divided_by_zero(), true);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), true);
        
        for op in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let mut dividend = op.clone();
            println!("Originally, dividend = {}", dividend);
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_infinity(), false);
            assert_eq!(dividend.is_undefined(), false);
            assert_eq!(dividend.is_divided_by_zero(), false);

            let divisor = 0_u8;
            dividend.panic_free_modular_rem_assign_uint(divisor, &modulo);
            println!("After op1.panic_free_modular_rem_assign_uint({}, {}), dividend = {}", divisor, modulo, dividend);
            assert_eq!(dividend.to_string(), "0");
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_divided_by_zero(), true);
            assert_eq!(dividend.is_infinity(), false);
            assert_eq!(dividend.is_undefined(), true);

            for divisor in [3_u8, 50_u8]
            {
                let mut dividend = op.clone();
                println!("Originally, dividend = {}", dividend);
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
    
                dividend.panic_free_modular_rem_assign_uint(divisor, &modulo);
                println!("After dividend.panic_free_modular_rem_assign_uint({}, {}), dividend = {}", divisor, modulo, dividend);
                assert_eq!(dividend.to_string(), "0");
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_next_multiple_uint()
{
    biguint_next_multiple_of_uint();
    biguint_next_multiple_of_assign_uint();
    biguint_panic_free_next_multiple_of_uint();
    biguint_panic_free_next_multiple_of_assign_uint();
    biguint_modular_next_multiple_of_uint();
    biguint_modular_next_multiple_of_assign_uint();
    biguint_panic_free_modular_next_multiple_of_uint();
    biguint_panic_free_modular_next_multiple_of_assign_uint();
    biguint_is_multiple_of_uint();
}

fn biguint_next_multiple_of_uint()
{
    println!("biguint_next_multiple_of_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 586478_u32;
    let multiple = a_biguint.next_multiple_of_uint(num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    let a_biguint = U256::max();
    let num = 586478_u32;
    let multiple = a_biguint.next_multiple_of_uint(num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "448670");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    #[cfg(test)] // It will panic.
    biguint_should_panic_next_multiple_of_uint();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_next_multiple_of_uint()
{
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = 0_u32;
    let _multiple = _a_biguint.next_multiple_of_uint(_num);
}

fn biguint_next_multiple_of_assign_uint()
{
    println!("biguint_next_multiple_of_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 586478_u32;
    a_biguint.next_multiple_of_assign_uint(num);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 586478_u32;
    a_biguint.next_multiple_of_assign_uint(num);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "448670");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = 0_u8;
    // It will panic.
    // _a_biguint.next_multiple_of_assign_uint(_num);
    println!("---------------------------");
}

fn biguint_panic_free_next_multiple_of_uint()
{
    println!("biguint_panic_free_next_multiple_of_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 586478_u32;
    let multiple = a_biguint.panic_free_next_multiple_of_uint(num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    let a_biguint = U256::max();
    let num = 586478_u32;
    let multiple = a_biguint.panic_free_next_multiple_of_uint(num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "448670");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 0_u8;
    let multiple = a_biguint.panic_free_next_multiple_of_uint(num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);
    println!("---------------------------");
}

fn biguint_panic_free_next_multiple_of_assign_uint()
{
    println!("biguint_panic_free_next_multiple_of_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 586478_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_next_multiple_of_assign_uint(num);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::max();
    let num = 586478_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_next_multiple_of_assign_uint(num);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "448670");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 0_u8;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_next_multiple_of_assign_uint(num);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_modular_next_multiple_of_uint()
{
    println!("biguint_modular_next_multiple_of_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::max();
    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "1");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // rhs == 0
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = 0_u8;
    let _modulo = _a_biguint.wrapping_add_uint(200_u8);
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of_uint(_num, &_modulo);

    // rhs == multiple of modulo
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of_uint(_num, &_modulo);

    // modulo == 0
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = 100_u8;
    let _modulo = U256::zero();
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of_uint(_num, &_modulo);

    // modulo == 1
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = 100_u8;
    let _modulo = U256::one();
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of_uint(_num, &_modulo);
    println!("---------------------------");
}

fn biguint_modular_next_multiple_of_assign_uint()
{
    println!("biguint_modular_next_multiple_of_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.modular_next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = UU32::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0
    let mut _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _num = 0_u8;
    let _modulo = _a_biguint.wrapping_add_uint(200_u8);
    // _a_biguint.modular_next_multiple_of_assign_uint(_num, &_modulo);

    // rhs == multiple of modulo
    let mut _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _num = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    // _a_biguint.modular_next_multiple_of_assign_uint(_num, &_modulo);

    // modulo == 0
    let mut _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _num = 100_u8;
    let _modulo = U256::zero();
    // _a_biguint.modular_next_multiple_of_assign_uint(_num, &_modulo);

    // modulo == 1
    let mut _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _num = 100_u8;
    let _modulo = U256::one();
    // _a_biguint.modular_next_multiple_of_assign_uint(_num, &_modulo);
    println!("---------------------------");
}

fn biguint_panic_free_modular_next_multiple_of_uint()
{
    println!("biguint_panic_free_modular_next_multiple_of_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::max();
    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "1");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // rhs == 0
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 0_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // rhs == multiple of modulo
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // modulo == 0
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 100_u8;
    let modulo = U256::zero();
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // modulo == 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 100_u8;
    let modulo = U256::one();
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // rhs == 0 and modulo == 0
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 0_u8;
    let modulo = U256::zero();
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // rhs == 0 and modulo == 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = 0_u8;
    let modulo = U256::one();
    let multiple = a_biguint.panic_free_modular_next_multiple_of_uint(num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);
    println!("---------------------------");
}

fn biguint_panic_free_modular_next_multiple_of_assign_uint()
{
    println!("biguint_panic_free_modular_next_multiple_of_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.modular_next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = UU32::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 100_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 0_u8;
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == multiple of modulo
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 100_u8;
    let modulo = U256::zero();
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 1
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 100_u8;
    let modulo = U256::one();
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0 and modulo == 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 0_u8;
    let modulo = U256::zero();
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0 and modulo == 1
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = 0_u8;
    let modulo = U256::one();
    a_biguint.panic_free_modular_next_multiple_of_assign_uint(num, &modulo);
    println!("After a_biguint.next_multiple_of_assign_uint({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_multiple_of_uint()
{
    println!("biguint_is_multiple_of_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let a_biguint = U256::from_str("12345678901234567890123456789012345678900").unwrap();
    let rhs = 100_u8;
    let ans = a_biguint.is_multiple_of_uint(rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, true);

    // Normal case 2
    let a_biguint = U256::from_str("12345678901234567890123456789012345678900").unwrap();
    let rhs = 99_u8;
    let ans = a_biguint.is_multiple_of_uint(rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, false);

    // rhs == 0 and self != 0
    let a_biguint = U256::from_str("12345678901234567890123456789012345678900").unwrap();
    let rhs = 0_u8;
    let ans = a_biguint.is_multiple_of_uint(rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, false);

    // rhs == 0 and self == 0
    let a_biguint = U256::zero();
    let rhs = 0_u8;
    let ans = a_biguint.is_multiple_of_uint(rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, true);
    println!("---------------------------");
}


fn biguint_exponentiation_logarithm_uint_main()
{
    biguint_pow_uint();
    biguint_pow_assign_uint();
    biguint_panic_free_pow_uint();
    biguint_panic_free_pow_assign_uint();
    biguint_wrapping_pow_uint();
    biguint_wrapping_pow_assign_uint();
    biguint_overflowing_pow_uint();
    biguint_overflowing_pow_assign_uint();
    biguint_checked_pow_uint();
    biguint_unchecked_pow_uint();
    biguint_saturating_pow_uint();
    biguint_saturating_pow_assign_uint();
    biguint_modular_pow_uint();
    biguint_modular_pow_assign_uint();
    biguint_panic_free_modular_pow_uint();
    biguint_panic_free_modular_pow_assign_uint();

    biguint_iroot_uint();
    biguint_iroot_assign_uint();
    biguint_panic_free_iroot_uint();
    biguint_panic_free_iroot_assign_uint();
    biguint_checked_iroot_uint();
    biguint_unchecked_iroot_uint();

    biguint_ilog_uint();
    biguint_ilog_assign_uint();
    biguint_panic_free_ilog_uint();
    biguint_panic_free_ilog_assign_uint();
    biguint_checked_ilog_uint();
    biguint_unchecked_ilog_uint();
}

fn biguint_pow_uint()
{
    println!("biguint_pow_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // normal exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = 30_u8;
    let res = a_biguint.pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = 100_u8;
    let res = a_biguint.pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = 0_u8;
    let res = a_biguint.pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 30
    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let res = a_biguint.pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = UU32::zero();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.pow_uint(_exp);
    println!("---------------------------");
}

fn biguint_pow_assign_uint()
{
    println!("biguint_pow_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    a_biguint.pow_assign_uint(exp);
    println!("After a_biguint.pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 100_u8;
    a_biguint.pow_assign_uint(exp);
    println!("After a_biguint.pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 10_u8;
    a_biguint.pow_assign_uint(exp);
    println!("After a_biguint.pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.pow_assign_uint(exp);
    println!("After a_biguint.pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::zero();
    let _exp = 0_u8;
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic.
    // _a_biguint.pow_assign_uint(_exp);
    println!("---------------------------");
}

fn biguint_panic_free_pow_uint()
{
    println!("biguint_panic_free_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 30_u8;
    let res = a_biguint.panic_free_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 100_u8;
    let res = a_biguint.panic_free_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let res = a_biguint.panic_free_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let res = a_biguint.panic_free_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::zero();
    let exp = 0_u8;
    let res = a_biguint.panic_free_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_pow_assign_uint()
{
    println!("biguint_panic_free_pow_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 10_u8;
    a_biguint.panic_free_pow_assign_uint(exp);
    println!("After a_biguint.panic_free_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "10000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(10000000000_u64);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 10_u8;
    a_biguint.panic_free_pow_assign_uint(exp);
    println!("After a_biguint.panic_free_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 10_u8;
    a_biguint.panic_free_pow_assign_uint(exp);
    println!("After a_biguint.panic_free_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.panic_free_pow_assign_uint(exp);
    println!("After a_biguint.panic_free_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.panic_free_pow_assign_uint(exp);
    println!("After a_biguint.panic_free_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_wrapping_pow_uint()
{
    println!("biguint_wrapping_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 30_u32;
    let res = a_biguint.wrapping_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 100_u32;
    let res = a_biguint.wrapping_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let res = a_biguint.wrapping_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let res = a_biguint.wrapping_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = UU32::zero();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.wrapping_pow_uint(_exp);
    println!("---------------------------");
}

fn biguint_wrapping_pow_assign_uint()
{
    println!("biguint_wrapping_pow_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    a_biguint.wrapping_pow_assign_uint(exp);
    println!("After a_biguint.wrapping_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 100_u8;
    a_biguint.wrapping_pow_assign_uint(exp);
    println!("After a_biguint.wrapping_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    a_biguint.wrapping_pow_assign_uint(exp);
    println!("After a_biguint.wrapping_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.wrapping_pow_assign_uint(exp);
    println!("After a_biguint.wrapping_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::zero();
    let _exp = 0_u8;
    println!("Originally, _a_biguint = {}", _a_biguint);
    // It will panic.
    // _a_biguint.wrapping_pow_assign_uint(_exp);
    println!("---------------------------");
}

fn biguint_overflowing_pow_uint()
{
    println!("biguint_overflowing_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 30_u32;
    let (res, overflow) = a_biguint.overflowing_pow_uint(exp);
    println!("{} ** {} = {}\noverflow = {}", a_biguint, exp, res, overflow);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(overflow, false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 100_u32;
    let (res, overflow) = a_biguint.overflowing_pow_uint(exp);
    println!("{} ** {} = {}\noverflow = {}", a_biguint, exp, res, overflow);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(overflow, true);
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let (res, overflow) = a_biguint.overflowing_pow_uint(exp);
    println!("{} ** {} = {}\noverflow = {}", a_biguint, exp, res, overflow);
    assert_eq!(res.to_string(), "1");
    assert_eq!(overflow, false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let (res, overflow) = a_biguint.overflowing_pow_uint(exp);
    println!("{} ** {} = {}\noverflow = {}", a_biguint, exp, res, overflow);
    assert_eq!(res.to_string(), "0");
    assert_eq!(overflow, false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = UU32::zero();
    let _exp = 0_u8;
    // It will panic.
    // let (res, overflow) = _a_biguint.overflowing_pow_uint(_exp);

    println!("---------------------------");
}

fn biguint_overflowing_pow_assign_uint()
{
    println!("biguint_overflowing_pow_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    let overflow = a_biguint.overflowing_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}\noverflow = {}", exp, a_biguint, overflow);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_string("1000000000000000000000000000000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 3_u8;
    let overflow = a_biguint.overflowing_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}\noverflow = {}", exp, a_biguint, overflow);
    assert_eq!(a_biguint.to_string(), "51484102413631087777415798035541167055393351402420714880745735202410401366016");
    assert_eq!(overflow, true);
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    let overflow = a_biguint.overflowing_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}\noverflow = {}", exp, a_biguint, overflow);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 10_u8;
    let overflow = a_biguint.overflowing_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}\noverflow = {}", exp, a_biguint, overflow);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::zero();
    let _exp = 0_u8;
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic.
    // let overflow = _a_biguint.overflowing_pow_assign_uint(_exp);
    println!("---------------------------");
}

fn biguint_checked_pow_uint()
{
    println!("biguint_checked_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 30_u8;
    let res = a_biguint.checked_pow_uint(exp);
    match res
    {
        Some(raised) => {
                println!("{} ** {} = {}", a_biguint, exp, raised);
                assert_eq!(raised.to_string(), "1000000000000000000000000000000");
                assert_eq!(raised.is_overflow(), false);
                assert_eq!(raised.is_underflow(), false);
                assert_eq!(raised.is_infinity(), false);
                assert_eq!(raised.is_divided_by_zero(), false);
                assert_eq!(raised.is_undefined(), false);
            },
        None => { println!("Overflow"); }
    }

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 100_u8;
    let res = a_biguint.checked_pow_uint(exp);
    match res
    {
        Some(raised) => { println!("{} ** {} = {}", a_biguint, exp, raised); },
        None => {
                println!("Overflow");
                assert_eq!(res, None);
            },
    }

    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let res = a_biguint.checked_pow_uint(exp);
    match res
    {
        Some(raised) => {
                println!("{} ** {} = {}", a_biguint, exp, raised);
                assert_eq!(raised.to_string(), "0");
                assert_eq!(raised.is_overflow(), false);
                assert_eq!(raised.is_underflow(), false);
                assert_eq!(raised.is_infinity(), false);
                assert_eq!(raised.is_divided_by_zero(), false);
                assert_eq!(raised.is_undefined(), false);
            },
        None => { println!("Overflow"); }
    }

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let res = a_biguint.checked_pow_uint(exp);
    match res
    {
        Some(raised) => {
                println!("{} ** {} = {}", a_biguint, exp, raised);
                assert_eq!(raised.to_string(), "1");
                assert_eq!(raised.is_overflow(), false);
                assert_eq!(raised.is_underflow(), false);
                assert_eq!(raised.is_infinity(), false);
                assert_eq!(raised.is_divided_by_zero(), false);
                assert_eq!(raised.is_undefined(), false);
            },
        None => { println!("Overflow"); }
    }

    let a_biguint = UU32::zero();
    let exp = 0_u8;
    let res = a_biguint.checked_pow_uint(exp);
    match res
    {
        Some(raised) => { println!("{} ** {} = {}", a_biguint, exp, raised); },
        None => {
                println!("Undefined");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_pow_uint()
{
    println!("biguint_unchecked_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 30_u8;
    let res = a_biguint.unchecked_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = UU32::from_string("1000000000000000000000000000000");
    let _exp = 30_u8;
    // It will panic.
    // println!("{} ** {} = {}", _a_biguint, 100_u32, _a_biguint.unchecked_pow_uint(_exp);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let res = a_biguint.unchecked_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let res = a_biguint.unchecked_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = UU32::zero();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_pow_uint(_exp);
    println!("---------------------------");
}

fn biguint_saturating_pow_uint()
{
    println!("biguint_saturating_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    
    let a_biguint = U256::from_uint(10_u8);
    let exp = 30_u8;
    let res = a_biguint.saturating_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_uint(10_u8);
    let exp = 100_u8;
    let res = a_biguint.saturating_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res, UU32::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let res = a_biguint.saturating_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let res = a_biguint.saturating_pow_uint(exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = UU32::zero();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.saturating_pow_uint(_exp);
    println!("---------------------------");
}

fn biguint_saturating_pow_assign_uint()
{
    println!("biguint_saturating_pow_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let mut a_biguint = UU32::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    a_biguint.saturating_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::from_uint(1000000000000000000000000000000_u128);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    a_biguint.saturating_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint, UU32::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::from_uint(100_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.saturating_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    a_biguint.saturating_pow_assign_uint(exp);
    println!("After a_biguint.overflowing_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = UU32::zero();
    let _exp = 0_u8;
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic.
    // _a_biguint.saturating_pow_assign_uint(_exp);
    println!("---------------------------");
}

fn biguint_modular_pow_uint()
{
    println!("biguint_modular_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Noraml case 1
    let a_biguint = U256::from_uint(10_u8);
    let exp = 30_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.modular_pow_uint(exp, &modulo);
    println!("{} ** {} (mod {}) = {}", a_biguint, exp, modulo, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Normal case 2
    let a_biguint = U256::from_uint(10_u8);
    let exp = 100_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.modular_pow_uint(exp, &modulo);
    println!("{} ** {} (mod {}) = {}", a_biguint, exp, modulo, res);
    assert_eq!(res.to_string(), "59749648429786538521694772865754025520");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = 200_u8;
    let modulo = U256::from_uint(100_u8);
    let res = a_biguint.modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let a_biguint = UU32::from_uint(300_u16);
    let exp = 30_u8;
    let modulo = U256::from_uint(100_u8);
    let res = a_biguint.modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let _a_biguint = UU32::zero();
    let _exp = 0_u8;
    let _modulo = U256::halfmax();
    // It will panic.
    // let res = _a_biguint.modular_pow_uint(_exp, &_modulo);

    // self == 0 and exp == multiple of modulo and modulo != 0
    let _a_biguint = UU32::zero();
    let _exp = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    // It will panic.
    // let res = _a_biguint.modular_pow_uint(_exp, &_modulo);

    // self == multiple of modulo and exp == 0 and modulo != 0
    let _a_biguint = UU32::from_uint(300_u16);
    let _exp = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    // It will panic.
    // let res = _a_biguint.modular_pow_uint(_exp, &_modulo);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let _a_biguint = UU32::from_uint(300_u16);
    let _exp = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    // It will panic.
    // let res = _a_biguint.modular_pow_uint(_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 0
    let _a_biguint = U256::from_uint(10_u8);
    let _exp = 100_u8;
    let _modulo = U256::zero();
    // It will panic!
    // let _res = a_biguint.modular_pow_uint(_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 1
    let _a_biguint = U256::from_uint(10_u8);
    let _exp = 100_u8;
    let _modulo = U256::one();
    // It will panic!
    // let _res = a_biguint.modular_pow_uint(_exp, &_modulo);

    // self == 0 and exp == 0 and modulo == 0
    let _a_biguint = U256::zero();
    let _exp = 0_u8;
    let _modulo = U256::zero();
    // It will panic!
    // let _res = a_biguint.modular_pow_uint(_exp, &_modulo);
    println!("---------------------------");
}

fn biguint_modular_pow_assign_uint()
{
    println!("biguint_modular_pow_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Noraml case 1
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.modular_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = U256::from_uint(1000000000000000000000000000000_u128);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 100_u8;
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.modular_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "52266245075570873327294567809656160090");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.modular_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.modular_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.modular_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let mut a_biguint = UU32::from_uint(300_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.modular_pow_assign_uint({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let mut _a_biguint = U256::zero();
    let _exp = 0_u8;
    let _modulo = U256::halfmax();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_pow_assign_uint(_exp, &_modulo);

    // self == 0 and exp == multiple of modulo and modulo != 0
    let mut _a_biguint = U256::zero();
    let _exp = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_pow_assign_uint(_exp, &_modulo);

    // self == multiple of modulo and exp == 0 and modulo != 0
    let mut _a_biguint = U256::from_uint(300_u16);
    let _exp = 0_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_pow_assign_uint(_exp, &_modulo);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let mut _a_biguint = U256::from_uint(300_u16);
    let _exp = 200_u8;
    let _modulo = U256::from_uint(100_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_pow_assign_uint(_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 0
    let mut _a_biguint = U256::from_uint(10_u8);
    let _exp = 100_u8;
    let _modulo = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_pow_assign_uint(_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 1
    let _a_biguint = U256::from_uint(10_u8);
    let _exp = 100_u8;
    let _modulo = U256::one();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_pow_assign_uint(_exp, &_modulo);

    // self == 0 and exp == 0 and modulo == 0
    let mut _a_biguint = U256::zero();
    let _exp = 0_u8;
    let _modulo = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.modular_pow_assign_uint(_exp, &_modulo);
    println!("---------------------------");
}

fn biguint_panic_free_modular_pow_uint()
{
    println!("biguint_panic_free_modular_pow_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Noraml case 1
    let a_biguint = U256::from_uint(10_u8);
    let exp = 30_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Normal case 2
    let a_biguint = U256::from_uint(10_u8);
    let exp = 100_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "59749648429786538521694772865754025520");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = 0_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = 2000_u16;
    let modulo = U256::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let a_biguint = UU32::zero();
    let exp = 30_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let a_biguint = U256::from_uint(3000_u16);
    let exp = 30_u8;
    let modulo = U256::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let a_biguint = UU32::zero();
    let exp = 0_u8;
    let modulo = U256::halfmax();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == multiple of modulo and modulo != 0
    let a_biguint = U256::zero();
    let exp = 2000_u16;
    let modulo = U256::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp == 0 and modulo != 0
    let a_biguint = U256::from_uint(3000_u16);
    let exp = 0_u8;
    let modulo = U256::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let a_biguint = U256::from_uint(3000_u16);
    let exp = 2000_u16;
    let modulo = U256::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 0
    let a_biguint = U256::from_uint(10_u8);
    let exp = 100_u8;
    let modulo = U256::zero();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 1
    let a_biguint = U256::from_uint(10_u8);
    let exp = 100_u8;
    let modulo = U256::one();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo == 0
    let a_biguint = U256::zero();
    let exp = 0_u8;
    let modulo = U256::zero();
    let res = a_biguint.panic_free_modular_pow_uint(exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // collectively
    for modulo in [U256::zero(), U256::one()]
    {
        for lhs in [U256::zero(), U256::from_uint(50_u8)]
        {
            for rhs in [0_u8, 50_u8]
            {
                let res = lhs.panic_free_modular_pow_uint(rhs, &modulo);
                println!("{} ** {} = {} (mod {})", lhs, rhs, res, modulo);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_pow_assign_uint()
{
    println!("biguint_panic_free_modular_pow_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Noraml case 1
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = U256::from_uint(1000000000000000000000000000000_u128);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 100_u8;
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "52266245075570873327294567809656160090");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 200_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let mut a_biguint = UU32::from_uint(300_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 30_u8;
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 150_u8;
    let modulo = U256::from_uint(50_u8);
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 100_u8;
    let modulo = U256::zero();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 1
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 100_u8;
    let modulo = U256::one();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    let modulo = U256::zero();
    a_biguint.panic_free_modular_pow_assign_uint(exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // collectively
    for modulo in [U256::zero(), U256::one()]
    {
        for lhs in [U256::zero(), U256::from_uint(50_u8)]
        {
            for rhs in [0_u8, 50_u8]
            {
                let mut lhs = lhs.clone();
                println!("Originally, lhs = {}", lhs);
                assert_eq!(lhs.is_overflow(), false);
                assert_eq!(lhs.is_underflow(), false);
                assert_eq!(lhs.is_infinity(), false);
                assert_eq!(lhs.is_undefined(), false);
                assert_eq!(lhs.is_divided_by_zero(), false);

                lhs.panic_free_modular_pow_assign_uint(rhs, &modulo);
                println!("After lhs.panic_free_modular_pow_assign_uint({}, {}), lhs = {}", rhs, modulo, lhs);
                assert_eq!(lhs.to_string(), "0");
                assert_eq!(lhs.is_overflow(), false);
                assert_eq!(lhs.is_underflow(), false);
                assert_eq!(lhs.is_infinity(), false);
                assert_eq!(lhs.is_undefined(), true);
                assert_eq!(lhs.is_divided_by_zero(), false);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_iroot_uint()
{
    println!("biguint_iroot_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 8_u8;
    let res = a_biguint.iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "100000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 65_u8;
    let res = a_biguint.iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "9");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 212_u8;
    let res = a_biguint.iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 213_u8;
    let res = a_biguint.iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = u128::MAX;
    let res = a_biguint.iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = 6_u8;
    let res = a_biguint.iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.iroot_uint(_exp);

    let _a_biguint = U256::one();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.iroot_uint(_exp);

    let _a_biguint = U256::zero();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.iroot_uint(_exp);
    println!("---------------------------");
}

fn biguint_iroot_assign_uint()
{
    println!("biguint_iroot_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 8_u8;
    a_biguint.iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "100000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 65_u8;
    a_biguint.iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "9");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 212_u8;
    a_biguint.iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 213_u8;
    a_biguint.iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = u128::MAX;
    a_biguint.iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 6_u8;
    a_biguint.iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _exp = 0_u8;
    // It will panic.
    // a_biguint.iroot_assign_uint(exp);

    let mut _a_biguint = U256::one();
    let _exp = 0_u8;
    // It will panic.
    // a_biguint.iroot_assign_uint(exp);

    let mut _a_biguint = U256::zero();
    let _exp = 0_u8;
    // It will panic.
    // a_biguint.iroot_assign_uint(exp);
    println!("---------------------------");
}

fn biguint_panic_free_iroot_uint()
{
    println!("biguint_panic_free_iroot_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 8_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "100000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 65_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "9");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 212_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 213_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = u128::MAX;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = 6_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 0_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res, U256::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), true);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let exp = 0_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = 0_u8;
    let res = a_biguint.panic_free_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_iroot_assign_uint()
{
    println!("biguint_panic_free_iroot_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 8_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.panic_free_iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "100000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 65_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.panic_free_iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "9");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 212_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.panic_free_iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 213_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.panic_free_iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = u128::MAX;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.panic_free_iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 6_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint, U256::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = 0_u8;
    a_biguint.panic_free_iroot_assign_uint(exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_checked_iroot_uint()
{
    println!("biguint_checked_iroot_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 8_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => {
                println!("The third root of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "100000000");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 65_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => {
                println!("The square root of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "9");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 212_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => {
                println!("The square root of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "2");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 213_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => {
                println!("The square root of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "1");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = u128::MAX;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => {
                println!("The square root of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "1");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::zero();
    let exp = 6_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => {
                println!("The {}-th root of {} is {}.", exp, a_biguint, r);
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 0_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => { println!("The {}-th root of {} is {}.", exp, a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::one();
    let exp = 0_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => { println!("The {}-th root of {} is {}.", exp, a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let exp = 0_u8;
    let res = a_biguint.checked_iroot_uint(exp);
    match res
    {
        Some(r) => { println!("The {}-th root of {} is {}.", exp, a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_iroot_uint()
{
    println!("biguint_unchecked_iroot_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 8_u8;
    let res = a_biguint.unchecked_iroot_uint(exp);
    println!("The third root of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "100000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 65_u8;
    let res = a_biguint.unchecked_iroot_uint(exp);
    println!("The square root of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "9");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 212_u8;
    let res = a_biguint.unchecked_iroot_uint(exp);
    println!("The square root of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = 213_u8;
    let res = a_biguint.unchecked_iroot_uint(exp);
    println!("The square root of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = u128::MAX;
    let res = a_biguint.unchecked_iroot_uint(exp);
    println!("The square root of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = 6_u8;
    let res = a_biguint.unchecked_iroot_uint(exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_iroot_uint(_exp);

    let _a_biguint = U256::one();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_iroot_uint(_exp);

    let _a_biguint = U256::zero();
    let _exp = 0_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_iroot_uint(_exp);
    println!("---------------------------");
}

fn biguint_ilog_uint()
{
    println!("biguint_ilog_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 1_0000_0000_0000_0000_0000_0000_0000_0000_u128;
    let res = a_biguint.ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 10_u8;
    let res = a_biguint.ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "64");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = 6_u8;
    let res = a_biguint.ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.ilog_uint(_base);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.ilog_uint(_base);

    let _a_biguint = U256::zero();
    let _base = 6_u8;
    // It will panic.
    // let res = _a_biguint.ilog_uint(_base);

    let _a_biguint = U256::zero();
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.ilog_uint(_base);

    let _a_biguint = U256::zero();
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.ilog_uint(_base);

    let _a_biguint = U256::one();
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.ilog(&_base);

    let _a_biguint = U256::one();
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.ilog(&_base);
    println!("---------------------------");
}

fn biguint_ilog_assign_uint()
{
    println!("biguint_ilog_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 1_0000_0000_0000_0000_0000_0000_0000_0000_u128;
    a_biguint.ilog_assign_uint(base);
    println!("After a_biguint.ilog_assign_uint({}), a_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 10_u8;
    a_biguint.ilog_assign_uint(base);
    println!("After a_biguint.ilog_assign_uint({}), a_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "64");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 6_u8;
    a_biguint.ilog_assign_uint(base);
    println!("After a_biguint.ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.ilog_assign_uint(_base);

    let mut _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.ilog_assign_uint(_base);

    let _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = 6_u8;
    // It will panic.
    // let res = _a_biguint.ilog_assign_uint(_base);

    let _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.ilog_assign_uint(_base);

    let _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.ilog_assign_uint(_base);

    let _a_biguint = U256::one();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.ilog_assign_uint(_base);

    let _a_biguint = U256::one();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.ilog_assign_uint(_base);
    println!("---------------------------");
}

fn biguint_panic_free_ilog_uint()
{
    println!("biguint_panic_free_ilog_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 1_0000_0000_0000_0000_0000_0000_0000_0000_u128;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 10_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "64");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = 6_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 0_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res, U256::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), true);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 1_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res, U256::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), true);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let base = 6_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let base = 0_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let base = 1_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = 0_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = 1_u8;
    let res = a_biguint.panic_free_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_ilog_assign_uint()
{
    println!("biguint_panic_free_ilog_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 1_0000_0000_0000_0000_0000_0000_0000_0000_u128;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 10_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "64");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 6_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 0_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint, U256::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 1_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint, U256::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 6_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 0_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 1_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 0_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = 1_u8;
    a_biguint.panic_free_ilog_assign_uint(base);
    println!("After a_biguint.panic_free_ilog_assign_uint({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_checked_ilog_uint()
{
    println!("biguint_checked_ilog_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 1_0000_0000_0000_0000_0000_0000_0000_0000_u128;
    let res = a_biguint.checked_ilog_uint(base);
    match res
    {
        Some(r) => {
                println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r);
                assert_eq!(r.to_string(), "2");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 10_u8;
    let res = a_biguint.checked_ilog_uint(base);
    match res
    {
        Some(r) => {
                println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r);
                assert_eq!(r.to_string(), "64");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::one();
    let base = 6_u8;
    let res = a_biguint.checked_ilog_uint(base);
    match res
    {
        Some(r) => {
                println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r);
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 0_u8;
    let res = a_biguint.checked_ilog_uint(base);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 1_u8;
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let base = 6_u8;
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let base = 0_u8;
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let base = 1_u8;
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::one();
    let base = 0_u8;
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::one();
    let base = 1_u8;
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_ilog_uint()
{
    println!("biguint_unchecked_ilog_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 1_0000_0000_0000_0000_0000_0000_0000_0000_u128;
    let res = a_biguint.unchecked_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = 10_u8;
    let res = a_biguint.unchecked_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "64");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = 6_u8;
    let res = a_biguint.unchecked_ilog_uint(base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::one();
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_ilog_uint(_base);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_ilog_uint(_base);

    let _a_biguint = U256::zero();
    let _base = 6_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_ilog_uint(_base);

    let _a_biguint = U256::zero();
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_ilog_uint(_base);

    let _a_biguint = U256::zero();
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_ilog_uint(_base);

    let _a_biguint = U256::one();
    let _base = 0_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_ilog_uint(_base);

    let _a_biguint = U256::one();
    let _base = 1_u8;
    // It will panic.
    // let res = _a_biguint.unchecked_ilog_uint(_base);
    println!("---------------------------");
}


fn biguint_miscellaneous_arithmatic_operation_uint_main()
{
    biguint_midpoint_uint();
    biguint_midpoint_assign_uint();
    biguint_gcd_uint();
    biguint_gcd_assign_uint();
    biguint_panic_free_gcd_uint();
    biguint_panic_free_gcd_assign_uint();
    biguint_lcm_uint();
    biguint_lcm_assign_uint();
    biguint_panic_free_lcm_uint();
    biguint_panic_free_lcm_assign_uint();
}

fn biguint_midpoint_uint()
{
    println!("biguint_midpoint_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // normal case
    let a_biguint = U256::from_string("8888866666444442222233333444445555566666777778888899999").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.midpoint_uint(b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "4444433333222221111155555555555555555555555555555555555");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is even number
    let a_biguint = U256::from_string("66666444442222244444555556666677777888889999900000").unwrap();
    let b_biguint = 66666555554444433333222221111100000_u128;
    let c_biguint = a_biguint.midpoint_uint(b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "33333222221111155555555555555555555555555555500000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is odd number
    let a_biguint = U256::from_string("66666444442222244444555556666677777888889999900000").unwrap();
    let b_biguint = 66666555554444433333222221111100001_u128;
    let c_biguint = a_biguint.midpoint_uint(b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "33333222221111155555555555555555555555555555500000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is even number
    let a_biguint = U256::from_string("2222288888666664444422222333334444455555666667777788888").unwrap();
    let b_biguint = 66666555554444433333222221111100000_u128;
    let c_biguint = a_biguint.midpoint_uint(b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1111144444333332222244444444444444444444444444444444444");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is odd number
    let a_biguint = U256::from_string("2222288888666664444422222333334444455555666667777788888").unwrap();
    let b_biguint = 66666555554444433333222221111100001_u128;
    let c_biguint = a_biguint.midpoint_uint(b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1111144444333332222244444444444444444444444444444444444");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_midpoint_assign_uint()
{
    println!("biguint_midpoint_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // normal case
    let mut a_biguint = U256::from_string("8888866666444442222233333444445555566666777778888899999").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.midpoint_assign_uint(b_biguint);
    println!("After a_biguint.midpoint_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "4444433333222221111155555555555555555555555555555555555");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is even number
    let mut a_biguint = U256::from_string("66666444442222244444555556666677777888889999900000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 66666555554444433333222221111100000_u128;
    a_biguint.midpoint_assign_uint(b_biguint);
    println!("After a_biguint.midpoint_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "33333222221111155555555555555555555555555555500000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is odd number
    let mut a_biguint = U256::from_string("66666444442222244444555556666677777888889999900000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 66666555554444433333222221111100001_u128;
    a_biguint.midpoint_assign_uint(b_biguint);
    println!("After a_biguint.midpoint_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "33333222221111155555555555555555555555555555500000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is even number
    let mut a_biguint = U256::from_string("2222288888666664444422222333334444455555666667777788888").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 66666555554444433333222221111100000_u128;
    a_biguint.midpoint_assign_uint(b_biguint);
    println!("After a_biguint.midpoint_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1111144444333332222244444444444444444444444444444444444");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is odd number
    let mut a_biguint = U256::from_string("2222288888666664444422222333334444455555666667777788888").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 66666555554444433333222221111100001_u128;
    a_biguint.midpoint_assign_uint(b_biguint);
    println!("After a_biguint.midpoint_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1111144444333332222244444444444444444444444444444444444");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_gcd_uint()
{
    println!("biguint_gcd_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // normal case
    let a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "11111");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = 176599892424056297732340280216263039863_u128;
    let c_biguint = a_biguint.gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    let b_biguint = 256529360383586277064974026736439112491_u128;
    let c_biguint = a_biguint.gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    let b_biguint = 71263413766404235019454912736237592261_u128;
    let c_biguint = a_biguint.gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U256::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    let b_biguint = 103778310992036469625452733331446377109_u128;
    let c_biguint = a_biguint.gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "103778310992036469625452733331446377109");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = 3_u128.pow(25_u32).wrapping_mul(5_u128.pow(12_u32)).wrapping_mul(11_u128.pow(2_u32));
    let c_biguint = a_biguint.gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let _a_biguint = U256::zero();
    let _b_biguint = 103778310992036469625452733331446377109_u128;
    // It will panic!
    // let c_biguint = _a_biguint.gcd(&_b_biguint);

    let _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = 0_u128;
    // It will panic!
    // let c_biguint = _a_biguint.gcd(&_b_biguint);

    let _a_biguint = U256::zero();
    let _b_biguint = 0_u128;
    // It will panic!
    // let c_biguint = _a_biguint.gcd(&_b_biguint);
    println!("---------------------------");
}

fn biguint_gcd_assign_uint()
{
    println!("biguint_gcd_assign_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // normal case
    let mut a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.gcd_assign_uint(b_biguint);
    println!("After a_biguint.gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "11111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 176599892424056297732340280216263039863_u128;
    a_biguint.gcd_assign_uint(b_biguint);
    println!("After a_biguint.gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.gcd_assign_uint(b_biguint);
    println!("After a_biguint.gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 256529360383586277064974026736439112491_u128;
    a_biguint.gcd_assign_uint(b_biguint);
    println!("After a_biguint.gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 71263413766404235019454912736237592261_u128;
    a_biguint.gcd_assign_uint(b_biguint);
    println!("After a_biguint.gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U256::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 103778310992036469625452733331446377109_u128;
    a_biguint.gcd_assign_uint(b_biguint);
    println!("After a_biguint.gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "103778310992036469625452733331446377109");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U256::from_uint(2_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(7_u8).pow_uint(63_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = 3_u128.pow(25_u32).wrapping_mul(5_u128.pow(12_u32)).wrapping_mul(11_u128.pow(2_u32));
    a_biguint.gcd_assign_uint(b_biguint);
    println!("After a_biguint.gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let mut _a_biguint = U256::zero();
    let _b_biguint = 103778310992036469625452733331446377109_u128;
    // It will panic!
    // _a_biguint.gcd_assign_uint(_b_biguint);

    let mut _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = 0_u128;
    // It will panic!
    // _a_biguint.gcd_assign_uint(_b_biguint);

    let mut _a_biguint = U256::zero();
    let _b_biguint = 0_u128;
    // It will panic!
    // _a_biguint.gcd_assign_uint(_b_biguint);
    println!("---------------------------");
}

fn biguint_panic_free_gcd_uint()
{
    println!("biguint_panic_free_gcd_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // normal case
    let a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "11111");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = 176599892424056297732340280216263039863_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    let b_biguint = 256529360383586277064974026736439112491_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    let b_biguint = 71263413766404235019454912736237592261_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U256::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    let b_biguint = 103778310992036469625452733331446377109_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "103778310992036469625452733331446377109");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = 3_u128.pow(25_u32).wrapping_mul(5_u128.pow(12_u32)).wrapping_mul(11_u128.pow(2_u32));
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let a_biguint = U256::zero();
    let b_biguint = 103778310992036469625452733331446377109_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // non-zero and zero
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let b_biguint = 0_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and zero
    let a_biguint = U256::zero();
    let b_biguint = 0_u128;
    let c_biguint = a_biguint.panic_free_gcd_uint(b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_gcd_assign_uint()
{
    println!("biguint_panic_free_gcd_assign_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // normal case
    let mut a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "11111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 176599892424056297732340280216263039863_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 256529360383586277064974026736439112491_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 71263413766404235019454912736237592261_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U256::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 103778310992036469625452733331446377109_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "103778310992036469625452733331446377109");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U256::from_uint(2_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(7_u8).pow_uint(63_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = 3_u128.pow(25_u32).wrapping_mul(5_u128.pow(12_u32)).wrapping_mul(11_u128.pow(2_u32));
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 103778310992036469625452733331446377109_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // non-zero and zero
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 0_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 0_u128;
    a_biguint.panic_free_gcd_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_gcd_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_lcm_uint()
{
    println!("biguint_lcm_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // normal case
    let a_biguint = U256::from_string("1111122222333334444455555666667777788888").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "7777922224222246666944447444475555866662777741110777774888865555388888");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("6803131165750672834156364579962694397471399207621174936018049247058097685071").unwrap();
    let b_biguint = 176599892424056297732340280216263039863_u128;
    let c_biguint = a_biguint.lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1201432232018313536575078427518720257429815777213343847736733246472480617592688699762764735843270475023457692985273");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("44252664306827291403239758473867025040196893255067151905832712870552757072629").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "3441868973519140676288607887594334453559862957523356796877044853256166361556295667060287344153336903049997780819");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    let b_biguint = 256529360383586277064974026736439112491_u128;
    let c_biguint = a_biguint.lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "199522550818427434557973689651667058038144567865901188449215831677613012159957775002");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    let b_biguint = 71263413766404235019454912736237592261_u128;
    let c_biguint = a_biguint.lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U512::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    let b_biguint = 103778310992036469625452733331446377109_u128;
    let c_biguint = a_biguint.lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "311334932976109408876358199994339131327");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U512::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    let c_biguint = a_biguint.lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "20596479741978911975639783055646618200359178304364816695371910650463951431749917999104000000000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let _a_biguint = U256::zero();
    let _b_biguint = 103778310992036469625452733331446377109_u128;
    // It will panic!
    // let c_biguint = _a_biguint.lcm(&_b_biguint);

    let _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = 0_u128;
    // It will panic!
    // let c_biguint = _a_biguint.lcm(&_b_biguint);

    let _a_biguint = U256::zero();
    let _b_biguint = 0_u128;
    // It will panic!
    // let c_biguint = _a_biguint.lcm(&_b_biguint);
    println!("---------------------------");
}

fn biguint_lcm_assign_uint()
{
    println!("biguint_lcm_assign_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // normal case
    let mut a_biguint = U256::from_string("1111122222333334444455555666667777788888").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.lcm_assign_uint(b_biguint);
    println!("After a_biguint.lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "7777922224222246666944447444475555866662777741110777774888865555388888");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("6803131165750672834156364579962694397471399207621174936018049247058097685071").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 176599892424056297732340280216263039863_u128;
    a_biguint.lcm_assign_uint(b_biguint);
    println!("After a_biguint.lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1201432232018313536575078427518720257429815777213343847736733246472480617592688699762764735843270475023457692985273");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("44252664306827291403239758473867025040196893255067151905832712870552757072629").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.lcm_assign_uint(b_biguint);
    println!("After a_biguint.lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "3441868973519140676288607887594334453559862957523356796877044853256166361556295667060287344153336903049997780819");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 256529360383586277064974026736439112491_u128;
    a_biguint.lcm_assign_uint(b_biguint);
    println!("After a_biguint.lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "199522550818427434557973689651667058038144567865901188449215831677613012159957775002");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 71263413766404235019454912736237592261_u128;
    a_biguint.lcm_assign_uint(b_biguint);
    println!("After a_biguint.lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U512::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 103778310992036469625452733331446377109_u128;    assert_eq!(a_biguint.is_overflow(), false);
    a_biguint.lcm_assign_uint(b_biguint);
    println!("After a_biguint.lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "311334932976109408876358199994339131327");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U512::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    a_biguint.lcm_assign_uint(b_biguint);
    println!("After a_biguint.lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "20596479741978911975639783055646618200359178304364816695371910650463951431749917999104000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let mut _a_biguint = U256::zero();
    let _b_biguint = 103778310992036469625452733331446377109_u128;
    // It will panic!
    // _a_biguint.lcm_assign_uint(_b_biguint);

    let mut _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = 0_u128;
    // It will panic!
    // _a_biguint.lcm_assign_uint(_b_biguint);

    let mut _a_biguint = U256::zero();
    let _b_biguint = 0_u128;
    // It will panic!
    // _a_biguint.lcm_assign_uint(_b_biguint);
    println!("---------------------------");
}

fn biguint_panic_free_lcm_uint()
{
    println!("biguint_panic_free_lcm_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // normal case
    let a_biguint = U256::from_string("1111122222333334444455555666667777788888").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "7777922224222246666944447444475555866662777741110777774888865555388888");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("6803131165750672834156364579962694397471399207621174936018049247058097685071").unwrap();
    let b_biguint = 176599892424056297732340280216263039863_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1201432232018313536575078427518720257429815777213343847736733246472480617592688699762764735843270475023457692985273");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("44252664306827291403239758473867025040196893255067151905832712870552757072629").unwrap();
    let b_biguint = 77777666665555544444333332222211111_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "3441868973519140676288607887594334453559862957523356796877044853256166361556295667060287344153336903049997780819");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    let b_biguint = 256529360383586277064974026736439112491_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "199522550818427434557973689651667058038144567865901188449215831677613012159957775002");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    let b_biguint = 71263413766404235019454912736237592261_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U512::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    let b_biguint = 103778310992036469625452733331446377109_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "311334932976109408876358199994339131327");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U512::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "20596479741978911975639783055646618200359178304364816695371910650463951431749917999104000000000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let a_biguint = U256::zero();
    let b_biguint = 103778310992036469625452733331446377109_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // non-zero and zero
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let b_biguint = 0_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and zero
    let a_biguint = U256::zero();
    let b_biguint = 0_u128;
    let c_biguint = a_biguint.panic_free_lcm_uint(b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_lcm_assign_uint()
{
    println!("biguint_panic_free_lcm_assign_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // normal case
    let mut a_biguint = U256::from_string("1111122222333334444455555666667777788888").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "7777922224222246666944447444475555866662777741110777774888865555388888");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("6803131165750672834156364579962694397471399207621174936018049247058097685071").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 176599892424056297732340280216263039863_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1201432232018313536575078427518720257429815777213343847736733246472480617592688699762764735843270475023457692985273");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("44252664306827291403239758473867025040196893255067151905832712870552757072629").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 77777666665555544444333332222211111_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "3441868973519140676288607887594334453559862957523356796877044853256166361556295667060287344153336903049997780819");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 256529360383586277064974026736439112491_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "199522550818427434557973689651667058038144567865901188449215831677613012159957775002");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("71263413766404235019454912736237592261").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 71263413766404235019454912736237592261_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "71263413766404235019454912736237592261");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U256::from_string("311334932976109408876358199994339131327").unwrap();
    // let mut a_biguint = U512::from_string("103778310992036469625452733331446377109").unwrap().wrapping_mul_uint(3_u8);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 103778310992036469625452733331446377109_u128;    assert_eq!(a_biguint.is_overflow(), false);
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "311334932976109408876358199994339131327");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U512::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 25029766050440185546875_u128;
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "20596479741978911975639783055646618200359178304364816695371910650463951431749917999104000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 103778310992036469625452733331446377109_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    // non-zero and zero
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 0_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = 0_u128;
    a_biguint.panic_free_lcm_assign_uint(b_biguint);
    println!("After a_biguint.panic_free_lcm_assign_uint(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}


fn biguint_arithmatic_operation_biguint_main()
{
    biguint_add();
    biguint_sub();
    biguint_mul();
    biguint_div();
    biguint_rem();
    biguint_next_multiple();
}

fn biguint_add()
{
    biguint_carrying_add();
    biguint_carrying_add_assign();
    biguint_wrapping_add();
    biguint_wrapping_add_assign();
    biguint_overflowing_add();
    biguint_overflowing_add_assign();
    biguint_checked_add();
    biguint_unchecked_add();
    biguint_saturating_add();
    biguint_saturating_add_assign();
    biguint_modular_add();
    biguint_modular_add_assign();
    biguint_panic_free_modular_add();
    biguint_panic_free_modular_add_assign();
}

fn biguint_carrying_add()
{
    println!("biguint_carrying_add");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint_hi = U256::from_str_radix("1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210_1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210", 16).unwrap();
    let a_biguint_lo = U256::from_str_radix("1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531_1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531", 16).unwrap();
    let b_biguint_hi = U256::from_str_radix("EDCB_A987_6543_210F_0123_4567_89AB_CDEF_EDCB_A987_6543_210F_0123_4567_89AB_CDE1", 16).unwrap();
    let b_biguint_lo = U256::from_str_radix("FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF_FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF", 16).unwrap();

    let (c_biguint_lo, carry) = a_biguint_lo.carrying_add(&b_biguint_lo, false);
    let (c_biguint_hi, overflow) = a_biguint_hi.carrying_add(&b_biguint_hi, carry);
    println!("{}:{} + {}:{} = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("carry = {}, overflow = {}", carry, overflow);
    assert_eq!(c_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFF2");
    assert_eq!(overflow, false);
    assert_eq!(c_biguint_hi.is_overflow(), false);
    assert_eq!(c_biguint_hi.is_underflow(), false);
    assert_eq!(c_biguint_hi.is_infinity(), false);
    assert_eq!(c_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(c_biguint_hi.is_undefined(), false);
    assert_eq!(c_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), "1111_1110_1111_1111_1111_1101_1111_1111_1111_1110_1111_1111_1111_1101_1111_1110");
    assert_eq!(carry, true);
    assert_eq!(c_biguint_lo.is_overflow(), true);
    assert_eq!(c_biguint_lo.is_underflow(), false);
    assert_eq!(c_biguint_lo.is_infinity(), false);
    assert_eq!(c_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(c_biguint_hi.is_undefined(), false);

    let a_biguint_hi = U256::from_str_radix("FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF", 16).unwrap();
    let a_biguint_lo = U256::from_str_radix("FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF", 16).unwrap();
    let b_biguint_hi = U256::zero();
    let b_biguint_lo = U256::one();

    let (c_biguint_lo, carry) = a_biguint_lo.carrying_add(&b_biguint_lo, false);
    let (c_biguint_hi, overflow) = a_biguint_hi.carrying_add(&b_biguint_hi, carry);
    println!("{}:{} + {}:{} = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("carry = {}, overflow = {}", carry, overflow);
    assert_eq!(c_biguint_hi.to_string(), "0");
    assert_eq!(overflow, true);
    assert_eq!(c_biguint_hi.is_overflow(), true);
    assert_eq!(c_biguint_hi.is_underflow(), false);
    assert_eq!(c_biguint_hi.is_infinity(), false);
    assert_eq!(c_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(c_biguint_hi.is_undefined(), false);
    assert_eq!(c_biguint_lo.to_string(), "0");
    assert_eq!(carry, true);
    assert_eq!(c_biguint_lo.is_overflow(), true);
    assert_eq!(c_biguint_lo.is_underflow(), false);
    assert_eq!(c_biguint_lo.is_infinity(), false);
    assert_eq!(c_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(c_biguint_hi.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_carrying_add_assign()
{
    println!("biguint_carrying_add_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint_hi = U256::from_str_radix("1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210_1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210", 16).unwrap();
    let mut a_biguint_lo = U256::from_str_radix("1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531_1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531", 16).unwrap();
    let b_biguint_hi = U256::from_str_radix("EDCB_A987_6543_210F_0123_4567_89AB_CDEF_EDCB_A987_6543_210F_0123_4567_89AB_CDE1", 16).unwrap();
    let b_biguint_lo = U256::from_str_radix("FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF_FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF", 16).unwrap();
    println!("Originally, a_biguint_hi = {}\na_biguint_lo = {}\nb_biguint_hi = {}\nb_biguint_lo = {}", a_biguint_hi, a_biguint_lo, b_biguint_hi, b_biguint_lo);
    print!("Operation is: {}:{} + {}:{} ", a_biguint_hi, a_biguint_lo, b_biguint_hi, b_biguint_lo);

    assert_eq!(a_biguint_hi.is_overflow(), false);
    assert_eq!(a_biguint_hi.is_underflow(), false);
    assert_eq!(a_biguint_hi.is_infinity(), false);
    assert_eq!(a_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(a_biguint_hi.is_undefined(), false);

    assert_eq!(a_biguint_lo.is_overflow(), false);
    assert_eq!(a_biguint_lo.is_underflow(), false);
    assert_eq!(a_biguint_lo.is_infinity(), false);
    assert_eq!(a_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(a_biguint_lo.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);

    let carry = a_biguint_lo.carrying_add_assign(&b_biguint_lo, false);
    let overflow = a_biguint_hi.carrying_add_assign(&b_biguint_hi, carry);

    println!(" = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("carry = {}, overflow = {}", carry, overflow);
    println!("After a_biguint_lo.carrying_add_assign(&b_biguint_lo, false), a_biguint_lo = {}", a_biguint_lo);
    println!("After a_biguint_hi.carrying_add_assign(&b_biguint_hi, {}), a_biguint_hi = {}", carry, a_biguint_hi);

    assert_eq!(a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), "1111_1110_1111_1111_1111_1101_1111_1111_1111_1110_1111_1111_1111_1101_1111_1110");
    assert_eq!(carry, true);
    assert_eq!(a_biguint_lo.is_overflow(), true);
    assert_eq!(a_biguint_lo.is_underflow(), false);
    assert_eq!(a_biguint_lo.is_infinity(), false);
    assert_eq!(a_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(a_biguint_lo.is_undefined(), false);
    
    assert_eq!(a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFF2");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint_hi.is_overflow(), false);
    assert_eq!(a_biguint_hi.is_underflow(), false);
    assert_eq!(a_biguint_hi.is_infinity(), false);
    assert_eq!(a_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(a_biguint_hi.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);

    let mut a_biguint_hi = U256::from_str_radix("FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF", 16).unwrap();
    let mut a_biguint_lo = U256::from_str_radix("FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF", 16).unwrap();
    let b_biguint_hi = U256::zero();
    let b_biguint_lo = U256::one();
    println!("Originally, a_biguint_hi = {}\na_biguint_lo = {}\nb_biguint_hi = {}\nb_biguint_lo = {}", a_biguint_hi, a_biguint_lo, b_biguint_hi, b_biguint_lo);
    print!("Operation is: {}:{} + {}:{} ", a_biguint_hi, a_biguint_lo, b_biguint_hi, b_biguint_lo);

    assert_eq!(a_biguint_hi.is_overflow(), false);
    assert_eq!(a_biguint_hi.is_underflow(), false);
    assert_eq!(a_biguint_hi.is_infinity(), false);
    assert_eq!(a_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(a_biguint_hi.is_undefined(), false);

    assert_eq!(a_biguint_lo.is_overflow(), false);
    assert_eq!(a_biguint_lo.is_underflow(), false);
    assert_eq!(a_biguint_lo.is_infinity(), false);
    assert_eq!(a_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(a_biguint_lo.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);

    let carry = a_biguint_lo.carrying_add_assign(&b_biguint_lo, false);
    let overflow = a_biguint_hi.carrying_add_assign(&b_biguint_hi, carry);

    println!(" = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("carry = {}, overflow = {}", carry, overflow);
    println!("After a_biguint_lo.carrying_add_assign(&b_biguint_lo, false), a_biguint_lo = {}", a_biguint_lo);
    println!("After a_biguint_hi.carrying_add_assign(&b_biguint_hi, {}), a_biguint_hi = {}", carry, a_biguint_hi);

    assert_eq!(a_biguint_lo.to_string(), "0");
    assert_eq!(carry, true);
    assert_eq!(a_biguint_lo.is_overflow(), true);
    assert_eq!(a_biguint_lo.is_underflow(), false);
    assert_eq!(a_biguint_lo.is_infinity(), false);
    assert_eq!(a_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(a_biguint_lo.is_undefined(), false);

    assert_eq!(a_biguint_hi.to_string(), "0");
    assert_eq!(overflow, true);
    assert_eq!(a_biguint_hi.is_overflow(), true);
    assert_eq!(a_biguint_hi.is_underflow(), false);
    assert_eq!(a_biguint_hi.is_infinity(), false);
    assert_eq!(a_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(a_biguint_hi.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);

    assert_eq!(b_biguint_hi.is_overflow(), false);
    assert_eq!(b_biguint_hi.is_underflow(), false);
    assert_eq!(b_biguint_hi.is_infinity(), false);
    assert_eq!(b_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(b_biguint_hi.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_add()
{
    println!("biguint_wrapping_add");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let one_biguint = U512::one();
    let res = a_biguint.wrapping_add(&one_biguint);
    println!("{} + 1 = {}", a_biguint, res);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = U512::max();
    let one_biguint = U512::one();
    let res = b_biguint.wrapping_add(&one_biguint);
    println!("{} + {} = {}", b_biguint, one_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);

    let c_biguint = U512::zero();
    let one_biguint = U512::one();
    let res = c_biguint.wrapping_add(&one_biguint);
    println!("{} + {} = {}", c_biguint, one_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_add_assign()
{
    println!("biguint_wrapping_add_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U512::max().wrapping_sub_uint(1_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    a_biguint.wrapping_add_assign(&one_biguint);
    println!("After a_biguint.wrapping_add_assign(&U512::one()), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint, U512::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    a_biguint.wrapping_add_assign(&one_biguint);
    println!("After a_biguint.wrapping_add_assign(&U512::one()), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_add_assign(&one_biguint);
    println!("After a_biguint.wrapping_add_assign(&U512::one()),\ta_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_add()
{
    println!("biguint_overflowing_add");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let one_biguint = U512::one();
    let (res, overflow) = a_biguint.overflowing_add(&one_biguint);
    println!("{} + {} = {}, overflow = {}", a_biguint, one_biguint, res, overflow);
    assert_eq!(overflow, false);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = U512::max();
    let one_biguint = U512::one();
    let (res, overflow) = b_biguint.overflowing_add(&one_biguint);
    println!("{} + {} = {}, overflow = {}", b_biguint, one_biguint, res, overflow);
    assert_eq!(overflow, true);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);

    let c_biguint = U512::max();
    let two_biguint = U512::from_uint(2_u8);
    let (res, overflow) = c_biguint.overflowing_add(&two_biguint);
    println!("{} + {} = {}, overflow = {}", c_biguint, two_biguint, res, overflow);
    assert_eq!(overflow, true);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_add_assign()
{
    println!("biguint_overflowing_add_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U512::max().wrapping_sub_uint(1_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    let overflow = a_biguint.overflowing_add_assign(&one_biguint);
    println!("After a_biguint.overflowing_add_assign(&U512::one()), a_biguint = {}, overflow = {}", a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint, U512::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    let overflow = a_biguint.overflowing_add_assign(&one_biguint);
    println!("After a_biguint.overflowing_add_assign(&U512::one()),\ta_biguint = {}, overflow = {}", a_biguint, overflow);
    assert_eq!(overflow, true);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let overflow = a_biguint.overflowing_add_assign(&one_biguint);
    println!("After a_biguint.overflowing_add_assign(&U512::one()),\ta_biguint = {}, overflow = {}", a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_checked_add()
{
    println!("biguint_checked_add");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let one_biguint = U512::one();
    let res = a_biguint.checked_add(&one_biguint);
    match res
    {
        Some(r) => {
                println!("{} + {} = {}, overflow = {}", a_biguint, one_biguint, r, r.is_overflow());
                assert_eq!(r, U512::max());
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_undefined(), false);
            },
        None => { println!("Error: Overflow"); },
    }

    let b_biguint = U512::max();
    let one_biguint = U512::one();
    let res = b_biguint.checked_add(&one_biguint);
    match res
    {
        Some(r) => { println!("{} + {} = {}, overflow = {}", b_biguint, one_biguint, r, r.is_overflow()); },
        None => { 
                println!("Error: Overflow");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_add()
{
    println!("biguint_unchecked_add()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let one_biguint = U512::one();
    let res = a_biguint.unchecked_add(&one_biguint);
    println!("{} + {} = {}, overflow = {}", a_biguint, one_biguint, res, res.is_overflow());
    assert_eq!(res, U512::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);

    let _b_biguint = U512::max();
    let _one_biguint = U512::one();
    // It will panic.
    // let res = _b_biguint.unchecked_add(&_one_biguint);
    println!("---------------------------");
}

fn biguint_saturating_add()
{
    println!("biguint_saturating_add");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U512::max().wrapping_sub_uint(1_u8);
    let one_biguint = U512::one();
    let res = a_biguint.saturating_add(&one_biguint);
    println!("{} + {} = {}", a_biguint, one_biguint, res);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = U512::max();
    let one_biguint = U512::one();
    let res: cryptocol::number::BigUInt<u64, 8> = b_biguint.saturating_add(&one_biguint);
    println!("{} + {} = {}", b_biguint, one_biguint, res);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_saturating_add_assign()
{
    println!("biguint_saturating_add_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U512::max().wrapping_sub_uint(1_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    a_biguint.saturating_add_assign(&one_biguint);
    println!("After a_biguint.saturating_add_assign(&U512::one()), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint, U512::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut b_biguint = U512::max();
    println!("Originally, b_biguint = {}", b_biguint);
    assert_eq!(b_biguint.is_overflow(), false);
    assert_eq!(b_biguint.is_underflow(), false);
    assert_eq!(b_biguint.is_infinity(), false);
    assert_eq!(b_biguint.is_divided_by_zero(), false);
    assert_eq!(b_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    b_biguint.saturating_add_assign(&one_biguint);
    println!("After a_biguint.saturating_add_assign(&U512::one()), b_biguint = {}", b_biguint);
    assert_eq!(b_biguint, U512::max());
    assert_eq!(b_biguint.is_overflow(), false);
    assert_eq!(b_biguint.is_underflow(), false);
    assert_eq!(b_biguint.is_infinity(), false);
    assert_eq!(b_biguint.is_divided_by_zero(), false);
    assert_eq!(b_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_modular_add()
{
    println!("biguint_modular_add");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8); // == 76801874298166903427690031858186486050853753882811946569946433649008
    let one = U256::one();
    let res = a_biguint.modular_add(&one, &m);
    println!("{} + {} = {}", a_biguint, one, res);
    assert_eq!(res.to_string(), "76801874298166903427690031858186486050853753882811946569946433649007");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8); // == 76801874298166903427690031858186486050853753882811946569946433649008
    let two = U256::from_uint(2_u8);
    let res = a_biguint.modular_add(&two, &m);
    println!("{} + {} = {}", a_biguint, two, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 3
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8); // == 76801874298166903427690031858186486050853753882811946569946433649008
    let three = U256::from_uint(3_u8);
    let res = a_biguint.modular_add(&three, &m);
    println!("{} + {} = {}", a_biguint, three, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == Self::max()
    let a_biguint = U256::max().wrapping_sub_uint(2_u8);
    let m = U256::max();
    let three = U256::from_uint(3_u8);
    let res = a_biguint.modular_add(&three, &m);
    println!("{} + {} = {}", a_biguint, three, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    //  op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    let res = a_biguint.modular_add(&three, &m);
    println!("{} + {} = {}(mod {})", a_biguint, three, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    let res = a_biguint.modular_add(&three, &m);
    println!("{} + {} = {}(mod {})", a_biguint, three, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    let res = a_biguint.modular_add(&zero, &m);
    println!("{} + {} = {}(mod {})", a_biguint, zero, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    let res = a_biguint.modular_add(&multiple_of_modulo, &m);
    println!("{} + {} = {}(mod {})", a_biguint, multiple_of_modulo, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    let res = a_biguint.modular_add(&zero, &m);
    println!("{} + {} = {}(mod {})", a_biguint, zero, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    let res = a_biguint.modular_add(&zero, &m);
    println!("{} + {} = {}(mod {})", a_biguint, zero, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    let res = a_biguint.modular_add(&multiple_of_modulo, &m);
    println!("{} + {} = {}(mod {})", a_biguint, multiple_of_modulo, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    let res = a_biguint.modular_add(&multiple_of_modulo, &m);
    println!("{} + {} = {}(mod {})", a_biguint, multiple_of_modulo, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Panic Examples
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::zero();
    let _rhs = U256::from_uint(3_u8);
    // It will panic.
    // let res = _a_biguint.modular_add(&_rhs, &_m);
    
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::one();
    let _rhs = U256::from_uint(3_u8);
    // It will panic.
    // let res = _a_biguint.modular_add(&_rhs, &_m);
    println!("---------------------------");
}

fn biguint_modular_add_assign()
{
    println!("biguint_modular_add_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    println!("Originally, a = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8); // == 768018742981669034276900318581864860508537538828119465699464336490062
    let one = U256::one();
    a_biguint.modular_add_assign(&one, &m);
    println!("After a_biguint.modular_add_assign_uint(&U256::one(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490061");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    println!("Originally, b_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8); // == 768018742981669034276900318581864860508537538828119465699464336490062
    let two = U256::from_uint(2_u8);
    a_biguint.modular_add_assign(&two, &m);
    println!("After a_biguint.modular_add_assign(&U256::from_uint(2_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();    
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8); // == 768018742981669034276900318581864860508537538828119465699464336490062
    let three = U256::from_uint(3_u8);
    a_biguint.modular_add_assign(&three, &m);
    println!("After a_biguint.modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.modular_add_assign(&three, &m);
    println!("After a_biguint.modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == Self::max()
    let mut a_biguint = U256::max().wrapping_sub_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::max();
    let three = U256::from_uint(3_u8);
    a_biguint.modular_add_assign(&three, &m);
    println!("After a_biguint.modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    a_biguint.modular_add_assign(&three, &m);
    println!("After a.modular_add_assign(U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    a_biguint.modular_add_assign(&three, &m);
    println!("After a.modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    a_biguint.modular_add_assign(&zero, &m);
    println!("After a.modular_add_assign(&U256::zero(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    a_biguint.modular_add_assign(&multiple_of_modulo, &m);
    println!("After a.modular_add_assign(& U256::from_uint(250_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    a_biguint.modular_add_assign(&zero, &m);
    println!("After a.modular_add_assign(&U256::zero(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    a_biguint.modular_add_assign(&zero, &m);
    println!("After a.modular_add_assign(&U256::zero(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    a_biguint.modular_add_assign(&multiple_of_modulo, &m);
    println!("After a.modular_add_assign(&U256::from_uint(250_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // Panic Examples
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::zero();
    let _rhs = U256::one();
    // It will panic.
    // _a_biguint.modular_add_assign(&_rhs, &_m);
    
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::one();
    let _rhs = U256::one();
    // It will panic.
    // _a_biguint.modular_add_assign_uint(&_rhs, &_m);
    println!("---------------------------");
}

fn biguint_panic_free_modular_add()
{
    println!("biguint_panic_free_modular_add");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8); // == 76801874298166903427690031858186486050853753882811946569946433649008
    let one = U256::one();
    let res = a_biguint.panic_free_modular_add(&one, &m);
    println!("{} + {} = {}", a_biguint, one, res);
    assert_eq!(res.to_string(), "76801874298166903427690031858186486050853753882811946569946433649007");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8); // == 76801874298166903427690031858186486050853753882811946569946433649008
    let two = U256::from_uint(2_u8);
    let res = a_biguint.panic_free_modular_add(&two, &m);
    println!("{} + {} = {}", a_biguint, two, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 3
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = a_biguint.wrapping_add_uint(2_u8); // == 76801874298166903427690031858186486050853753882811946569946433649008
    let three = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_add(&three, &m);
    println!("{} + {} = {}", a_biguint, three, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == Self::max()
    let a_biguint = U256::max().wrapping_sub_uint(2_u8);
    let m = U256::max();
    let three = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_add(&three, &m);
    println!("{} + {} = {}", a_biguint, three, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    //  op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_add(&three, &m);
    println!("{} + {} = {}(mod {})", a_biguint, three, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_add(&three, &m);
    println!("{} + {} = {}(mod {})", a_biguint, three, res, m);
    assert_eq!(res.to_string(), "3");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    let res = a_biguint.panic_free_modular_add(&zero, &m);
    println!("{} + {} = {}(mod {})", a_biguint, zero, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    let res = a_biguint.panic_free_modular_add(&multiple_of_modulo, &m);
    println!("{} + {} = {}(mod {})", a_biguint, multiple_of_modulo, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    let res = a_biguint.panic_free_modular_add(&zero, &m);
    println!("{} + {} = {}(mod {})", a_biguint, zero, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    let res = a_biguint.panic_free_modular_add(&zero, &m);
    println!("{} + {} = {}(mod {})", a_biguint, zero, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    let res = a_biguint.panic_free_modular_add(&multiple_of_modulo, &m);
    println!("{} + {} = {}(mod {})", a_biguint, multiple_of_modulo, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    let res = a_biguint.panic_free_modular_add(&multiple_of_modulo, &m);
    println!("{} + {} = {}(mod {})", a_biguint, multiple_of_modulo, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo = 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::zero();
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_add(&rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // modulo = 1
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::one();
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_add(&rhs, &m);
    println!("{} + {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // Collective Example for modulo == 0 or 1
    for a_biguint in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [U256::zero(), U256::from_uint(3_u8), U256::from_uint(50_u8)]
        {
            for m in [U256::zero(), U256::one()]
            {
                let res = a_biguint.panic_free_modular_add(&rhs, &m);
                println!("{} + {} = {} (mod {})", a_biguint, rhs, res, m);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_add_assign()
{
    println!("biguint_panic_free_modular_add_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    println!("Originally, a = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8); // == 768018742981669034276900318581864860508537538828119465699464336490062
    let one = U256::one();
    a_biguint.panic_free_modular_add_assign(&one, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::one(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "768018742981669034276900318581864860508537538828119465699464336490061");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();
    println!("Originally, b_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8); // == 768018742981669034276900318581864860508537538828119465699464336490062
    let two = U256::from_uint(2_u8);
    a_biguint.panic_free_modular_add_assign(&two, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::from_uint(2_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = U256::from_string("768018742981669034276900318581864860508537538828119465699464336490060").unwrap();    
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = a_biguint.wrapping_add_uint(2_u8); // == 768018742981669034276900318581864860508537538828119465699464336490062
    let three = U256::from_uint(3_u8);
    a_biguint.panic_free_modular_add_assign(&three, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_modular_add_assign(&three, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == Self::max()
    let mut a_biguint = U256::max().wrapping_sub_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::max();
    let three = U256::from_uint(3_u8);
    a_biguint.panic_free_modular_add_assign(&three, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    a_biguint.panic_free_modular_add_assign(&three, &m);
    println!("After a_biguint.panic_free_modular_add_assign(U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let three = U256::from_uint(3_u8);
    a_biguint.panic_free_modular_add_assign(&three, &m);
    println!("After a_biguinta.panic_free_modular_add_assign(&U256::from_uint(3_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    a_biguint.panic_free_modular_add_assign(&zero, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::zero(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    a_biguint.panic_free_modular_add_assign(&multiple_of_modulo, &m);
    println!("After a_biguint.panic_free_modular_add_assign(& U256::from_uint(250_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    a_biguint.panic_free_modular_add_assign(&zero, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::zero(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let zero = U256::zero();
    a_biguint.panic_free_modular_add_assign(&zero, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::zero(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    println!("Originally, a = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let multiple_of_modulo = U256::from_uint(250_u8);
    a_biguint.panic_free_modular_add_assign(&multiple_of_modulo, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::from_uint(250_u8), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // modulo == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::zero();
    let rhs = U256::one();
    a_biguint.panic_free_modular_add_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::one(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // modulo == 1
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = U256::one();
    let rhs = U256::one();
    a_biguint.panic_free_modular_add_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_add_assign(&U256::one(), &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // Collective Example for modulo == 0 or 1
    for a in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [U256::zero(), U256::from_uint(3_u8), U256::from_uint(50_u8)]
        {
            for m in [U256::zero(), U256::one()]
            {
                let mut a_biguint = a.clone();
                println!("Originally, a = {}", a_biguint);
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), false);
            
                a_biguint.panic_free_modular_add_assign(&rhs, &m);
                println!("After a_biguint.panic_free_modular_add_assign_uint({}, &{}), a_biguint = {}", rhs, a_biguint, m);
                assert_eq!(a_biguint.to_string(), "0");
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_sub()
{
    biguint_borrowing_sub();
    biguint_borrowing_sub_assign();
    biguint_wrapping_sub();
    biguint_wrapping_sub_assign();
    biguint_overflowing_sub();
    biguint_overflowing_sub_assign();
    biguint_checked_sub();
    biguint_unchecked_sub();
    biguint_saturating_sub();
    biguint_saturating_sub_assign();
    biguint_modular_sub();
    biguint_modular_sub_assign();
    biguint_panic_free_modular_sub();
    biguint_panic_free_modular_sub_assign();
    biguint_abs_diff();
}

fn biguint_borrowing_sub()
{
    println!("biguint_borrowing_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint_hi = U256::from_str_radix("FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFF2", 16).unwrap();
    let a_biguint_lo = U256::from_str_radix("1111_1110_1111_1111_1111_1101_1111_1111_1111_1110_1111_1111_1111_1101_1111_1110", 16).unwrap();
    let b_biguint_hi = U256::from_str_radix("EDCB_A987_6543_210F_0123_4567_89AB_CDEF_EDCB_A987_6543_210F_0123_4567_89AB_CDE1", 16).unwrap();
    let b_biguint_lo = U256::from_str_radix("FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF_FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF", 16).unwrap();

    let (c_biguint_lo, borrow) = a_biguint_lo.borrowing_sub(&b_biguint_lo, false);
    let (c_biguint_hi, unerflow) = a_biguint_hi.borrowing_sub(&b_biguint_hi, borrow);

    println!("{}:{} - {}:{} = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("borrow = {}, overflow = {}", borrow, unerflow);
    assert_eq!(c_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), "1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210_1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210");
    assert_eq!(c_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), "1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531_1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531");
    assert_eq!(borrow, true);
    assert_eq!(c_biguint_lo.is_underflow(), true);
    assert_eq!(c_biguint_lo.is_overflow(), false);
    assert_eq!(c_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(c_biguint_lo.is_infinity(), false);
    assert_eq!(c_biguint_lo.is_undefined(), false);
    assert_eq!(unerflow, false);
    assert_eq!(c_biguint_hi.is_underflow(), false);
    assert_eq!(c_biguint_hi.is_overflow(), false);
    assert_eq!(c_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(c_biguint_hi.is_infinity(), false);
    assert_eq!(c_biguint_hi.is_undefined(), false);

    let a_biguint_hi = U256::zero();
    let a_biguint_lo = U256::zero();
    let b_biguint_hi = U256::zero();
    let b_biguint_lo = U256::one();

    let (c_biguint_lo, borrow) = a_biguint_lo.borrowing_sub(&b_biguint_lo, false);
    let (c_biguint_hi, underflow) = a_biguint_hi.borrowing_sub(&b_biguint_hi, borrow);

    println!("{}:{} - {}:{} = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), c_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("borrow = {}, underflow = {}", borrow, underflow);

    assert_eq!(c_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF");
    assert_eq!(c_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF");
    assert_eq!(borrow, true);
    assert_eq!(c_biguint_lo.is_underflow(), true);
    assert_eq!(c_biguint_lo.is_overflow(), false);
    assert_eq!(c_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(c_biguint_lo.is_infinity(), false);
    assert_eq!(c_biguint_lo.is_undefined(), false);
    assert_eq!(underflow, true);
    assert_eq!(c_biguint_hi.is_underflow(), true);
    assert_eq!(c_biguint_hi.is_overflow(), false);
    assert_eq!(c_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(c_biguint_hi.is_infinity(), false);
    assert_eq!(c_biguint_hi.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_borrowing_sub_assign()
{
    println!("biguint_borrowing_sub_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint_hi = U256::from_str_radix("FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFF2", 16).unwrap();
    let mut a_biguint_lo = U256::from_str_radix("1111_1110_1111_1111_1111_1101_1111_1111_1111_1110_1111_1111_1111_1101_1111_1110", 16).unwrap();
    let b_biguint_hi = U256::from_str_radix("EDCB_A987_6543_210F_0123_4567_89AB_CDEF_EDCB_A987_6543_210F_0123_4567_89AB_CDE1", 16).unwrap();
    let b_biguint_lo = U256::from_str_radix("FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF_FDB9_7531_0ECA_8642_2468_ACE0_1357_9BDF", 16).unwrap();

    print!("{}:{} - {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    let borrow = a_biguint_lo.borrowing_sub_assign(&b_biguint_lo, false);
    let underflow = a_biguint_hi.borrowing_sub_assign(&b_biguint_hi, borrow);
    println!(" = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("borrow = {}, underflow = {}", borrow, underflow);

    assert_eq!(a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), "1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210_1234_5678_9ABC_DEF0_FEDC_BA98_7654_3210");
    assert_eq!(a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), "1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531_1357_9BDF_0246_8ACE_ECA8_6420_FDB9_7531");
    assert_eq!(borrow, true);
    assert_eq!(a_biguint_lo.is_underflow(), true);
    assert_eq!(a_biguint_lo.is_overflow(), false);
    assert_eq!(a_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(a_biguint_lo.is_infinity(), false);
    assert_eq!(a_biguint_lo.is_undefined(), false);
    assert_eq!(underflow, false);
    assert_eq!(a_biguint_hi.is_underflow(), false);
    assert_eq!(a_biguint_hi.is_overflow(), false);
    assert_eq!(a_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(a_biguint_hi.is_infinity(), false);
    assert_eq!(a_biguint_hi.is_undefined(), false);

    let mut a_biguint_hi = U256::zero();
    let mut a_biguint_lo = U256::zero();
    let b_biguint_hi = U256::zero();
    let b_biguint_lo = U256::one();

    print!("{}:{} - {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    let borrow = a_biguint_lo.borrowing_sub_assign(&b_biguint_lo, false);
    let underflow = a_biguint_hi.borrowing_sub_assign(&b_biguint_hi, borrow);
    println!(" = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("borrow = {}, underflow = {}", borrow, underflow);

    assert_eq!(a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF");
    assert_eq!(a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF");
    assert_eq!(borrow, true);
    assert_eq!(a_biguint_lo.is_underflow(), true);
    assert_eq!(a_biguint_lo.is_overflow(), false);
    assert_eq!(a_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(a_biguint_lo.is_infinity(), false);
    assert_eq!(a_biguint_lo.is_undefined(), false);
    assert_eq!(underflow, true);
    assert_eq!(a_biguint_hi.is_underflow(), true);
    assert_eq!(a_biguint_hi.is_overflow(), false);
    assert_eq!(a_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(a_biguint_hi.is_infinity(), false);
    assert_eq!(a_biguint_hi.is_undefined(), false);

    print!("{}:{} - {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), b_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    let borrow = a_biguint_lo.borrowing_sub_assign(&b_biguint_lo, false);
    let underflow = a_biguint_hi.borrowing_sub_assign(&b_biguint_hi, borrow);
    println!(" = {}:{}", a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap());
    println!("borrow = {}, underflow = {}", borrow, underflow);

    assert_eq!(a_biguint_hi.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF");
    assert_eq!(a_biguint_lo.to_string_with_radix_and_stride(16, 4).unwrap(), "FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFE");
    assert_eq!(borrow, false);
    assert_eq!(a_biguint_lo.is_underflow(), true);
    assert_eq!(a_biguint_lo.is_overflow(), false);
    assert_eq!(a_biguint_lo.is_divided_by_zero(), false);
    assert_eq!(a_biguint_lo.is_infinity(), false);
    assert_eq!(a_biguint_lo.is_undefined(), false);
    assert_eq!(underflow, false);
    assert_eq!(a_biguint_hi.is_underflow(), true);
    assert_eq!(a_biguint_hi.is_overflow(), false);
    assert_eq!(a_biguint_hi.is_divided_by_zero(), false);
    assert_eq!(a_biguint_hi.is_infinity(), false);
    assert_eq!(a_biguint_hi.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_sub()
{
    println!("biguint_wrapping_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U512::one();
    let res = a_biguint.wrapping_sub(&U512::one());
    println!("{} - 1 = {}", a_biguint, res);
    assert_eq!(res, U512::zero());
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = U512::zero();
    let res = b_biguint.wrapping_sub(&U512::one());
    println!("{} - 1 = {}", b_biguint, res);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let c_biguint = U512::max();
    let res = c_biguint.wrapping_sub(&U512::one());
    println!("{} - 1 = {}", c_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_sub_assign()
{
    println!("biguint_wrapping_sub_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_sub_assign(&U512::one());
    println!("After a_biguint.wrapping_sub_assign(&U512::one()), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_sub_assign(&U512::one());
    println!("After a_biguint.wrapping_sub_assign(&U512::one()), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_sub_assign(&U512::one());
    println!("After a_biguint.wrapping_sub_assign(&U512::one()),\ta_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_sub()
{
    println!("biguint_overflowing_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U512::one();
    let (res, underflow) = a_biguint.overflowing_sub(&U512::one());
    println!("{} - 1 = {}, underflow = {}", a_biguint, res, underflow);
    assert_eq!(underflow, false);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = U512::zero();
    let (res, underflow) = b_biguint.overflowing_sub(&U512::one());
    println!("{} - 1 = {}, underflow = {}", b_biguint, res, underflow);
    assert_eq!(underflow, true);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_sub_assign()
{
    println!("biguint_overflowing_sub_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let underflow = a_biguint.overflowing_sub_assign(&U512::one());
    println!("After a_biguint.overflowing_sub_assign(&U512::one()), a_biguint = {}, underflow = {}", a_biguint, underflow);
    assert_eq!(underflow, false);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut b_biguint = U512::zero();
    println!("Originally, b_biguint = {}", b_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let underflow = b_biguint.overflowing_sub_assign(&U512::one());
    println!("After b_biguint.overflowing_sub_assign(&U512::one()),\tb_biguint = {}, underflow = {}", b_biguint, underflow);
    assert_eq!(underflow, true);
    assert_eq!(b_biguint, U512::max());
    assert_eq!(b_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_checked_sub()
{
    println!("biguint_checked_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U512::one();
    let res = a_biguint.checked_sub(&U512::one());
    match res
    {
        Some(r) => {
                println!("{} - 1 = {}, underflow = {}", a_biguint, r, r.is_underflow());
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
            },
        None => { println!("Error: Underflow"); },
    }

    let b_biguint = U512::max();
    let res = b_biguint.checked_add(&U512::one());
    match res
    {
        Some(r) => { println!("{} - 1 = {}, underflow = {}", b_biguint, r, r.is_underflow()); },
        None => { 
                println!("Error: Underflow");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_sub()
{
    println!("biguint_unchecked_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U512::one();
    let res = a_biguint.unchecked_sub(&U512::one());
    println!("{} - 1 = {}, underflow = {}", a_biguint, res, res.is_underflow());
    assert_eq!(res, U512::zero());
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let _b_biguint = U512::zero();
    // It will panic.
    // let res = _b_biguint.unchecked_sub(&U512::one());
    println!("---------------------------");
}

fn biguint_saturating_sub()
{
    println!("biguint_saturating_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U512::one();
    let one = U512::one();
    let res = a_biguint.saturating_sub(&one);
    println!("{} - {} = {}", a_biguint, one, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = U512::zero();
    let one = U512::one();
    let res = b_biguint.saturating_sub(&one);
    println!("{} - {} = {}", b_biguint, one, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let c_biguint = U512::from_uint(5_u8);
    let ten = U512::from_uint(10_u8);
    let res = c_biguint.saturating_sub(&ten);
    println!("{} - {} = {}", c_biguint, ten, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_saturating_sub_assign()
{
    println!("biguint_saturating_sub_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one = U512::one();
    a_biguint.saturating_sub_assign(&one);
    println!("After a_biguint.saturating_sub_assign(&U512::one()), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::zero();
    println!("Originally, b_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one = U512::one();
    a_biguint.saturating_sub_assign(&one);
    println!("After b_biguint.saturating_sub_assign(&U512::one()), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::from_uint(5_u8);
    println!("Originally, b_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let ten = U512::from_uint(10_u8);
    a_biguint.saturating_sub_assign(&ten);
    println!("After b_biguint.saturating_sub_assign(&U512::from_uint(10_u8)), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_modular_sub()
{
    println!("biguint_modular_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal Case 1
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("10000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    let one = U256::one();
    let res = a_biguint.modular_sub(&one, &m);
    println!("{} - {} = {} (mod {})", a_biguint, one, res, m);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal Case 2
    let a_biguint = U256::one();
    let m = U256::from_string("10000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    let one = U256::one();
    let res = a_biguint.modular_sub(&one, &m);
    println!("{} - {} = {} (mod {})", a_biguint, one, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal Case 3
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("10000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    let three = U256::from_uint(4_u8);
    let res = a_biguint.modular_sub(&three, &m);
    println!("{} - {} = {} (mod {})", a_biguint, one, res, m);
    assert_eq!(res.to_string(), "9999999999999999999999999999999999999999999999999999999999999999998");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == Self::max()
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::max();
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res, U256::max().wrapping_sub_uint(1_u8));
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    let res = a_biguint.modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // Pacnic Examples
    let _a_biguint = U256::from_uint(2_u8);
    let _m = U256::zero();
    let _rhs = U256::from_uint(3_u8);
    // It will panic.
    // let res = _a_biguint.modular_sub(&_rhs, &_m);
    
    let _a_biguint = U256::from_uint(2_u8);
    let _m = U256::one();
    let _rhs = U256::from_uint(3_u8);
    // It will panic.
    // let res = _a_biguint.modular_sub(&_rhs, &_m);
    println!("---------------------------");
}

fn biguint_modular_sub_assign()
{
    println!("biguint_modular_sub_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = UU32::one();
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // Normal case 2
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
       
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = UU32::from_uint(2_u8);
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
       
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = UU32::from_uint(3_u8);
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084090");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // modulo == Self::max()
    let mut a_biguint = U256::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::max();
    let rhs = U256::from_uint(3_u8);
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint, U256::max().wrapping_sub_uint(1_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    a_biguint.modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign_uint({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // Panic Examples
    let _a_biguint = U256::from_uint(2_u8);
    let _m = U256::zero();
    let _rhs = U256::one();
    // It will panic.
    // _a_biguint.modular_sub_assign(&_rhs, &m);
    
    let _a_biguint = U256::from_uint(2_u8);
    let _m = U256::one();
    let _rhs = U256::one();
    // It will panic.
    // _a_biguint.modular_sub_assign(&_rhs, &m);
    println!("---------------------------");
}

fn biguint_panic_free_modular_sub()
{
    println!("biguint_panic_free_modular_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal Case 1
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("10000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    let one = U256::one();
    let res = a_biguint.panic_free_modular_sub(&one, &m);
    println!("{} - {} = {} (mod {})", a_biguint, one, res, m);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal Case 2
    let a_biguint = U256::one();
    let m = U256::from_string("10000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    let one = U256::one();
    let res = a_biguint.panic_free_modular_sub(&one, &m);
    println!("{} - {} = {} (mod {})", a_biguint, one, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal Case 3
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::from_string("10000000000000000000000000000000000000000000000000000000000000000000").unwrap();
    let three = U256::from_uint(4_u8);
    let res = a_biguint.panic_free_modular_sub(&three, &m);
    println!("{} - {} = {} (mod {})", a_biguint, three, res, m);
    assert_eq!(res.to_string(), "9999999999999999999999999999999999999999999999999999999999999999998");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == Self::max()
    let a_biguint = U256::from_uint(2_u8);
    let m = U256::max();
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res, U256::max().wrapping_sub_uint(1_u8));
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "247");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == multiple of modulo
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == 0
    let a_biguint = U256::zero();
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {}(mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let a_biguint = U256::from_uint(750_u16);
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0 and op2 == multiple of modulo
    let a_biguint = U256::zero();
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let a_biguint = U256::from_uint(150_u8);
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == 0
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::zero();
    let rhs = U256::from_uint(50_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // modulo == 1
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let m = U256::one();
    let rhs = U256::from_uint(50_u8);
    let res = a_biguint.panic_free_modular_sub(&rhs, &m);
    println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // Collective Examples for modulo == 0 or 1
    for a_biguint in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [U256::zero(), U256::from_uint(3_u8), U256::from_uint(50_u8)]
        {
            for m in [U256::zero(), U256::one()]
            {
                let res = a_biguint.panic_free_modular_sub(&rhs, &m);
                println!("{} - {} = {} (mod {})", a_biguint, rhs, res, m);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_sub_assign()
{
    println!("biguint_panic_free_modular_sub_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = UU32::one();
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // Normal case 2
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
       
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = UU32::from_uint(2_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 3
    let mut a_biguint = UU32::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
       
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let rhs = UU32::from_uint(3_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084093");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "76801874298166903427690031858186486050853753882811946569946433649006084090");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // modulo == Self::max()
    let mut a_biguint = U256::from_uint(2_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::max();
    let rhs = U256::from_uint(3_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint, U256::max().wrapping_sub_uint(1_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::from_uint(3_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "247");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(250_u8);
    let rhs = U256::zero();
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(150_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::from_uint(50_u8);
    let rhs = U256::from_uint(250_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // modulo == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::zero();
    let rhs = U256::from_uint(250_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    
    // modulo == 1
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let m = U256::one();
    let rhs = U256::from_uint(250_u8);
    a_biguint.panic_free_modular_sub_assign(&rhs, &m);
    println!("After a_biguint.panic_free_modular_sub_assign({}, &m), a_biguint = {}", rhs, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    
    // Collective Examples for modulo == 0 or 1
    for a in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [U256::zero(), U256::from_uint(3_u8), U256::from_uint(50_u8)]
        {
            for m in [U256::zero(), U256::one()]
            {
                let mut a_biguint = a.clone();
                println!("Originally, a = {}", a_biguint);
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), false);
            
                a_biguint.panic_free_modular_sub_assign(&rhs, &m);
                println!("After a_biguint.panic_free_modular_sub_assign_uint({}, &{}), a_biguint = {}", rhs, a_biguint, m);
                assert_eq!(a_biguint.to_string(), "0");
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_abs_diff()
{
    println!("biguint_abs_diff");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    
    let a = U256::from_str("500000000000000000500000000500000000500000000500000000").unwrap();
    let b = U256::from_str("500000000000000000000000000000000000000000000000000000").unwrap();
    let c = a.abs_diff(&b);
    let d = b.abs_diff(&a);
    println!("500000000000000000500000000500000000500000000500000000 <-> 500000000000000000000000000000000000000000000000000000 = {}", c);
    println!("500000000000000000000000000000000000000000000000000000 <-> 500000000000000000500000000500000000500000000500000000 = {}", d);
    assert_eq!(c, U256::from_str("500000000500000000500000000500000000").unwrap());
    assert_eq!(c.is_overflow(), false);
    assert_eq!(c.is_underflow(), false);
    assert_eq!(c.is_divided_by_zero(), false);
    assert_eq!(c.is_infinity(), false);
    assert_eq!(c.is_undefined(), false);
    assert_eq!(d, U256::from_str("500000000500000000500000000500000000").unwrap());
    assert_eq!(d.is_overflow(), false);
    assert_eq!(d.is_underflow(), false);
    assert_eq!(d.is_divided_by_zero(), false);
    assert_eq!(d.is_infinity(), false);
    assert_eq!(d.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_mul()
{
    biguint_carrying_mul();
    biguint_carrying_mul_assign();
    biguint_widening_mul();
    biguint_widening_mul_assign();
    biguint_wrapping_mul();
    biguint_wrapping_mul_assign();
    biguint_overflowing_mul();
    biguint_overflowing_mul_assign();
    biguint_checked_mul();
    biguint_unchecked_mul();
    biguint_saturating_mul();
    biguint_saturating_mul_assign();
    biguint_modular_mul();
    biguint_modular_mul_assign();
    biguint_panic_free_modular_mul();
    biguint_panic_free_modular_mul_assign();
}

fn biguint_carrying_mul()
{
    println!("biguint_carrying_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let a_biguint_low = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_biguint_high = U256::from_string("75388281194656994643364900608409476801874298166903427690031858186486050853").unwrap();
    let b_biguint = UU32::from_string("16962363268797823794757102636892132280421717087553271230257168091959361441925").unwrap();
    let (res_biguint_low, res_biguint_high) = a_biguint_low.carrying_mul(&b_biguint, UU32::zero());
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);
    let (res_biguint_high, res_biguint_higher) = a_biguint_high.carrying_mul(&b_biguint, res_biguint_high);

    println!("{}:{} X {} = {}:{}:{}", a_biguint_high, a_biguint_low, b_biguint, res_biguint_higher, res_biguint_high, res_biguint_low);
    assert_eq!(res_biguint_higher.to_string(), "11043616366686523019040587905143508095308019572635527295298701528708842829");
    assert_eq!(res_biguint_higher.is_overflow(), false);
    assert_eq!(res_biguint_higher.is_underflow(), false);
    assert_eq!(res_biguint_higher.is_divided_by_zero(), false);
    assert_eq!(res_biguint_higher.is_infinity(), false);
    assert_eq!(res_biguint_higher.is_undefined(), false);

    assert_eq!(res_biguint_high.to_string(), "47612192950075281462365720785702517256274202447286280420710978194126658529299");
    assert_eq!(res_biguint_high.is_overflow(), true);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);

    assert_eq!(res_biguint_low.to_string(), "99569105317044689054574557712853522297141576321520100863242044268764373638902");
    assert_eq!(res_biguint_low.is_overflow(), true);
    assert_eq!(res_biguint_low.is_underflow(), false);
    assert_eq!(res_biguint_low.is_divided_by_zero(), false);
    assert_eq!(res_biguint_low.is_infinity(), false);
    assert_eq!(res_biguint_low.is_undefined(), false);

    // Maximum case
    let a_biguint_low = U256::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    let a_biguint_high = U256::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    let b_biguint = UU32::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    let (res_biguint_low, res_biguint_high) = a_biguint_low.carrying_mul(&b_biguint, UU32::zero());
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);
    let (res_biguint_high, res_biguint_higher) = a_biguint_high.carrying_mul(&b_biguint, res_biguint_high);

    println!("{}:{} X {} = {}:{}:{}", a_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap(), a_biguint_low.to_string_with_radix_and_stride(16, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), res_biguint_higher.to_string_with_radix_and_stride(16, 8).unwrap(), res_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap(), res_biguint_low.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(res_biguint_higher.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFE");
    assert_eq!(res_biguint_higher.is_overflow(), false);
    assert_eq!(res_biguint_higher.is_underflow(), false);
    assert_eq!(res_biguint_higher.is_divided_by_zero(), false);
    assert_eq!(res_biguint_higher.is_infinity(), false);
    assert_eq!(res_biguint_higher.is_undefined(), false);

    assert_eq!(res_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF");
    assert_eq!(res_biguint_high.is_overflow(), true);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);

    assert_eq!(res_biguint_low.to_string(), "1");
    assert_eq!(res_biguint_low.is_overflow(), true);
    assert_eq!(res_biguint_low.is_underflow(), false);
    assert_eq!(res_biguint_low.is_divided_by_zero(), false);
    assert_eq!(res_biguint_low.is_infinity(), false);
    assert_eq!(res_biguint_low.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_carrying_mul_assign()
{
    println!("biguint_carrying_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case
    let mut a_biguint_low = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mut a_biguint_high = UU32::from_string("75388281194656994643364900608409476801874298166903427690031858186486050853").unwrap();
    let b_biguint = U256::from_string("16962363268797823794757102636892132280421717087553271230257168091959361441925").unwrap();
    println!("Originally, a_biguint_low = {}\na_biguint_high = {}", a_biguint_low, a_biguint_high);
    assert_eq!(a_biguint_low.is_overflow(), false);
    assert_eq!(a_biguint_low.is_underflow(), false);
    assert_eq!(a_biguint_low.is_divided_by_zero(), false);
    assert_eq!(a_biguint_low.is_infinity(), false);
    assert_eq!(a_biguint_low.is_undefined(), false);
    assert_eq!(a_biguint_high.is_overflow(), false);
    assert_eq!(a_biguint_high.is_underflow(), false);
    assert_eq!(a_biguint_high.is_divided_by_zero(), false);
    assert_eq!(a_biguint_high.is_infinity(), false);
    assert_eq!(a_biguint_high.is_undefined(), false);
    
    let res_biguint_high = a_biguint_low.carrying_mul_assign(&b_biguint, UU32::zero());
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);

    let res_biguint_higher = a_biguint_high.carrying_mul_assign(&b_biguint, res_biguint_high);
    println!("After a_biguint_low.carrying_mul_assign(&b_biguint, UU32::zero()),\na_biguint_low = {}", a_biguint_low);
    println!("After a_biguint_high.carrying_mul_assign(&b_biguint, res_biguint_high),\na_biguint_high = {}", a_biguint_high);
    println!("res_biguint_higher = {}", res_biguint_higher);
    assert_eq!(res_biguint_higher.to_string(), "11043616366686523019040587905143508095308019572635527295298701528708842829");
    assert_eq!(res_biguint_higher.is_overflow(), false);
    assert_eq!(res_biguint_higher.is_underflow(), false);
    assert_eq!(res_biguint_higher.is_divided_by_zero(), false);
    assert_eq!(res_biguint_higher.is_infinity(), false);
    assert_eq!(res_biguint_higher.is_undefined(), false);
    assert_eq!(a_biguint_high.to_string(), "47612192950075281462365720785702517256274202447286280420710978194126658529299");
    assert_eq!(a_biguint_high.is_overflow(), true);
    assert_eq!(a_biguint_high.is_underflow(), false);
    assert_eq!(a_biguint_high.is_divided_by_zero(), false);
    assert_eq!(a_biguint_high.is_infinity(), false);
    assert_eq!(a_biguint_high.is_undefined(), false);
    assert_eq!(a_biguint_low.to_string(), "99569105317044689054574557712853522297141576321520100863242044268764373638902");
    assert_eq!(a_biguint_low.is_overflow(), true);
    assert_eq!(a_biguint_low.is_underflow(), false);
    assert_eq!(a_biguint_low.is_divided_by_zero(), false);
    assert_eq!(a_biguint_low.is_infinity(), false);
    assert_eq!(a_biguint_low.is_undefined(), false);

    // Maximum case
    let mut a_biguint_low = U256::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    let mut a_biguint_high = U256::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    let b_biguint = U256::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    println!("Originally, a_biguint_low = {}\na_biguint_high = {}", a_biguint_low, a_biguint_high);
    assert_eq!(a_biguint_low.is_overflow(), false);
    assert_eq!(a_biguint_low.is_underflow(), false);
    assert_eq!(a_biguint_low.is_divided_by_zero(), false);
    assert_eq!(a_biguint_low.is_infinity(), false);
    assert_eq!(a_biguint_low.is_undefined(), false);
    assert_eq!(a_biguint_high.is_overflow(), false);
    assert_eq!(a_biguint_high.is_underflow(), false);
    assert_eq!(a_biguint_high.is_divided_by_zero(), false);
    assert_eq!(a_biguint_high.is_infinity(), false);
    assert_eq!(a_biguint_high.is_undefined(), false);
    
    let res_biguint_high = a_biguint_low.carrying_mul_assign(&b_biguint, UU32::zero());
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);

    let res_biguint_higher = a_biguint_high.carrying_mul_assign(&b_biguint, res_biguint_high);
    println!("After a_biguint_low.carrying_mul_assign(&b_biguint, UU32::zero()),\na_biguint_low = {}", a_biguint_low);
    println!("After a_biguint_high.carrying_mul_assign(&b_biguint, res_biguint_high),\na_biguint_high = {}", a_biguint_high);
    println!("res_biguint_higher = {}", res_biguint_higher);
    assert_eq!(res_biguint_higher.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFE");
    assert_eq!(res_biguint_higher.is_overflow(), false);
    assert_eq!(res_biguint_higher.is_underflow(), false);
    assert_eq!(res_biguint_higher.is_divided_by_zero(), false);
    assert_eq!(res_biguint_higher.is_infinity(), false);
    assert_eq!(res_biguint_higher.is_undefined(), false);
    assert_eq!(a_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF");
    assert_eq!(a_biguint_high.is_overflow(), true);
    assert_eq!(a_biguint_high.is_underflow(), false);
    assert_eq!(a_biguint_high.is_divided_by_zero(), false);
    assert_eq!(a_biguint_high.is_infinity(), false);
    assert_eq!(a_biguint_high.is_undefined(), false);
    assert_eq!(a_biguint_low.to_string(), "1");
    assert_eq!(a_biguint_low.is_overflow(), true);
    assert_eq!(a_biguint_low.is_underflow(), false);
    assert_eq!(a_biguint_low.is_divided_by_zero(), false);
    assert_eq!(a_biguint_low.is_infinity(), false);
    assert_eq!(a_biguint_low.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_widening_mul()
{
    println!("biguint_widening_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case
    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_string("123456789098765432101234566789098765432101234567890987654321012345678909876").unwrap();
    let (res_biguint_low, res_biguint_high) = a_biguint.widening_mul(&b_biguint);

    println!("{} X {} = {}:{}", a_biguint, b_biguint, res_biguint_high, res_biguint_low);
    assert_eq!(res_biguint_high.to_string(), "934840581853378776614741519244947987886551255599166686673415072970125925");
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);

    assert_eq!(res_biguint_low.to_string(), "99383456710232708163688724311017197312314189592099594761784803361525674171544");
    assert_eq!(res_biguint_low.is_overflow(), true);
    assert_eq!(res_biguint_low.is_underflow(), false);
    assert_eq!(res_biguint_low.is_divided_by_zero(), false);
    assert_eq!(res_biguint_low.is_infinity(), false);
    assert_eq!(res_biguint_low.is_undefined(), false);

    // Maximum case
    let a_biguint = U256::max();
    let b_biguint = U256::max();
    let (res_biguint_low, res_biguint_high) = a_biguint.widening_mul(&b_biguint);

    println!("{} X {} = {}:{}", a_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), res_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap(), res_biguint_low.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(res_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFE");
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);

    assert_eq!(res_biguint_low.to_string_with_radix_and_stride(16, 8).unwrap(), "1");
    assert_eq!(res_biguint_low.is_overflow(), true);
    assert_eq!(res_biguint_low.is_underflow(), false);
    assert_eq!(res_biguint_low.is_divided_by_zero(), false);
    assert_eq!(res_biguint_low.is_infinity(), false);
    assert_eq!(res_biguint_low.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_widening_mul_assign()
{
    println!("biguint_widening_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case
    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_string("123456789098765432101234566789098765432101234567890987654321012345678909876").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let res_biguint_high = a_biguint.widening_mul_assign(&b_biguint);
    println!("After a_biguint.widening_mul_assign(&b_biguint),\na_biguint = {}\nres_biguint_high = {}", a_biguint, res_biguint_high);
    assert_eq!(a_biguint.to_string(), "99383456710232708163688724311017197312314189592099594761784803361525674171544");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(res_biguint_high.to_string(), "934840581853378776614741519244947987886551255599166686673415072970125925");
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);

    // Maximum case
    let mut a_biguint = U256::max();
    let b_biguint = U256::max();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let res_biguint_high = a_biguint.widening_mul_assign(&b_biguint);
    println!("After a_biguint.widening_mul_assign(&b_biguint),\na_biguint = {}\nres_biguint_high = {}", a_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), res_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(16, 8).unwrap(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(res_biguint_high.to_string_with_radix_and_stride(16, 8).unwrap(), "FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFE");
    assert_eq!(res_biguint_high.is_overflow(), false);
    assert_eq!(res_biguint_high.is_underflow(), false);
    assert_eq!(res_biguint_high.is_divided_by_zero(), false);
    assert_eq!(res_biguint_high.is_infinity(), false);
    assert_eq!(res_biguint_high.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_mul()
{
    println!("biguint_wrapping_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let res = a_biguint.wrapping_mul(&b_biguint);
    println!("{} X {} = {}", a_biguint, b_biguint, res);
    assert_eq!(res.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let res = a_biguint.wrapping_mul(&b_biguint);
    println!("{} X {} = {}", a_biguint, b_biguint, res);
    assert_eq!(res.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_wrapping_mul_assign()
{
    println!("biguint_wrapping_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU32::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_mul_assign(&b_biguint);
    println!("After a_biguint.wrapping_mul_assign(&b_biguint), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.wrapping_mul_assign(&b_biguint);
    println!("After c_biguint.wrapping_mul_assign(&b_biguint), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_mul()
{
    println!("biguint_overflowing_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_string("1874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let (res, overflow) = a_biguint.overflowing_mul(&b_biguint);
    println!("{} X {} = {}, {}", a_biguint, b_biguint, res, overflow);
    assert_eq!(overflow, false);
    assert_eq!(res.to_string(), "464825945392050067127900830248540611730962937362749346715544953508855312");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let (res, overflow) = a_biguint.overflowing_mul(&b_biguint);
    println!("{} X {} = {}, {}", a_biguint, b_biguint, res, overflow);
    assert_eq!(overflow, true);
    assert_eq!(res.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_overflowing_mul_assign()
{
    println!("biguint_overflowing_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = UU32::from_string("1874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);

    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let overflow = a_biguint.overflowing_mul_assign(&b_biguint);
    println!("After a_biguint.overflowing_mul_assign(&b_biguint), a_biguint = {}, {}", a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.to_string(), "464825945392050067127900830248540611730962937362749346715544953508855312");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let overflow = a_biguint.overflowing_mul_assign(&b_biguint);
    println!("After c_biguint.overflowing_mul_assign(&b_biguint), a_biguint = {}, {}", a_biguint, overflow);
    assert_eq!(overflow, true);
    assert_eq!(a_biguint.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_checked_mul()
{
    println!("biguint_checked_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_string("1874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let res = a_biguint.checked_mul(&b_biguint);
    match &res
    {
        Some(r) =>
            {
                println!("{} X {} = {}", a_biguint, b_biguint, r);
                assert_eq!(r.to_string(), "464825945392050067127900830248540611730962937362749346715544953508855312");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
            },
        None => { println!("Overflow happend!"); },
    }

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let res = a_biguint.checked_mul(&b_biguint);
    match &res
    {
        Some(r) => { println!("{} X {} = {}", a_biguint, b_biguint, r); },
        None =>
            {
                println!("Overflow happend!");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_mul()
{
    println!("biguint_unchecked_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = UU32::from_string("1874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = UU32::from_uint(248_u8);
    let res = a_biguint.unchecked_mul(&b_biguint);
    println!("{} X {} = {}", a_biguint, b_biguint, res);
    assert_eq!(res.to_string(), "464825945392050067127900830248540611730962937362749346715544953508855312");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let _a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let _b_biguint = UU32::from_uint(248_u8);
    // It will panic.
    // let res = a_biguint.unchecked_mul(&_b_biguint);
    println!("---------------------------");
}

fn biguint_saturating_mul()
{
    println!("biguint_saturating_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = UU32::from_uint(5_u8);
    let res = a_biguint.saturating_mul(&b_biguint);
    println!("{} X {} = {}", a_biguint, b_biguint, res);
    assert_eq!(res.to_string(), "4384009371490834517138450159290932430254268769414059732849732168245030420470");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let b_biguint = UU32::from_uint(248_u8);
    let res = a_biguint.saturating_mul(&b_biguint);
    println!("{} X {} = {}", a_biguint, b_biguint, res);
    assert_eq!(res, UU32::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_saturating_mul_assign()
{
    println!("biguint_saturating_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = UU32::from_uint(5_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.saturating_mul_assign(&b_biguint);
    println!("After a_biguint.saturating_mul_assign(&b_biguint), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "4384009371490834517138450159290932430254268769414059732849732168245030420470");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = UU32::from_uint(248_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    a_biguint.saturating_mul_assign(&b_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    println!("After a_biguint.saturating_mul_assign_uint(&b_biguint), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint, UU32::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_modular_mul()
{
    println!("biguint_modular_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let mul_biguint = UU32::from_uint(5_u8);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let mul_biguint = UU32::from_uint(123456789_u32);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "8622247606403727534023749230384750061554739874487486410968923457264899031");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == maximum
    let m = UU32::max();
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let mul_biguint = UU32::from_uint(123456789_u32);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "111970462099597246185125739952117562742423650866418469977837510261574559319010");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_biguint = UU32::from_uint(5_u8);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_biguint = UU32::from_uint(5_u8);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_biguint = UU32::zero();
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let mul_biguint = UU32::from_uint(4321000_u32);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == 0 and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_biguint = UU32::zero();
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == 0 and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_biguint = UU32::from_uint(4321000_u32);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_biguint = UU32::zero();
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_biguint = UU32::from_uint(4321000_u32);
    let res = a_biguint.modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // Panic Examples
    let _m = UU32::zero();
    let _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let _mul_biguint = UU32::from_uint(248_u8);
    // It will panic!
    // let res = _a_biguint.modular_mul(&_mul_biguint, &_m);
    
    let _m = UU32::one();
    let _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let _mul_biguint = UU32::from_uint(248_u8);
    // It will panic!
    // let res = _a_biguint.modular_mul(&_mul_biguint, &_m);
    println!("---------------------------");
}

fn biguint_modular_mul_assign()
{
    println!("biguint_modular_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_biguint = UU32::from_uint(5_u8);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After a_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_biguint = UU32::from_uint(123456789_u32);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "8622247606403727534023749230384750061554739874487486410968923457264899031");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == maximum
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::max();
    let mul_biguint = UU32::from_uint(123456789_u32);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "111970462099597246185125739952117562742423650866418469977837510261574559319010");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(5_u8);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(4321000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(5_u8);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::zero();
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(4321000_u32);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::zero();
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0 and op2 == multiple of modulo
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(4321000_u32);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(4321000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::zero();
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(4321000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(4321000_u32);
    a_biguint.modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // Panic Examples
    let mut _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    assert_eq!(_a_biguint.is_overflow(), false);
    assert_eq!(_a_biguint.is_underflow(), false);
    assert_eq!(_a_biguint.is_divided_by_zero(), false);
    assert_eq!(_a_biguint.is_infinity(), false);
    assert_eq!(_a_biguint.is_undefined(), false);

    let _m = UU32::zero();
    let _mul_biguint = UU32::from_uint(248_u8);
    // It will panic!
    // _a_biguint.modular_mul_assign(&_mul_biguint, &_m);
    
    let mut _a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    assert_eq!(_a_biguint.is_overflow(), false);
    assert_eq!(_a_biguint.is_underflow(), false);
    assert_eq!(_a_biguint.is_divided_by_zero(), false);
    assert_eq!(_a_biguint.is_infinity(), false);
    assert_eq!(_a_biguint.is_undefined(), false);

    let _m = UU32::one();
    let _mul_biguint = UU32::from_uint(248_u8);
    // It will panic!
    // _a_biguint.modular_mul_assign(&_mul_biguint, &_m);
    println!("---------------------------");
}

fn biguint_panic_free_modular_mul()
{
    println!("biguint_panic_free_modular_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case 1
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let mul_biguint = UU32::from_uint(5_u8);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // Normal case 2
    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let mul_biguint = UU32::from_uint(123456789_u32);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "8622247606403727534023749230384750061554739874487486410968923457264899031");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == maximum
    let m = UU32::max();
    let a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    let mul_biguint = UU32::from_uint(123456789_u32);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "111970462099597246185125739952117562742423650866418469977837510261574559319010");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op1 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_biguint = UU32::from_uint(5_u8);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_biguint = UU32::from_uint(5_u8);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_biguint = UU32::zero();
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let mul_biguint = UU32::from_uint(4321000_u32);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == 0 and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_biguint = UU32::zero();
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == 0 and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::zero();
    let mul_biguint = UU32::from_uint(4321000_u32);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_biguint = UU32::zero();
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let m = UU32::from_uint(1000_u16);
    let a_biguint = U256::from_uint(4321000_u32);
    let mul_biguint = UU32::from_uint(4321000_u32);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // modulo == 0
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::zero();
    let mul_biguint = UU32::from_uint(248_u8);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);

    // modulo == 1
    let a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    let m = UU32::one();
    let mul_biguint = UU32::from_uint(248_u8);
    let res = a_biguint.panic_free_modular_mul(&mul_biguint, &m);
    println!("{} * {} = {} (mod {})", a_biguint, mul_biguint, res, m);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    
    // Collective Example for modulo == 0 or 1
    for a_biguint in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [U256::zero(), U256::from_uint(3_u8), U256::from_uint(50_u8)]
        {
            for m in [U256::zero(), U256::one()]
            {
                let res = a_biguint.panic_free_modular_mul(&rhs, &m);
                println!("{} * {} = {} (mod {})", a_biguint, rhs, res, m);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_mul_assign()
{
    println!("biguint_panic_free_modular_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_biguint = UU32::from_uint(5_u8);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After a_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "159290932430254268769414059733840093714908345171384502932436456877341425");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // Normal case 2
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let mul_biguint = UU32::from_uint(123456789_u32);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "8622247606403727534023749230384750061554739874487486410968923457264899031");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == maximum
    let mut a_biguint = U256::from_string("31858186486050853753882811946768018742981669034276900586487291375468285").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::max();
    let mul_biguint = UU32::from_uint(123456789_u32);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "111970462099597246185125739952117562742423650866418469977837510261574559319010");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op1 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(5_u8);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo
    let mut a_biguint = U256::from_uint(4321000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(5_u8);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == 0
    let mut a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::zero();
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op2 == multiple of modulo
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(4321000_u32);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0 and op2 == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::zero();
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == 0 and op2 == multiple of modulo
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(4321000_u32);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == 0
    let mut a_biguint = U256::from_uint(4321000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::zero();
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut a_biguint = U256::from_uint(4321000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::from_uint(1000_u16);
    let mul_biguint = UU32::from_uint(4321000_u32);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After b_biguint.modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // modulo == 0
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::zero();
    let mul_biguint = UU32::from_uint(248_u8);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);

    // modulo == 1
    let mut a_biguint = U256::from_string("318581864860508537538828119467680187429816690342769005864872913754682855846").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let m = UU32::one();
    let mul_biguint = UU32::from_uint(248_u8);
    a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m);
    println!("After a_biguint.panic_free_modular_mul_assign(&mul_biguint, &m), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    
    // Collective Example for modulo == 0 or 1
    for a in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::zero(), U256::from_uint(50_u8)]
    {
        for rhs in [U256::zero(), U256::from_uint(3_u8), U256::from_uint(50_u8)]
        {
            for m in [U256::zero(), U256::one()]
            {
                let mut a_biguint = a.clone();
                println!("Originally, a_biguint = {}", a_biguint);
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), false);

                a_biguint.panic_free_modular_mul_assign(&rhs, &m);
                println!("After b_biguint.panic_free_modular_mul_assign(&rhs, &m), a_biguint = {}", a_biguint);
                assert_eq!(a_biguint.to_string(), "0");
                assert_eq!(a_biguint.is_overflow(), false);
                assert_eq!(a_biguint.is_underflow(), false);
                assert_eq!(a_biguint.is_divided_by_zero(), false);
                assert_eq!(a_biguint.is_infinity(), false);
                assert_eq!(a_biguint.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_div()
{
    biguint_divide_fully();
    biguint_panic_free_divide_fully();
    biguint_wrapping_div();
    biguint_wrapping_div_assign();
    biguint_overflowing_div();
    biguint_overflowing_div_assign();
    biguint_checked_div();
    biguint_unchecked_div();
    biguint_saturating_div();
    biguint_saturating_div_assign();
    biguint_panic_free_div();
    biguint_panic_free_div_assign();
    biguint_modular_div();
    biguint_modular_div_assign();
    biguint_panic_free_modular_div();
    biguint_panic_free_modular_div_assign();
}

fn biguint_divide_fully()
{
    println!("biguint_divide_fully");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let (quotient, remainder) = dividend.divide_fully(&divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let (quotient, remainder) = dividend.divide_fully(&divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    // It will panic!
    // let (quotient, remainder) = dividend.divide_fully(&_divisor);

    let _dividend = UU32::zero();
    let _divisor = 0_u8;
    // It will panic!
    // let (quotient, remainder) = dividend.divide_fully(&_divisor);
    println!("---------------------------");
}

fn biguint_panic_free_divide_fully()
{
    println!("biguint_panic_free_divide_fully");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let (quotient, remainder) = dividend.panic_free_divide_fully(&divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // Normal case 2
    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let (quotient, remainder) = dividend.panic_free_divide_fully(&divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // dividend != 0 and divisor == 0
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::zero();
    let (quotient, remainder) = dividend.panic_free_divide_fully(&divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient, UU32::max());
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // dividend == 0 and divisor == 0
    let dividend = UU32::zero();
    let divisor = UU32::zero();
    let (quotient, remainder) = dividend.panic_free_divide_fully(&divisor);
    println!("{} / {} => quotient = {} , remainder = {}", dividend, divisor, quotient, remainder);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_wrapping_div()
{
    println!("biguint_wrapping_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.wrapping_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = U256::zero();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.wrapping_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    // It will panic!
    // let quotient = _dividend.wrapping_div(&_divisor);

    let _dividend = U256::zero();
    let _divisor = U256::zero();
    // It will panic!
    // let quotient = _dividend.wrapping_div(&_divisor);
    println!("---------------------------");
}

fn biguint_wrapping_div_assign()
{
    println!("biguint_wrapping_div_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.wrapping_div_assign(&divisor);
    println!("After a_biguint.wrapping_div_assign(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.wrapping_div_assign(&divisor);
    println!("After a_biguint.wrapping_div_assign(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.wrapping_div_assign(&_divisor);

    let mut _a_biguint = UU32::zero();
    let _divisor = UU32::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.wrapping_div_assign(&_divisor);
    println!("---------------------------");
}

fn biguint_overflowing_div()
{
    println!("biguint_overflowing_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let (quotient, overflow) = dividend.overflowing_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(overflow, false);
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = U256::zero();
    let divisor = U256::from_uint(87_u8);
    let (quotient, overflow) = dividend.overflowing_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(overflow, false);
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    // It will panic!
    // let (quotient, overflow) = _dividend.overflowing_div(&_divisor);

    let _dividend = U256::zero();
    let _divisor = U256::zero();
    // It will panic!
    // let (quotient, overflow) = _dividend.overflowing_div(&_divisor);
    println!("---------------------------");
}

fn biguint_overflowing_div_assign()
{
    println!("biguint_overflowing_div_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let overflow = a_biguint.overflowing_div_assign(&divisor);
    println!("After a_biguint.overflowing_div_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let overflow = a_biguint.overflowing_div_assign(&divisor);
    println!("After a_biguint.overflowing_div_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    // It will panic!
    // let overflow = _a_biguint.overflowing_div_assign(&_divisor);

    let mut _a_biguint = UU32::zero();
    let _divisor = UU32::zero();
    // It will panic!
    // let overflow = _a_biguint.overflowing_div_assign(&_divisor);
    println!("---------------------------");
}

fn biguint_checked_div()
{
    println!("biguint_checked_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.checked_div(&divisor);
    match quotient
    {
        Some(q) =>
            {
                println!("{} / {} = {}", dividend, divisor, q);
                assert_eq!(q.to_string(), "1419043551905275201680884938348044216837079832");
                assert_eq!(q.is_overflow(), false);
                assert_eq!(q.is_underflow(), false);
                assert_eq!(q.is_infinity(), false);
                assert_eq!(q.is_undefined(), false);
                assert_eq!(q.is_divided_by_zero(), false);
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = U256::zero();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.checked_div(&divisor);
    match quotient
    {
        Some(q) =>
            {
                println!("{} / {} = {}", dividend, divisor, q);
                assert_eq!(q.to_string(), "0");
                assert_eq!(q.is_overflow(), false);
                assert_eq!(q.is_underflow(), false);
                assert_eq!(q.is_infinity(), false);
                assert_eq!(q.is_undefined(), false);
                assert_eq!(q.is_divided_by_zero(), false);
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::zero();
    let quotient = dividend.checked_div(&divisor);
    match quotient
    {
        Some(q) => { println!("{} / {} = {}", dividend, divisor, q); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(quotient, None);
            },
    }

    let dividend = U256::zero();
    let divisor = U256::zero();
    let quotient = dividend.checked_div(&divisor);
    match quotient
    {
        Some(q) => { println!("{} / {} = {}", dividend, divisor, q); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(quotient, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_div()
{
    println!("biguint_unchecked_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let quotient = dividend.unchecked_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let quotient = dividend.unchecked_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    // It will panic.
    // let quotient = _dividend.uchecked_div_uint(_divisor);

    let _dividend = UU32::zero();
    let _divisor = UU32::zero();
    // It will panic.
    // let quotient = _dividend.uchecked_div_uint(_divisor);
    println!("---------------------------");
}

fn biguint_saturating_div()
{
    println!("biguint_saturating_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.saturating_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let quotient = dividend.saturating_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    // It will panic!
    // let quotient = _dividend.saturating_div(&divisor);

    let _dividend = UU32::zero();
    let _divisor = UU32::zero();
    // It will panic!
    // let quotient = _dividend.saturating_div(&divisor);
    println!("---------------------------");
}

fn biguint_saturating_div_assign()
{
    println!("biguint_saturating_div_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.saturating_div_assign(&divisor);
    println!("After a_biguint.saturating_div_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.saturating_div_assign(&divisor);
    println!("After a_biguint.saturating_div_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.saturating_div_assign(&_divisor);

    let mut _a_biguint = UU32::zero();
    let _divisor = UU32::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.saturating_div_assign(&_divisor);
    println!("---------------------------");
}

fn biguint_panic_free_div()
{
    println!("biguint_panic_free_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.panic_free_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // Normal case 2
    let dividend = U256::zero();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.panic_free_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // dividend != 0 and divisor = 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::zero();
    let quotient = dividend.panic_free_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient, U256::max());
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // dividend == 0 and divisor = 0
    let dividend = U256::zero();
    let divisor = U256::zero();
    let quotient = dividend.panic_free_div(&divisor);
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_panic_free_div_assign()
{
    println!("biguint_panic_free_div_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(87_u8);
    a_biguint.panic_free_div_assign(&divisor);
    println!("After a_biguint.panic_free_div_assign(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(87_u8);
    a_biguint.panic_free_div_assign(&divisor);
    println!("After a_biguint.panic_free_div_assign(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::zero();
    a_biguint.panic_free_div_assign(&divisor);
    println!("After a_biguint.panic_free_div_assign(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint, UU32::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::zero();
    a_biguint.panic_free_div_assign(&divisor);
    println!("After a_biguint.panic_free_div_assign(&divisor),\na_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_modular_div()
{
    println!("biguint_modular_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "3");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // dividend == 0
    let dividend = U256::zero();
    let modulo = U256::from_uint(250_u8);
    let divisor = U256::from_uint(3_u8);
    let res = dividend.modular_div(&divisor, &modulo);
    println!("{} / {} = {}(mod {})", dividend, divisor, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // dividend == multiple of modulo
    let dividend = U256::from_uint(750_u16);
    let modulo = U256::from_uint(250_u8);
    let divisor = U256::from_uint(3_u8);
    let res = dividend.modular_div(&divisor, &modulo);
    println!("{} / {} = {}(mod {})", dividend, divisor, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    // op2 == 0
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::from_uint(250_u8);
    let _rhs = U256::zero();
    // It will panic.
    // let res = _a_biguint.modular_div(&_rhs, &_m);

    // op2 == multiple of modulo
    let _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    let _m = U256::from_uint(50_u8);
    let _rhs = U256::from_uint(250_u8);
    // It will panic.
    // let res = _a_biguint.modular_div(&_rhs, &_m);

    // op1 == 0 and op2 == 0
    let _a_biguint = U256::zero();
    let _m = U256::from_uint(250_u8);
    let _rhs = U256::zero();
    // It will panic.
    // let res = _a_biguint.modular_div(&_rhs, &_m);

    // op1 == multiple of modulo and op2 == 0
    let _a_biguint = U256::from_uint(750_u16);
    let _m = U256::from_uint(250_u8);
    let _rhs = U256::zero();
    // It will panic.
    // let res = _a_biguint.modular_div(&_rhs, &_m);

    // op1 == 0 and op2 == multiple of modulo
    let _a_biguint = U256::zero();
    let _m = U256::from_uint(50_u8);
    let _rhs = U256::from_uint(250_u8);
    // It will panic.
    // let res = _a_biguint.modular_div(&_rhs, &_m);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let _a_biguint = U256::from_uint(150_u8);
    let _m = U256::from_uint(50_u8);
    let _rhs = U256::from_uint(250_u8);
    // It will panic.
    // let res = _a_biguint.modular_div(&_rhs, &_m);

    // modulo == 0
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::zero();
    // It will panic!
    // let quotient = _dividend.modular_div(&_divisor, &_modulo);

    // modulo == 1
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::one();
    // It will panic!
    // let quotient = _dividend.modular_div(&_divisor, &_modulo);
    println!("---------------------------");
}

fn biguint_modular_div_assign()
{
    println!("biguint_modular_div_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.modular_div_assign({}, {}),\na_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // dividend == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(3_u8);
    let modulo = U256::from_uint(250_u8);
    a_biguint.modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.modular_div_assign({}, {}),\na_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // dividend == multiple of modulo
    let mut a_biguint = U256::from_uint(750_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let modulo = U256::from_uint(250_u8);
    let divisor = U256::from_uint(3_u8);
    a_biguint.modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.modular_div_assign({}, {}),\na_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    // op2 == 0
    let mut _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(250_u8);
    let _rhs = U256::zero();
    // It will panic.
    // _a_biguint.modular_div_assign(&_rhs, &_m);

    // op2 == multiple of modulo
    let mut _a_biguint = U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(50_u8);
    let _rhs = U256::from_uint(250_u8);
    // It will panic.
    // _a_biguint.modular_div_assign(&_rhs, &_m);

    // op1 == 0 and op2 == 0
    let mut _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(250_u8);
    let _rhs = U256::zero();
    // It will panic.
    // _a_biguint.modular_div_assign(&_rhs, &_m);

    // op1 == multiple of modulo and op2 == 0
    let mut _a_biguint = U256::from_uint(750_u16);
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(250_u8);
    let _rhs = U256::zero();
    // It will panic.
    // _a_biguint.modular_div_assign(&_rhs, &_m);

    // op1 == 0 and op2 == multiple of modulo
    let mut _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(50_u8);
    let _rhs = U256::from_uint(250_u8);
    // It will panic.
    // _a_biguint.modular_div_assign(&_rhs, &_m);

    // op1 == multiple of modulo and op2 == multiple of modulo
    let mut _a_biguint = U256::from_uint(150_u8);
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _m = U256::from_uint(50_u8);
    let _rhs = U256::from_uint(250_u8);
    // It will panic.
    // _a_biguint.modular_div_assign(&_rhs, &_m);

    // modulo == 0
    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::zero();
    // It will panic!
    // _a_biguint.modular_div_assign(&_divisor, &_modulo);

    // modulo == 1
    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::one();
    // It will panic!
    // _a_biguint.modular_div_assign(&_divisor, &_modulo);
    println!("---------------------------");
}

fn biguint_panic_free_modular_div()
{
    println!("biguint_panic_free_modular_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    
    // Normal case 1
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "3");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // Normal case 2 for modulo >= 2 and dividend == 0 and divisor != 0
    let dividend = U256::zero();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // Normal case 3 for modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let dividend = U256::from_uint(10000_u16);
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // modulo >= 2 and divisor == 0 and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient, U256::max());
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == multiple of modulo and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient, U256::max());
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), true);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == 0 and dividend == multiple of modulo
    let dividend = U256::from_uint(30000_u16);
    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == multiple of modulo and dividend == 0
    let dividend = U256::zero();
    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == multiple of modulo and dividend == multiple of modulo
    let dividend = U256::from_uint(30000_u16);
    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo == 0 and divisor != 0 and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::zero();
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // modulo == 1 and divisor != 0 and dividend != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::one();
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), false);

    // modulo == 0 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = U256::zero();
    let modulo = U256::zero();
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = U256::zero();
    let modulo = U256::one();
    let quotient = dividend.panic_free_modular_div(&divisor, &modulo);
    println!("{} / {} = {} (mod {})", dividend, divisor, quotient, modulo);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), true);
    assert_eq!(quotient.is_divided_by_zero(), true);

    // collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let op1 = U256::zero();
        let op2 = U256::zero();
        let res = op1.panic_free_modular_div(&op2, &modulo);
        println!("{} / {} = {} (mod {})", op1, op2, res, modulo);
        assert_eq!(res.to_string(), "0");
        assert_eq!(res.is_overflow(), false);
        assert_eq!(res.is_underflow(), false);
        assert_eq!(res.is_divided_by_zero(), true);
        assert_eq!(res.is_infinity(), false);
        assert_eq!(res.is_undefined(), true);
        
        for dividend in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let rhs = U256::zero();
            let res = dividend.panic_free_modular_div(&rhs, &modulo);
            println!("{} / {} = {} (mod {})", dividend, rhs, res, modulo);
            assert_eq!(res.to_string(), "0");
            assert_eq!(res.is_overflow(), false);
            assert_eq!(res.is_underflow(), false);
            assert_eq!(res.is_divided_by_zero(), true);
            assert_eq!(res.is_infinity(), true);
            assert_eq!(res.is_undefined(), true);

            for divisor in [U256::from_uint(3_u8), U256::from_uint(50_u8)]
            {
                let res = dividend.panic_free_modular_div(&divisor, &modulo);
                println!("{} / {} = {} (mod {})", dividend, divisor, res, modulo);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_div_assign()
{
    println!("biguint_panic_free_modular_div_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "3");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2 for modulo >= 2 and self == 0 and divisor != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 3 for modulo >= 2 and self == multiple of modulo and divisor != 0
    let mut a_biguint = U256::from_uint(10000_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self != 0 and divisor == 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639935");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self != 0 and divisor == multiple of modulo
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "115792089237316195423570985008687907853269984665640564039457584007913129639935");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == multiple of modulo
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == 0
    let mut a_biguint = U256::from_uint(30000_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == multiple of modulo
    let mut a_biguint = U256::from_uint(30000_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 0 and divisor != 0 and dividend != 0
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(128_u8);
    let modulo = U256::zero();
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 1 and divisor != 0 and dividend != 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(128_u8);
    let modulo = U256::one();
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 0 and divisor == 0 and dividend == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::zero();
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and dividend == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::one();
    a_biguint.panic_free_modular_div_assign(&divisor, &modulo);
    println!("After a_biguint.panic_free_modular_div_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // Collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let mut dividend = U256::zero();
        println!("Originally, op1 = {}", dividend);
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), false);
        assert_eq!(dividend.is_divided_by_zero(), false);

        let divisor = U256::zero();
        dividend.panic_free_modular_div_assign(&divisor, &modulo);
        println!("After a_biguint.panic_free_modular_div_assign({}, {}), op1 = {}", divisor, modulo, dividend);
        assert_eq!(dividend.to_string(), "0");
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_divided_by_zero(), true);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), true);
        
        for op in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let mut dividend = op.clone();
            println!("Originally, dividend = {}", dividend);
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_infinity(), false);
            assert_eq!(dividend.is_undefined(), false);
            assert_eq!(dividend.is_divided_by_zero(), false);

            let divisor = U256::zero();
            dividend.panic_free_modular_div_assign(&divisor, &modulo);
            println!("After op1.panic_free_modular_div_assign({}, {}), dividend = {}", divisor, modulo, dividend);
            assert_eq!(dividend.to_string(), "0");
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_divided_by_zero(), true);
            assert_eq!(dividend.is_infinity(), true);
            assert_eq!(dividend.is_undefined(), true);

            for divisor in [U256::from_uint(3_u8), U256::from_uint(50_u8)]
            {
                let mut dividend = op.clone();
                println!("Originally, dividend = {}", dividend);
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
    
                dividend.panic_free_modular_div_assign(&divisor, &modulo);
                println!("After dividend.panic_free_modular_div_assign({}, {}), dividend = {}", divisor, modulo, dividend);
                assert_eq!(dividend.to_string(), "0");
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}


fn biguint_rem()
{
    biguint_wrapping_rem();
    biguint_wrapping_rem_assign();
    biguint_overflowing_rem();
    biguint_overflowing_rem_assign();
    biguint_checked_rem();
    biguint_unchecked_rem();
    biguint_saturating_rem();
    biguint_saturating_rem_assign();
    biguint_panic_free_rem();
    biguint_panic_free_rem_assign();
    biguint_modular_rem();
    biguint_modular_rem_assign();
    biguint_panic_free_modular_rem();
    biguint_panic_free_modular_rem_assign();
}

fn biguint_wrapping_rem()
{
    println!("biguint_wrapping_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.wrapping_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.wrapping_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    // It will panic!
    // let remainder = _dividend.wrapping_rem(&_divisor);

    let _dividend = UU32::zero();
    let _divisor = UU32::zero();
    // It will panic!
    // let remainder = _dividend.wrapping_rem(&_divisor);
    println!("---------------------------");
}

fn biguint_wrapping_rem_assign()
{
    println!("biguint_wrapping_rem_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint.wrapping_rem_assign(&divisor);
    println!("After a_biguint.wrapping_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint.wrapping_rem_assign(&divisor);
    println!("After a_biguint.wrapping_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _divisor = U256::zero();
    // It will panic!
    // _a_biguint.wrapping_rem_assign(&_divisor);

    let mut _a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _divisor = U256::zero();
    // It will panic!
    // _a_biguint.wrapping_rem_assign(&_divisor);
    println!("---------------------------");
}

fn biguint_overflowing_rem()
{
    println!("biguint_overflowing_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let (remainder, overflow) = dividend.overflowing_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(overflow, false);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let (remainder, overflow) = dividend.overflowing_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(overflow, false);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    // It will panic!
    // let (remainder, overflow) = _dividend.overflowing_rem(&_divisor);

    let _dividend = UU32::zero();
    let _divisor = UU32::zero();
    // It will panic!
    // let (remainder, overflow) = _dividend.overflowing_rem(&_divisor);
    println!("---------------------------");
}

fn biguint_overflowing_rem_assign()
{
    println!("biguint_overflowing_rem_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(87_u8);
    let overflow = a_biguint.overflowing_rem_assign(&divisor);
    println!("After a_biguint.overflowing_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(87_u8);
    let overflow = a_biguint.overflowing_rem_assign(&divisor);
    println!("After a_biguint.overflowing_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic!
    // let overflow = _a_biguint.overflowing_rem_assign(&_divisor);

    let mut _a_biguint = U256::zero();
    let _divisor = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic!
    // let overflow = _a_biguint.overflowing_rem_assign(&_divisor);
    println!("---------------------------");
}

fn biguint_checked_rem()
{
    println!("biguint_checked_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.checked_rem(&divisor);
    match remainder
    {
        Some(r) =>
            {
                println!("{} % {} = {}", dividend, divisor, r);
                assert_eq!(r.to_string(), "8");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.checked_rem(&divisor);
    match remainder
    {
        Some(r) =>
            {
                println!("{} % {} = {}", dividend, divisor, r);
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Divided By Zero"); },
    }

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::zero();
    let remainder = dividend.checked_rem(&divisor);
    match remainder
    {
        Some(r) => { println!("{} % {} = {}", dividend, divisor, r); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(remainder, None);
            },
    }

    let dividend = UU32::zero();
    let divisor = UU32::zero();
    let remainder = dividend.checked_rem(&divisor);
    match remainder
    {
        Some(r) => { println!("{} % {} = {}", dividend, divisor, r); },
        None =>
            {
                println!("Divided By Zero");
                assert_eq!(remainder, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_rem()
{
    println!("biguint_unchecked_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let remainder = dividend.unchecked_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let dividend = U256::zero();
    let divisor = U256::from_uint(87_u8);
    let remainder = dividend.unchecked_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    // It will panic.
    // let remainder = _dividend.unchecked_rem(&_divisor);

    let _dividend = U256::zero();
    let _divisor = U256::zero();
    // It will panic.
    // let remainder = _dividend.unchecked_rem(&_divisor);
    println!("---------------------------");
}

fn biguint_saturating_rem()
{
    println!("biguint_saturating_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.saturating_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.saturating_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    // It will panic!
    // let remainder = _dividend.saturating_rem(&_divisor);

    let _dividend = UU32::zero();
    let _divisor = UU32::zero();
    // It will panic!
    // let remainder = _dividend.saturating_rem(&_divisor);
    println!("---------------------------");
}

fn biguint_saturating_rem_assign()
{
    println!("biguint_saturating_rem_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint.saturating_rem_assign(&divisor);
    println!("After a_biguint.saturating_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint.saturating_rem_assign(&divisor);
    println!("After a_biguint.saturating_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.saturating_rem_assign(&_divisor);

    let mut _a_biguint = U256::zero();
    let _divisor = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.saturating_rem_assign(&_divisor);
    println!("---------------------------");
}

fn biguint_panic_free_rem()
{
    println!("biguint_panic_free_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case 1
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.panic_free_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);
    assert_eq!(remainder.is_undefined(), false);

    // Normal case 2
    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.panic_free_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);
    assert_eq!(remainder.is_undefined(), false);

    // dividend != 0 and divisor == 0
    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::zero();
    let remainder = dividend.panic_free_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    assert_eq!(remainder.is_undefined(), false);
    
    // dividend == 0 and divisor == 0
    let dividend = UU32::zero();
    let divisor = UU32::zero();
    let remainder = dividend.panic_free_rem(&divisor);
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    assert_eq!(remainder.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_panic_free_rem_assign()
{
    println!("biguint_panic_free_rem_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint.panic_free_rem_assign(&divisor);
    println!("After a_biguint.panic_free_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint.panic_free_rem_assign(&divisor);
    println!("After a_biguint.panic_free_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // dividend != 0 and divisor == 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let divisor = U256::zero();
    a_biguint.panic_free_rem_assign(&divisor);
    println!("After a_biguint.panic_free_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // dividend == 0 and divisor == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    
    let divisor = U256::zero();
    a_biguint.panic_free_rem_assign(&divisor);
    println!("After a_biguint.panic_free_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_modular_rem()
{
    println!("biguint_modular_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);
    assert_eq!(remainder.is_undefined(), false);

    // modulo >= 2 and dividend == 0 and divisor != 0
    let dividend = U256::zero();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);
    assert_eq!(remainder.is_undefined(), false);

    // modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let dividend = U256::from_uint(200_u8);
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);
    assert_eq!(remainder.is_undefined(), false);

    // modulo >= 2 and dividend != 0 and divisor == 0    
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);

    // modulo >= 2 and dividend != 0 and divisor == multiple of modulo
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == 0
    let _dividend = U256::zero();
    let _divisor = U256::zero();
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == multiple of modulo
    let _dividend = U256::zero();
    let _divisor = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == 0
    let _dividend = U256::from_uint(200_u8);
    let _divisor = U256::zero();
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == multiple of modulo
    let _dividend = U256::from_uint(200_u8);
    let _divisor = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);

    // modulo == 0
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::zero();
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);

    // modulo == 1
    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::one();
    // It will panic!
    // let quotient = _dividend.modular_rem(&_divisor, &_modulo);
    println!("---------------------------");
}

fn biguint_modular_rem_assign()
{
    println!("biguint_modular_rem_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == 0 and divisor != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}), a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and dividend != 0 and divisor == 0
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::zero();
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);

    // modulo >= 2 and dividend != 0 and divisor == multiple of modulo
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == 0
    let _a_biguint = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::zero();
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);

    // modulo >= 2 and dividend == 0 and divisor == multiple of modulo
    let _a_biguint = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == 0
    let _a_biguint = U256::from_uint(200_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::zero();
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);

    // modulo >= 2 and dividend == multiple of modulo and divisor == multiple of modulo
    let _a_biguint = U256::from_uint(200_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);

    // modulo == 0
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::zero();
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);

    // modulo == 1
    let _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = U256::from_uint(128_u8);
    let _modulo = U256::one();
    // It will panic!
    // _a_biguint.modular_rem_assign(&_divisor, &_modulo);
    println!("---------------------------");
}

fn biguint_panic_free_modular_rem()
{
    println!("biguint_panic_free_modular_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == 0 and divisor != 0
    let dividend = U256::zero();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo >= 2 and dividend == multiple of modulo and divisor != 0
    let dividend = U256::from_uint(200_u8);
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo >= 2 and dividend != 0 and divisor == 0    
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);
    
    // modulo >= 2 and dividend != 0 and divisor == multiple of modulo
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and dividend == 0 and divisor == multiple of modulo
    let dividend = U256::zero();
    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and dividend == multiple of modulo and divisor == 0
    let dividend = U256::from_uint(200_u8);
    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo >= 2 and dividend == multiple of modulo and divisor == multiple of modulo
    let dividend = U256::from_uint(200_u8);
    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo == 0 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = U256::zero();
    let modulo = U256::zero();
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and dividend == 0
    let dividend = U256::zero();
    let divisor = U256::zero();
    let modulo = U256::one();
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), true);

    // modulo == 0 and divisor != 0 and divisor != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::zero();
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // modulo == 1 and divisor != 0 and divisor != 0
    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(128_u8);
    let modulo = U256::one();
    let remainder = dividend.panic_free_modular_rem(&divisor, &modulo);
    println!("{} % {} = {} (mod {})", dividend, divisor, remainder, modulo);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), true);
    assert_eq!(remainder.is_divided_by_zero(), false);

    // collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let op1 = U256::zero();
        let op2 = U256::zero();
        let res = op1.panic_free_modular_rem(&op2, &modulo);
        println!("{} % {} = {} (mod {})", op1, op2, res, modulo);
        assert_eq!(res.to_string(), "0");
        assert_eq!(res.is_overflow(), false);
        assert_eq!(res.is_underflow(), false);
        assert_eq!(res.is_divided_by_zero(), true);
        assert_eq!(res.is_infinity(), false);
        assert_eq!(res.is_undefined(), true);
        
        for dividend in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let rhs = U256::zero();
            let res = dividend.panic_free_modular_rem(&rhs, &modulo);
            println!("{} % {} = {} (mod {})", dividend, rhs, res, modulo);
            assert_eq!(res.to_string(), "0");
            assert_eq!(res.is_overflow(), false);
            assert_eq!(res.is_underflow(), false);
            assert_eq!(res.is_divided_by_zero(), true);
            assert_eq!(res.is_infinity(), false);
            assert_eq!(res.is_undefined(), true);

            for divisor in [U256::from_uint(3_u8), U256::from_uint(50_u8)]
            {
                let res = dividend.panic_free_modular_rem(&divisor, &modulo);
                println!("{} % {} = {} (mod {})", dividend, divisor, res, modulo);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_rem_assign()
{
    println!("biguint_panic_free_modular_rem_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case
    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self == 0 and divisor != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(128_u8);
    let modulo = UU32::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign_uint({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self == multiple of modulo and divisor != 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(128_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo >= 2 and self != 0 and divisor == 0  
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self != 0 and divisor == multiple of modulo
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == 0 and divisor == multiple of modulo
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo >= 2 and self == multiple of modulo and divisor == multiple of modulo
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 0 and self != 0 and divisor != 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(128_u8);
    let modulo = U256::zero();
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 1 and self != 0 and divisor != 0
    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(128_u8);
    let modulo = U256::one();
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 0 and divisor == 0 and self == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::zero();
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // modulo == 1 and divisor == 0 and self == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::zero();
    let modulo = U256::one();
    a_biguint.panic_free_modular_rem_assign(&divisor, &modulo);
    println!("After a_biguint.modular_rem_assign({}, {}), a_biguint = {}", divisor, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    // Collectively
    for modulo in [U256::zero(), U256::one()]
    {
        let mut dividend = U256::zero();
        println!("Originally, op1 = {}", dividend);
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), false);
        assert_eq!(dividend.is_divided_by_zero(), false);

        let divisor = U256::zero();
        dividend.panic_free_modular_rem_assign(&divisor, &modulo);
        println!("After a_biguint.panic_free_modular_rem_assign({}, {}), op1 = {}", divisor, modulo, dividend);
        assert_eq!(dividend.to_string(), "0");
        assert_eq!(dividend.is_overflow(), false);
        assert_eq!(dividend.is_underflow(), false);
        assert_eq!(dividend.is_divided_by_zero(), true);
        assert_eq!(dividend.is_infinity(), false);
        assert_eq!(dividend.is_undefined(), true);
        
        for op in [U256::from_string("76801874298166903427690031858186486050853753882811946569946433649006").unwrap(), U256::from_uint(50_u8)]
        {
            let mut dividend = op.clone();
            println!("Originally, dividend = {}", dividend);
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_infinity(), false);
            assert_eq!(dividend.is_undefined(), false);
            assert_eq!(dividend.is_divided_by_zero(), false);

            let divisor = U256::zero();
            dividend.panic_free_modular_rem_assign(&divisor, &modulo);
            println!("After op1.panic_free_modular_rem_assign({}, {}), dividend = {}", divisor, modulo, dividend);
            assert_eq!(dividend.to_string(), "0");
            assert_eq!(dividend.is_overflow(), false);
            assert_eq!(dividend.is_underflow(), false);
            assert_eq!(dividend.is_divided_by_zero(), true);
            assert_eq!(dividend.is_infinity(), false);
            assert_eq!(dividend.is_undefined(), true);

            for divisor in [U256::from_uint(3_u8), U256::from_uint(50_u8)]
            {
                let mut dividend = op.clone();
                println!("Originally, dividend = {}", dividend);
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
    
                dividend.panic_free_modular_rem_assign(&divisor, &modulo);
                println!("After dividend.panic_free_modular_rem_assign({}, {}), dividend = {}", divisor, modulo, dividend);
                assert_eq!(dividend.to_string(), "0");
                assert_eq!(dividend.is_overflow(), false);
                assert_eq!(dividend.is_underflow(), false);
                assert_eq!(dividend.is_divided_by_zero(), false);
                assert_eq!(dividend.is_infinity(), false);
                assert_eq!(dividend.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}


fn biguint_next_multiple()
{
    biguint_next_multiple_of();
    biguint_next_multiple_of_assign();
    biguint_panic_free_next_multiple_of();
    biguint_panic_free_next_multiple_of_assign();
    biguint_modular_next_multiple_of();
    biguint_modular_next_multiple_of_assign();
    biguint_panic_free_modular_next_multiple_of();
    biguint_panic_free_modular_next_multiple_of_assign();
    biguint_is_multiple_of();
}

fn biguint_next_multiple_of()
{
    println!("biguint_next_multiple_of");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::from(586478_u32);
    let multiple = a_biguint.next_multiple_of(&num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    let a_biguint = U256::max();
    let num = U256::from(586478_u32);
    let multiple = a_biguint.next_multiple_of(&num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "448670");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = U256::zero();
    // It will panic.
    // let _multiple = _a_biguint.next_multiple_of(&_num);
    println!("---------------------------");
}

fn biguint_next_multiple_of_assign()
{
    println!("biguint_next_multiple_of_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = UU32::from(586478_u32);
    a_biguint.next_multiple_of_assign(&num);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = UU32::from(586478_u32);
    a_biguint.next_multiple_of_assign(&num);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "448670");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let _a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = UU32::zero();
    // It will panic.
    // _a_biguint.next_multiple_of_assign(&_num);
    println!("---------------------------");
}

fn biguint_panic_free_next_multiple_of()
{
    println!("biguint_panic_free_next_multiple_of");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::from(586478_u32);
    let multiple = a_biguint.panic_free_next_multiple_of(&num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    let a_biguint = U256::max();
    let num = U256::from(586478_u32);
    let multiple = a_biguint.panic_free_next_multiple_of(&num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "448670");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::zero();
    let multiple = a_biguint.panic_free_next_multiple_of(&num);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);
    println!("---------------------------");
}

fn biguint_panic_free_next_multiple_of_assign()
{
    println!("biguint_panic_free_next_multiple_of_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let num = UU32::from(586478_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_next_multiple_of_assign(&num);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123697594");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::max();
    let num = UU32::from(586478_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_next_multiple_of_assign(&num);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "448670");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let num = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.panic_free_next_multiple_of_assign(&num);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_modular_next_multiple_of()
{
    println!("biguint_modular_next_multiple_of");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // Normal case 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::max();
    let num = U256::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8); println!("modulo = {}", modulo);
    let multiple = a_biguint.modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "1");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // rhs == 0
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = U256::zero();
    let _modulo = a_biguint.wrapping_add_uint(200_u8);
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of(&_num, &_modulo);

    // rhs == multiple of modulo
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = U256::from(200_u8);
    let _modulo = U256::from(100_u8);
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of(&_num, &_modulo);

    // modulo == 0
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = U256::from(100_u8);
    let _modulo = U256::zero();
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of(&_num, &_modulo);

    // modulo == 1
    let _a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let _num = U256::from(100_u8);
    let _modulo = U256::one();
    // It will panic.
    // let multiple = _a_biguint.modular_next_multiple_of(&_num, &_modulo);
    println!("---------------------------");
}

fn biguint_modular_next_multiple_of_assign()
{
    println!("biguint_modular_next_multiple_of_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case 1
    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = UU32::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.modular_next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = UU32::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = UU32::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0
    let mut _a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _num = UU32::zero();
    let _modulo = _a_biguint.wrapping_add_uint(200_u8);
    // _a_biguint.modular_next_multiple_of_assign(&_num, &_modulo);

    // rhs == multiple of modulo
    let mut _a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _num = UU32::from(200_u8);
    let _modulo = UU32::from(100_u8);
    // _a_biguint.modular_next_multiple_of_assign(&_num, &_modulo);

    // modulo == 0
    let mut _a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _num = UU32::from(100_u8);
    let _modulo = UU32::zero();
    // _a_biguint.modular_next_multiple_of_assign(&_num, &_modulo);

    // modulo == 1
    let mut _a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _num = UU32::from(100_u8);
    let _modulo = UU32::one();
    // _a_biguint.modular_next_multiple_of_assign(&_num, &_modulo);
    println!("---------------------------");
}

fn biguint_panic_free_modular_next_multiple_of()
{
    println!("biguint_panic_free_modular_next_multiple_of");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // Normal case 2
    let a_biguint = U256::max();
    let num = U256::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "1");
    assert_eq!(multiple.is_overflow(), true);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), false);

    // rhs == 0
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::zero();
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // rhs == multiple of modulo
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::from(200_u8);
    let modulo = U256::from(100_u8);
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // modulo == 0
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::from(100_u8);
    let modulo = U256::zero();
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // modulo == 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::from(100_u8);
    let modulo = U256::one();
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // rhs == 0 and modulo == 0
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::zero();
    let modulo = U256::zero();
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);

    // rhs == 0 and modulo == 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let num = U256::zero();
    let modulo = U256::one();
    let multiple = a_biguint.panic_free_modular_next_multiple_of(&num, &modulo);
    println!("The next multiple of {} is {}", a_biguint, multiple);
    assert_eq!(multiple.to_string(), "0");
    assert_eq!(multiple.is_overflow(), false);
    assert_eq!(multiple.is_underflow(), false);
    assert_eq!(multiple.is_infinity(), false);
    assert_eq!(multiple.is_divided_by_zero(), false);
    assert_eq!(multiple.is_undefined(), true);
    println!("---------------------------");
}

fn biguint_panic_free_modular_next_multiple_of_assign()
{
    println!("biguint_panic_free_modular_next_multiple_of_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let mut a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = UU32::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.modular_next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789012345678901234567890123456800");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = UU32::from_str_radix("FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF_FFFFFFFF", 16).unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = UU32::from(100_u8);
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = U256::zero();
    let modulo = a_biguint.wrapping_add_uint(200_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == multiple of modulo
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = U256::from(200_u8);
    let modulo = U256::from(100_u8);
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = U256::from(100_u8);
    let modulo = U256::zero();
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // modulo == 1
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = U256::from(100_u8);
    let modulo = U256::one();
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0 and modulo == 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = U256::zero();
    let modulo = U256::zero();
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // rhs == 0 and modulo == 1
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let num = U256::zero();
    let modulo = U256::one();
    a_biguint.panic_free_modular_next_multiple_of_assign(&num, &modulo);
    println!("After a_biguint.next_multiple_of_assign({}), a_biguint = {}", num, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_multiple_of()
{
    println!("biguint_is_multiple_of()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Normal case 1
    let a_biguint = U256::from_str("12345678901234567890123456789012345678900").unwrap();
    let rhs = U256::from(100_u8);
    let ans = a_biguint.is_multiple_of(&rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, true);

    // Normal case 2
    let a_biguint = U256::from_str("12345678901234567890123456789012345678900").unwrap();
    let rhs = U256::from(99_u8);
    let ans = a_biguint.is_multiple_of(&rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, false);

    // rhs == 0 and self != 0
    let a_biguint = U256::from_str("12345678901234567890123456789012345678900").unwrap();
    let rhs = U256::zero();
    let ans = a_biguint.is_multiple_of(&rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, false);

    // rhs == 0 and self == 0
    let a_biguint = U256::zero();
    let rhs = U256::zero();
    let ans = a_biguint.is_multiple_of(&rhs);
    println!("Is {} the multiple of {}? -> {}", a_biguint, rhs, ans);
    assert_eq!(ans, true);
    println!("---------------------------");
}


fn biguint_exponentiation_logarithm_biguint_main()
{
    biguint_next_power_of_two();
    biguint_next_power_of_two_assign();
    biguint_is_power_of_two();

    biguint_pow();
    biguint_pow_assign();
    biguint_panic_free_pow();
    biguint_panic_free_pow_assign();
    biguint_wrapping_pow();
    biguint_wrapping_pow_assign();
    biguint_overflowing_pow();
    biguint_overflowing_pow_assign();
    biguint_checked_pow();
    biguint_unchecked_pow();
    biguint_saturating_pow();
    biguint_saturating_pow_assign();
    biguint_modular_pow();
    biguint_modular_pow_assign();
    biguint_panic_free_modular_pow();
    biguint_panic_free_modular_pow_assign();

    biguint_iroot();
    biguint_iroot_assign();
    biguint_panic_free_iroot();
    biguint_panic_free_iroot_assign();
    biguint_checked_iroot();
    biguint_unchecked_iroot();
    biguint_isqrt();
    biguint_isqrt_assign();

    biguint_ilog();
    biguint_ilog_assign();
    biguint_panic_free_ilog();
    biguint_panic_free_ilog_assign();
    biguint_checked_ilog();
    biguint_unchecked_ilog();

    biguint_ilog2();
    biguint_ilog2_assign();
    biguint_panic_free_ilog2();
    biguint_panic_free_ilog2_assign();
    biguint_checked_ilog2();
    biguint_unchecked_ilog2();

    biguint_ilog10();
    biguint_ilog10_assign();
    biguint_panic_free_ilog10();
    biguint_panic_free_ilog10_assign();
    biguint_checked_ilog10();
    biguint_unchecked_ilog10();
}

fn biguint_next_power_of_two()
{
    println!("biguint_next_power_of_two");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Normal case
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.next_power_of_two();
    println!("The next power of two is {}.", res);
    assert_eq!(res.to_string(), "170141183460469231731687303715884105728");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Maximum
    let a_biguint = U256::max();
    let res = a_biguint.next_power_of_two();
    println!("The next power of two is {}.", res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Minimum
    let a_biguint = U256::zero();
    let res = a_biguint.next_power_of_two();
    println!("The next power of two is {}.", res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_next_power_of_two_assign()
{
    println!("biguint_next_power_of_two_assign()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Normal case
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.next_power_of_two_assign();
    println!("After a_biguint.next_power_of_two_assign(), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "170141183460469231731687303715884105728");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Maximum
    let mut a_biguint = U256::max();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.next_power_of_two_assign();
    println!("After a_biguint.next_power_of_two_assign(), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Minimum
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    a_biguint.next_power_of_two_assign();
    println!("After a_biguint.next_power_of_two_assign(), a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_power_of_two()
{
    println!("biguint_is_power_of_two()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Normal case 1
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.is_power_of_two();
    println!("Is {} the power of two? - {}.", a_biguint, res);
    assert_eq!(res, false);

    // Normal case 2
    let a_biguint = U256::from_str("170141183460469231731687303715884105728").unwrap();
    let res = a_biguint.is_power_of_two();
    println!("Is {} the power of two? - {}.", a_biguint, res);
    assert_eq!(res, true);

    // Maximum
    let a_biguint = U256::max();
    let res = a_biguint.is_power_of_two();
    println!("Is {} the power of two? - {}.", a_biguint, res);
    assert_eq!(res, false);

    // Minimum
    let a_biguint = U256::zero();
    let res = a_biguint.is_power_of_two();
    println!("Is {} the power of two? - {}.", a_biguint, res);
    assert_eq!(res, true);
    println!("---------------------------");
}

fn biguint_pow()
{
    println!("biguint_pow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // normal exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let res = a_biguint.pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let res = a_biguint.pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = UU32::zero();
    let res = a_biguint.pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let a_biguint = UU32::zero();
    let exp = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Panic example
    let _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.pow(&_exp);
    println!("---------------------------");
}

fn biguint_pow_assign()
{
    println!("biguint_pow_assign()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // normal exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(30_u8);
    a_biguint.pow_assign(&exp);
    println!("After a_biguint.pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(100_u8);
    a_biguint.pow_assign(&exp);
    println!("After a_biguint.pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.pow_assign(&exp);
    println!("After a_biguint.pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_str("123456789012345678901234567890123456789").unwrap();
    a_biguint.pow_assign(&exp);
    println!("After a_biguint.pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic example
    let mut _a_biguint = U256::zero();
    let _exp = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic.
    // _a_biguint.pow_assign(&_exp);
    println!("---------------------------");
}

fn biguint_panic_free_pow()
{
    println!("biguint_panic_free_pow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // normal exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let res = a_biguint.panic_free_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let res = a_biguint.panic_free_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = UU32::zero();
    let res = a_biguint.panic_free_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let a_biguint = UU32::zero();
    let exp = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.panic_free_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 0
    let a_biguint = U256::zero();
    let exp = U256::zero();
    let res = a_biguint.panic_free_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_pow_assign()
{
    println!("biguint_panic_free_pow_assign()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // normal exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(30_u8);
    a_biguint.panic_free_pow_assign(&exp);
    println!("After a_biguint.panic_free_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(100_u8);
    a_biguint.panic_free_pow_assign(&exp);
    println!("After a_biguint.panic_free_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.panic_free_pow_assign(&exp);
    println!("After a_biguint.panic_free_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_str("123456789012345678901234567890123456789").unwrap();
    a_biguint.panic_free_pow_assign(&exp);
    println!("After a_biguint.panic_free_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic example
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.panic_free_pow_assign(&exp);
    println!("After a_biguint.panic_free_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(),  true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_wrapping_pow()
{
    println!("biguint_wrapping_pow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // normal exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let res = a_biguint.wrapping_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let res = a_biguint.wrapping_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = UU32::zero();
    let res = a_biguint.wrapping_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let a_biguint = UU32::zero();
    let exp = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.wrapping_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Panic example
    let _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.wrapping_pow(&_exp);
    println!("---------------------------");
}

fn biguint_wrapping_pow_assign()
{
    println!("biguint_wrapping_pow_assign()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // normal exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(30_u8);
    a_biguint.wrapping_pow_assign(&exp);
    println!("After a_biguint.wrapping_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(100_u8);
    a_biguint.wrapping_pow_assign(&exp);
    println!("After a_biguint.wrapping_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.wrapping_pow_assign(&exp);
    println!("After a_biguint.wrapping_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_str("123456789012345678901234567890123456789").unwrap();
    a_biguint.wrapping_pow_assign(&exp);
    println!("After a_biguint.wrapping_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic example
    let mut _a_biguint = U256::zero();
    let _exp = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic.
    // _a_biguint.wrapping_pow_assign(&_exp);
    println!("---------------------------");
}

fn biguint_overflowing_pow()
{
    println!("biguint_overflowing_pow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // normal exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let (res, overflow) = a_biguint.overflowing_pow(&exp);
    println!("{} ** {} = {}, {}", a_biguint, exp, res, overflow);
    assert_eq!(overflow, false);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let (res, overflow) = a_biguint.overflowing_pow(&exp);
    println!("{} ** {} = {}, {}", a_biguint, exp, res, overflow);
    assert_eq!(overflow, true);
    assert_eq!(res.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = UU32::zero();
    let (res, overflow) = a_biguint.overflowing_pow(&exp);
    println!("{} ** {} = {}, {}", a_biguint, exp, res, overflow);
    assert_eq!(overflow, false);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let a_biguint = UU32::zero();
    let exp = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let (res, overflow) = a_biguint.overflowing_pow(&exp);
    println!("{} ** {} = {}, {}", a_biguint, exp, res, overflow);
    assert_eq!(overflow, false);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Panic example
    let _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // let (res, overflow) = _a_biguint.overflowing_pow(&_exp);
    println!("---------------------------");
}

fn biguint_overflowing_pow_assign()
{
    println!("biguint_overflowing_pow_assign()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // normal exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(30_u8);
    let overflow = a_biguint.overflowing_pow_assign(&exp);
    println!("After a_biguint.overflowing_pow_assign({}), a_biguint = {}, {}", exp, a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(100_u8);
    let overflow = a_biguint.overflowing_pow_assign(&exp);
    println!("After a_biguint.overflowing_pow_assign({}), a_biguint = {}, {}", exp, a_biguint, overflow);
    assert_eq!(overflow, true);
    assert_eq!(a_biguint.to_string(), "60053020119642567005817971699943807522652027577520184704273238430174760927232");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    let overflow = a_biguint.overflowing_pow_assign(&exp);
    println!("After a_biguint.overflowing_pow_assign({}), a_biguint = {}, {}", exp, a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let overflow = a_biguint.overflowing_pow_assign(&exp);
    println!("After a_biguint.overflowing_pow_assign({}), a_biguint = {}, {}", exp, a_biguint, overflow);
    assert_eq!(overflow, false);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic example
    let mut _a_biguint = U256::zero();
    let _exp = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic.
    // let overflow = _a_biguint.overflowing_pow_assign(&_exp);
    println!("---------------------------");
}

fn biguint_checked_pow()
{
    println!("biguint_checked_pow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let res = a_biguint.checked_pow(&exp);
    match res
    {
        Some(raised) => {
                println!("{} ** {} = {}", a_biguint, exp, raised);
                assert_eq!(raised.to_string(), "1000000000000000000000000000000");
                assert_eq!(raised.is_overflow(), false);
                assert_eq!(raised.is_underflow(), false);
                assert_eq!(raised.is_infinity(), false);
                assert_eq!(raised.is_divided_by_zero(), false);
                assert_eq!(raised.is_undefined(), false);
            },
        None => { println!("Overflow"); }
    }

    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let res = a_biguint.checked_pow(&exp);
    match res
    {
        Some(raised) => { println!("{} ** {} = {}", a_biguint, exp, raised); },
        None => {
                println!("Overflow");
                assert_eq!(res, None);
            },
    }

    let a_biguint = UU32::zero();
    let exp = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.checked_pow(&exp);
    match res
    {
        Some(raised) => {
                println!("{} ** {} = {}", a_biguint, exp, raised);
                assert_eq!(raised.to_string(), "0");
                assert_eq!(raised.is_overflow(), false);
                assert_eq!(raised.is_underflow(), false);
                assert_eq!(raised.is_infinity(), false);
                assert_eq!(raised.is_divided_by_zero(), false);
                assert_eq!(raised.is_undefined(), false);
            },
        None => { println!("Overflow"); }
    }

    let a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = UU32::zero();
    let res = a_biguint.checked_pow(&exp);
    match res
    {
        Some(raised) => {
                println!("{} ** {} = {}", a_biguint, exp, raised);
                assert_eq!(raised.to_string(), "1");
                assert_eq!(raised.is_overflow(), false);
                assert_eq!(raised.is_underflow(), false);
                assert_eq!(raised.is_infinity(), false);
                assert_eq!(raised.is_divided_by_zero(), false);
                assert_eq!(raised.is_undefined(), false);
            },
        None => { println!("Overflow"); }
    }

    let a_biguint = UU32::zero();
    let exp = UU32::zero();
    let res = a_biguint.checked_pow(&exp);
    match res
    {
        Some(raised) => { println!("{} ** {} = {}", a_biguint, exp, raised); },
        None => {
                println!("Undefined");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_pow()
{
    println!("biguint_unchecked_pow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // normal exponentiation
    let a_biguint = U256::from_uint(10_u8);
    let exp = U256::from_uint(30_u8);
    let res = a_biguint.unchecked_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = U256::zero();
    let res = a_biguint.unchecked_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let a_biguint = U256::zero();
    let exp = U256::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.unchecked_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Panic examples
    let _a_biguint = U256::from_uint(10_u8);
    let _exp = U256::from_uint(100_u8);
    // It will panic.
    // let res = _a_biguint.unchecked_pow(&_exp);

    let _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_pow(&_exp);
    println!("---------------------------");
}

fn biguint_saturating_pow()
{
    println!("biguint_saturating_pow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // normal exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let res = a_biguint.saturating_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let res = a_biguint.saturating_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res, UU32::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let a_biguint = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let exp = UU32::zero();
    let res = a_biguint.saturating_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let a_biguint = UU32::zero();
    let exp = UU32::from_str("123456789012345678901234567890123456789").unwrap();
    let res = a_biguint.saturating_pow(&exp);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Panic example
    let _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.saturating_pow(&_exp);
    println!("---------------------------");
}

fn biguint_saturating_pow_assign()
{
    println!("biguint_saturating_pow_assign()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    
    // normal exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(30_u8);
    a_biguint.saturating_pow_assign(&exp);
    println!("After a_biguint.wrapping_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // wrapping (modular) exponentiation
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let exp = U256::from_uint(100_u8);
    a_biguint.saturating_pow_assign(&exp);
    println!("After a_biguint.saturating_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint, U256::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 123456789012345678901234567890123456789 ** 0
    let mut a_biguint = U256::from_str("123456789012345678901234567890123456789").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.saturating_pow_assign(&exp);
    println!("After a_biguint.saturating_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // 0 ** 123456789012345678901234567890123456789
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_str("123456789012345678901234567890123456789").unwrap();
    a_biguint.wrapping_pow_assign(&exp);
    println!("After a_biguint.saturating_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic example
    let mut _a_biguint = U256::zero();
    let _exp = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    // It will panic.
    // _a_biguint.saturating_pow_assign(&_exp);
    println!("---------------------------");
}

fn biguint_modular_pow()
{
    println!("biguint_modular_pow()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // Noraml case 1
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let modulo = UU32::halfmax();
    let res = a_biguint.modular_pow(&exp, &modulo);
    println!("{} ** {} (mod {}) = {}", a_biguint, exp, modulo, res);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Normal case 2
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let modulo = UU32::halfmax();
    let res = a_biguint.modular_pow(&exp, &modulo);
    println!("{} ** {} (mod {}) = {}", a_biguint, exp, modulo, res);
    assert_eq!(res.to_string(), "59749648429786538521694772865754025520");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::zero();
    let modulo = U256::halfmax();
    let res = a_biguint.modular_pow(&exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(200_u8);
    let modulo = UU32::from_uint(100_u8);
    let res = a_biguint.modular_pow(&exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let a_biguint = UU32::zero();
    let exp = UU32::from_uint(30_u8);
    let modulo = UU32::halfmax();
    let res = a_biguint.modular_pow(&exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let a_biguint = UU32::from_uint(300_u16);
    let exp = UU32::from_uint(30_u8);
    let modulo = U256::from_uint(100_u8);
    let res = a_biguint.modular_pow(&exp, &modulo);
    println!("{} ** {} = {}", a_biguint, exp, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let _a_biguint = UU32::zero();
    let _exp = UU32::zero();
    let _modulo = UU32::halfmax();
    // It will panic.
    // let res = _a_biguint.modular_pow(_exp, &_modulo);

    // self == 0 and exp == multiple of modulo and modulo != 0
    let _a_biguint = UU32::zero();
    let _exp = UU32::from_uint(200_u8);
    let _modulo = UU32::from_uint(100_u8);
    // It will panic.
    // let res = _a_biguint.modular_pow(&_exp, &_modulo);

    // self == multiple of modulo and exp == 0 and modulo != 0
    let _a_biguint = UU32::from_uint(300_u16);
    let _exp = UU32::zero();
    let _modulo = UU32::from_uint(100_u8);
    // It will panic.
    // let res = _a_biguint.modular_pow(&_exp, &_modulo);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let _a_biguint = UU32::from_uint(300_u16);
    let _exp = UU32::from_uint(200_u8);
    let _modulo = UU32::from_uint(100_u8);
    // It will panic.
    // let res = _a_biguint.modular_pow(&_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 0
    let _a_biguint = UU32::from_uint(10_u8);
    let _exp = UU32::from_uint(100_u8);
    let _modulo = UU32::zero();
    // It will panic!
    // let _res = a_biguint.modular_pow(&_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 1
    let _a_biguint = UU32::from_uint(10_u8);
    let _exp = UU32::from_uint(100_u8);
    let _modulo = UU32::one();
    // It will panic!
    // let _res = a_biguint.modular_pow(&_exp, &_modulo);

    // self == 0 and exp == 0 and modulo == 0
    let _a_biguint = UU32::zero();
    let _exp = UU32::zero();
    let _modulo = UU32::zero();
    // It will panic!
    // let _res = a_biguint.modular_pow(&_exp, &_modulo);
    println!("---------------------------");
}

fn biguint_modular_pow_assign()
{
    println!("biguint_modular_pow_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // Noraml case 1
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(30_u8);
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.modular_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = U256::from_uint(1000000000000000000000000000000_u128);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(100_u8);
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.modular_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "52266245075570873327294567809656160090");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.modular_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.modular_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(30_u8);
    let modulo = U256::halfmax();
    a_biguint.modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.modular_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let mut a_biguint = UU32::from_uint(300_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(30_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.modular_pow_assign({}), a_biguint = {}", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let mut _a_biguint = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _exp = U256::zero();
    let _modulo = U256::halfmax();
    // It will panic!
    // _a_biguint.modular_pow_assign(&_exp, &_modulo);

    // self == 0 and exp == multiple of modulo and modulo != 0
    let mut _a_biguint = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _exp = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_pow_assign(&_exp, &_modulo);

    // self == multiple of modulo and exp == 0 and modulo != 0
    let mut _a_biguint = U256::from_uint(300_u16);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _exp = U256::zero();
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_pow_assign(&_exp, &_modulo);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let mut _a_biguint = U256::from_uint(300_u16);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _exp = U256::from_uint(200_u8);
    let _modulo = U256::from_uint(100_u8);
    // It will panic!
    // _a_biguint.modular_pow_assign(&_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 0
    let mut _a_biguint = U256::from_uint(10_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _exp = U256::from_uint(100_u8);
    let _modulo = U256::zero();
    // It will panic!
    // _a_biguint.modular_pow_assign(&_exp, &_modulo);

    // self != 0 and exp != 0 and modulo == 1
    let _a_biguint = U256::from_uint(10_u8);
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    let _exp = U256::from_uint(100_u8);
    let _modulo = U256::one();
    // _a_biguint.modular_pow_assign(&_exp, &_modulo);

    // self == 0 and exp == 0 and modulo == 0
    let mut _a_biguint = U256::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _exp = U256::zero();
    let _modulo = U256::zero();
    // It will panic!
    // _a_biguint.modular_pow_assign(&_exp, &_modulo);
    println!("---------------------------");
}

fn biguint_panic_free_modular_pow()
{
    println!("biguint_panic_free_modular_pow()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // Noraml case 1
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(30_u8);
    let modulo = UU32::halfmax();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "1000000000000000000000000000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // Normal case 2
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let modulo = UU32::halfmax();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "59749648429786538521694772865754025520");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::zero();
    let modulo = UU32::halfmax();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(2000_u16);
    let modulo = UU32::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let a_biguint = UU32::zero();
    let exp = UU32::from_uint(30_u8);
    let modulo = UU32::halfmax();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let a_biguint = UU32::from_uint(3000_u16);
    let exp = UU32::from_uint(30_u8);
    let modulo = UU32::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let a_biguint = UU32::zero();
    let exp = UU32::zero();
    let modulo = UU32::halfmax();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == multiple of modulo and modulo != 0
    let a_biguint = UU32::zero();
    let exp = UU32::from_uint(2000_u16);
    let modulo = UU32::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp == 0 and modulo != 0
    let a_biguint = UU32::from_uint(3000_u16);
    let exp = UU32::zero();
    let modulo = UU32::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let a_biguint = UU32::from_uint(3000_u16);
    let exp = UU32::from_uint(2000_u16);
    let modulo = UU32::from_uint(1000_u16);
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 0
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let modulo = UU32::zero();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 1
    let a_biguint = UU32::from_uint(10_u8);
    let exp = UU32::from_uint(100_u8);
    let modulo = UU32::one();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo == 0
    let a_biguint = UU32::zero();
    let exp = UU32::zero();
    let modulo = UU32::zero();
    let res = a_biguint.panic_free_modular_pow(&exp, &modulo);
    println!("{} ** {} = {} (mod {})", a_biguint, exp, res, modulo);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    // collectively
    for modulo in [UU32::zero(), UU32::one()]
    {
        for lhs in [UU32::zero(), UU32::from_uint(50_u8)]
        {
            for rhs in [UU32::zero(), UU32::from_uint(50_u8)]
            {
                let res = lhs.panic_free_modular_pow(&rhs, &modulo);
                println!("{} ** {} = {} (mod {})", lhs, rhs, res, modulo);
                assert_eq!(res.to_string(), "0");
                assert_eq!(res.is_overflow(), false);
                assert_eq!(res.is_underflow(), false);
                assert_eq!(res.is_divided_by_zero(), false);
                assert_eq!(res.is_infinity(), false);
                assert_eq!(res.is_undefined(), true);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_panic_free_modular_pow_assign()
{
    println!("biguint_panic_free_modular_pow_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // Noraml case 1
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(30_u8);
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "1000000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Normal case 2
    let mut a_biguint = U256::from_uint(1000000000000000000000000000000_u128);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(100_u8);
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "52266245075570873327294567809656160090");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == 0 and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp == multiple of modulo and modulo != 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(200_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp != 0 and modulo != 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(30_u8);
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == multiple of modulo and exp != 0 and modulo != 0
    let mut a_biguint = U256::from_uint(300_u16);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(30_u8);
    let modulo = U256::from_uint(100_u8);
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo != 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    let modulo = U256::halfmax();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == multiple of modulo and exp == multiple of modulo and modulo != 0
    let mut a_biguint = U256::from_uint(200_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(150_u8);
    let modulo = U256::from_uint(50_u8);
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 0
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(100_u8);
    let modulo = U256::zero();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self != 0 and exp != 0 and modulo == 1
    let mut a_biguint = U256::from_uint(10_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(100_u8);
    let modulo = U256::one();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self == 0 and exp == 0 and modulo == 0
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    let modulo = U256::zero();
    a_biguint.panic_free_modular_pow_assign(&exp, &modulo);
    println!("After a_biguint.panic_free_modular_pow_assign_uint({}, {}), a_biguint = {}", exp, modulo, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // collectively
    for modulo in [U256::zero(), U256::one()]
    {
        for lhs in [U256::zero(), U256::from_uint(50_u8)]
        {
            for rhs in [U256::zero(), U256::from_uint(50_u8)]
            {
                let mut lhs = lhs.clone();
                println!("Originally, lhs = {}", lhs);
                assert_eq!(lhs.is_overflow(), false);
                assert_eq!(lhs.is_underflow(), false);
                assert_eq!(lhs.is_infinity(), false);
                assert_eq!(lhs.is_undefined(), false);
                assert_eq!(lhs.is_divided_by_zero(), false);

                lhs.panic_free_modular_pow_assign(&rhs, &modulo);
                println!("After lhs.panic_free_modular_pow_assign({}, {}), lhs = {}", rhs, modulo, lhs);
                assert_eq!(lhs.to_string(), "0");
                assert_eq!(lhs.is_overflow(), false);
                assert_eq!(lhs.is_underflow(), false);
                assert_eq!(lhs.is_infinity(), false);
                assert_eq!(lhs.is_undefined(), true);
                assert_eq!(lhs.is_divided_by_zero(), false);
            }
        }
    }
    println!("---------------------------");
}

fn biguint_iroot()
{
    println!("biguint_iroot");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(8_u8);
    let res = a_biguint.iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "100000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(65_u8);
    let res = a_biguint.iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "9");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(212_u8);
    let res = a_biguint.iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(213_u8);
    let res = a_biguint.iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(u128::MAX).wrapping_add_uint(1_u8);
    let res = a_biguint.iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = U256::from_uint(6_u8);
    let res = a_biguint.iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.iroot(&_exp);

    let _a_biguint = U256::one();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.iroot(&_exp);

    let _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.iroot(&_exp);
    println!("---------------------------");
}

fn biguint_iroot_assign()
{
    println!("biguint_iroot_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(8_u8);
    a_biguint.iroot_assign(&exp);
    println!("After a_biguint.iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "100000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(65_u8);
    a_biguint.iroot_assign(&exp);
    println!("After a_biguint.iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "9");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(212_u8);
    a_biguint.iroot_assign(&exp);
    println!("After a_biguint.iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(213_u8);
    a_biguint.iroot_assign(&exp);
    println!("After a_biguint.iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(u128::MAX).wrapping_add_uint(1_u8);
    a_biguint.iroot_assign(&exp);
    println!("After a_biguint.iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(6_u8);
    a_biguint.iroot_assign(&exp);
    println!("After a_biguint.iroot_assign_uint({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _exp = U256::zero();
    // It will panic.
    // _a_biguint.iroot_assign(&_exp);

    let mut _a_biguint = U256::one();
    let _exp = U256::zero();
    // It will panic.
    // _a_biguint.iroot_assign(&_exp);

    let mut _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // _a_biguint.iroot_assign(&_exp);
    println!("---------------------------");
}

fn biguint_panic_free_iroot()
{
    println!("biguint_panic_free_iroot");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(8_u8);
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "100000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(65_u8);
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "9");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(212_u8);
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(213_u8);
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(u128::MAX).wrapping_add_uint(1_u8);
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = U256::from_uint(6_u8);
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::zero();
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res, U256::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), true);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let exp = U256::zero();
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = U256::zero();
    let res = a_biguint.panic_free_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_iroot_assign()
{
    println!("biguint_panic_free_iroot_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(8_u8);
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "100000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(65_u8);
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "9");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(212_u8);
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(213_u8);
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(u128::MAX).wrapping_add_uint(1_u8);
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::from_uint(6_u8);
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint, U256::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let exp = U256::zero();
    a_biguint.panic_free_iroot_assign(&exp);
    println!("After a_biguint.panic_free_iroot_assign({}), a_biguint = {}.", exp, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_checked_iroot()
{
    println!("biguint_checked_iroot");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(8_u8);
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => {
                println!("The {}-th root of {} is {}.", exp, a_biguint, r);
                assert_eq!(r.to_string(), "100000000");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(65_u8);
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => {
                println!("The {}-th root of {} is {}.", exp, a_biguint, r);
                assert_eq!(r.to_string(), "9");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(212_u8);
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => {
                println!("The {}-th root of {} is {}.", exp, a_biguint, r);
                assert_eq!(r.to_string(), "2");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(213_u8);
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => {
                println!("The {}-th root of {} is {}.", exp, a_biguint, r);
                assert_eq!(r.to_string(), "1");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(u128::MAX).wrapping_add_uint(1_u8);
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => {
                println!("The {}-th root of {} is {}.", exp, a_biguint, r);
                assert_eq!(r.to_string(), "1");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); }
    }

    let a_biguint = U256::zero();
    let exp = U256::from_uint(6_u8);
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => {
                println!("The {}-th root of {} is {}.", exp, a_biguint, r);
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::zero();
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => { println!("The {}-th root of {} is {}.", exp, a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::one();
    let exp = U256::zero();
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => { println!("The {}-th root of {} is {}.", exp, a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let exp = U256::zero();
    let res = a_biguint.checked_iroot(&exp);
    match res
    {
        Some(r) => { println!("The {}-th root of {} is {}.", exp, a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_iroot()
{
    println!("biguint_unchecked_iroot");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(8_u8);
    let res = a_biguint.unchecked_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "100000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(65_u8);
    let res = a_biguint.unchecked_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "9");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(212_u8);
    let res = a_biguint.unchecked_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(213_u8);
    let res = a_biguint.unchecked_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let exp = U256::from_uint(u128::MAX).wrapping_add_uint(1_u8);
    let res = a_biguint.unchecked_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let exp = U256::from_uint(6_u8);
    let res = a_biguint.unchecked_iroot(&exp);
    println!("The {}-th root of {} is {}.", exp, a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_iroot(&_exp);

    let _a_biguint = U256::one();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_iroot(&_exp);

    let _a_biguint = U256::zero();
    let _exp = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_iroot(&_exp);
    println!("---------------------------");
}


fn biguint_isqrt()
{
    println!("biguint_isqrt");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let res = a_biguint.isqrt();
    println!("The square root of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string_with_radix_and_stride(10, 4).unwrap(), "1_0000_0000_0000_0000_0000_0000_0000_0000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.isqrt();
    println!("The second root of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_isqrt_assign()
{
    println!("biguint_isqrt_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.isqrt_assign();
    println!("After a_biguint.isqrt_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string_with_radix_and_stride(10, 4).unwrap(), "1_0000_0000_0000_0000_0000_0000_0000_0000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.isqrt_assign();
    println!("After a_biguint.isqrt_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_ilog()
{
    println!("biguint_ilog");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(1_0000_0000_0000_0000_0000_0000_0000_0000_u128);
    let res = a_biguint.ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(10_u8);
    let res = a_biguint.ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "64");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = U256::from_uint(6_u8);
    let res = a_biguint.ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog_uint(_base);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.ilog(&_base);

    let _a_biguint = U256::zero();
    let _base = U256::from_uint(6_u8);
    // It will panic.
    // let res = _a_biguint.ilog(&_base);

    let _a_biguint = U256::zero();
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog(&_base);

    let _a_biguint = U256::zero();
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.ilog(&_base);

    let _a_biguint = U256::one();
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog(&_base);

    let _a_biguint = U256::one();
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.ilog(&_base);
    println!("---------------------------");
}

fn biguint_ilog_assign()
{
    println!("biguint_ilog_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::from_uint(1_0000_0000_0000_0000_0000_0000_0000_0000_u128);
    a_biguint.ilog_assign(&base);
    println!("After a_biguint.ilog_assign({}), a_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::from_uint(10_u8);
    a_biguint.ilog_assign(&base);
    println!("After a_biguint.ilog_assign({}), a_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "64");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::from_uint(6_u8);
    a_biguint.ilog_assign(&base);
    println!("After a_biguint.ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();

    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog_assign(&_base);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.ilog_assign(&_base);

    let _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = U256::from_uint(6_u8);
    // It will panic.
    // let res = _a_biguint.ilog_assign(&_base);

    let _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog_assign(&_base);

    let _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.ilog_assign(&_base);

    let _a_biguint = U256::one();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog_assign(&_base);

    let _a_biguint = U256::one();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.ilog_assign(&_base);
    println!("---------------------------");
}

fn biguint_panic_free_ilog()
{
    println!("biguint_panic_free_ilog");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(1_0000_0000_0000_0000_0000_0000_0000_0000_u128);
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(10_u8);
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "64");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = U256::from_uint(6_u8);
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::zero();
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res, U256::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), true);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::one();
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res, U256::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), true);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let base = U256::from_uint(6_u8);
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let base = U256::zero();
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let base = U256::one();
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = U256::zero();
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = U256::one();
    let res = a_biguint.panic_free_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_ilog_assign()
{
    println!("biguint_panic_free_ilog_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::from_uint(1_0000_0000_0000_0000_0000_0000_0000_0000_u128);
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "2");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::from_uint(10_u8);
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "64");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::from_uint(6_u8);
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::zero();
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint, U256::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::one();
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint, U256::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::from_uint(6_u8);
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::zero();
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::one();
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::zero();
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let base = U256::one();
    a_biguint.panic_free_ilog_assign(&base);
    println!("After a_biguint.panic_free_ilog_assign({}),\na_biguint = {}.", base, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_checked_ilog()
{
    println!("biguint_checked_ilog");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(1_0000_0000_0000_0000_0000_0000_0000_0000_u128);
    let res = a_biguint.checked_ilog(&base);
    match res
    {
        Some(r) => {
                println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r);
                assert_eq!(r.to_string(), "2");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(10_u8);
    let res = a_biguint.checked_ilog(&base);
    match res
    {
        Some(r) => {
                println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r);
                assert_eq!(r.to_string(), "64");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::one();
    let base = U256::from_uint(6_u8);
    let res = a_biguint.checked_ilog(&base);
    match res
    {
        Some(r) => {
                println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r);
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::zero();
    let res = a_biguint.checked_ilog(&base);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::one();
    let res = a_biguint.checked_ilog(&base);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let base = U256::from_uint(6_u8);
    let res = a_biguint.checked_ilog(&base);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let base = U256::zero();
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }

    let a_biguint = U256::zero();
    let base = U256::one();
    let res = a_biguint.checked_ilog(&base);
    match res
    {
        Some(r) => { println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_ilog()
{
    println!("biguint_unchecked_ilog");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(1_0000_0000_0000_0000_0000_0000_0000_0000_u128);
    let res = a_biguint.unchecked_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "2");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let base = U256::from_uint(10_u8);
    let res = a_biguint.unchecked_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "64");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let base = U256::from_uint(6_u8);
    let res = a_biguint.unchecked_ilog(&base);
    println!("The logarithm of {} with respect to {} is {}.", a_biguint, base, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_ilog(&_base);

    let _a_biguint = U256::from_str("1_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000").unwrap();
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.unchecked_ilog(&_base);

    let _a_biguint = U256::zero();
    let _base = U256::from_uint(6_u8);
    // It will panic.
    // let res = _a_biguint.unchecked_ilog(&_base);

    let _a_biguint = U256::zero();
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_ilog(&_base);

    let _a_biguint = U256::zero();
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.unchecked_ilog(&_base);

    let _a_biguint = U256::one();
    let _base = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_ilog(&_base);

    let _a_biguint = U256::one();
    let _base = U256::one();
    // It will panic.
    // let res = _a_biguint.unchecked_ilog(&_base);
    println!("---------------------------");
}

fn biguint_ilog2()
{
    println!("biguint_ilog2");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_uint(64_u8);
    let res = a_biguint.ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_uint(70_u8);
    let res = a_biguint.ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let res = a_biguint.ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog2();
    println!("---------------------------");
}

fn biguint_ilog2_assign()
{
    println!("biguint_ilog2_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_uint(64_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.ilog2_assign();
    println!("After a_biguint.ilog2_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(70_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.ilog2_assign();
    println!("After a_biguint.ilog2_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.ilog2_assign();
    println!("After a_biguint.ilog2_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let _a_biguint = U256::zero();
    // It will panic.
    // _a_biguint.ilog2_assign();
    println!("---------------------------");
}

fn biguint_panic_free_ilog2()
{
    println!("biguint_panic_free_ilog2");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_uint(64_u8);
    let res = a_biguint.panic_free_ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_uint(70_u8);
    let res = a_biguint.panic_free_ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let res = a_biguint.panic_free_ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.panic_free_ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_ilog2_assign()
{
    println!("biguint_panic_free_ilog2_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_uint(64_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog2_assign();
    println!("After a_biguint.panic_free_ilog2_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(70_u8);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog2_assign();
    println!("After a_biguint.panic_free_ilog2_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "6");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog2_assign();
    println!("After a_biguint.panic_free_ilog2_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog2_assign();
    println!("After a_biguint.panic_free_ilog2_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_checked_ilog2()
{
    println!("biguint_checked_ilog2");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let a_biguint = U256::from_uint(64_u8);
    let res = a_biguint.checked_ilog2();
    match res
    {
        Some(r) => {
                println!("The base 2 logarithm of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "6");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_uint(70_u8);
    let res = a_biguint.checked_ilog2();
    match res
    {
        Some(r) => {
                println!("The base 2 logarithm of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "6");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::one();
    let res = a_biguint.checked_ilog2();
    match res
    {
        Some(r) => {
                println!("The base 2 logarithm of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::zero();
    let res = a_biguint.checked_ilog_uint(1_u8);
    match res
    {
        Some(r) => { println!("The base 2 logarithm of {}is {}.", a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_ilog2()
{
    println!("biguint_unchecked_ilog2");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_uint(64_u8);
    let res = a_biguint.ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_uint(70_u8);
    let res = a_biguint.ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "6");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let res = a_biguint.ilog2();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog2();
    println!("---------------------------");
}

fn biguint_ilog10()
{
    println!("biguint_ilog10");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_uint(10000_u32);
    let res = a_biguint.ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "4");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_uint(12345_u32);
    let res = a_biguint.ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "4");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let res = a_biguint.ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let _a_biguint = U256::zero();
    // It will panic.
    // let res = _a_biguint.ilog10();
    println!("---------------------------");
}

fn biguint_ilog10_assign()
{
    println!("biguint_ilog10_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_uint(10000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.ilog10_assign();
    println!("After a_biguint.ilog10_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(12345_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.ilog10_assign();
    println!("After a_biguint.ilog10_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.ilog10_assign();
    println!("After a_biguint.ilog10_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let _a_biguint = U256::zero();
    // It will panic.
    // _a_biguint.ilog10_assign();
    println!("---------------------------");
}

fn biguint_panic_free_ilog10()
{
    println!("biguint_panic_free_ilog10");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_uint(10000_u32);
    let res = a_biguint.panic_free_ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "4");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_uint(12345_u32);
    let res = a_biguint.panic_free_ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "4");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let res = a_biguint.panic_free_ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.panic_free_ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), true);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_ilog10_assign()
{
    println!("biguint_panic_free_ilog10_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_uint(10000_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog10_assign();
    println!("After a_biguint.panic_free_ilog10_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_uint(12345_u32);
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog10_assign();
    println!("After a_biguint.panic_free_ilog10_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog10_assign();
    println!("After a_biguint.panic_free_ilog10_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.panic_free_ilog10_assign();
    println!("After a_biguint.panic_free_ilog10_assign(),\na_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_checked_ilog10()
{
    println!("biguint_checked_ilog10");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);
    
    let a_biguint = U256::from_uint(10000_u32);
    let res = a_biguint.checked_ilog10();
    match res
    {
        Some(r) => {
                println!("The base 10 logarithm of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "4");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::from_uint(12345_u32);
    let res = a_biguint.checked_ilog10();
    match res
    {
        Some(r) => {
                println!("The base 10 logarithm of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "4");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::one();
    let res = a_biguint.checked_ilog10();
    match res
    {
        Some(r) => {
                println!("The base 10 logarithm of {} is {}.", a_biguint, r);
                assert_eq!(r.to_string(), "0");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
            },
        None => { println!("Error"); },
    }

    let a_biguint = U256::zero();
    let res = a_biguint.checked_ilog10();
    match res
    {
        Some(r) => { println!("The 10 logarithm of {} is {}.", a_biguint, r); },
        None => {
                println!("Error");
                assert_eq!(res, None);
            },
    }
    println!("---------------------------");
}

fn biguint_unchecked_ilog10()
{
    println!("biguint_unchecked_ilog10");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_uint(10000_u32);
    let res = a_biguint.unchecked_ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_uint(12345_u32);
    let res = a_biguint.unchecked_ilog10();
    println!("The base 10 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "4");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::one();
    let res = a_biguint.unchecked_ilog10();
    println!("The base 2 logarithm of {} is {}.", a_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let _a_biguint = U256::zero();
    // It will panic.
    // let res = _a_biguint.unchecked_ilog10();
    println!("---------------------------");
}

fn biguint_miscellaneous_arithmatic_operation_main()
{
    biguint_midpoint();
    biguint_midpoint_assign();
    biguint_gcd();
    biguint_gcd_assign();
    biguint_panic_free_gcd();
    biguint_panic_free_gcd_assign();
    biguint_lcm();
    biguint_lcm_assign();
    biguint_panic_free_lcm();
    biguint_panic_free_lcm_assign();
    biguint_is_prime_using_miller_rabin();
}

fn biguint_midpoint()
{
    println!("biguint_midpoint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // normal case
    let a_biguint = U256::from_string("88888666664444422222111112222233333444445555566666777778888899999").unwrap();
    let b_biguint = U256::from_string("999998888877777666665555544444333332222211111").unwrap();
    let c_biguint = a_biguint.midpoint(&b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "44444333332222211111555555555555555555555555555555555555555555555");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is even number
    let a_biguint = U256::from_string("888886666644444222221111122222333334444455555666667777788888").unwrap();
    let b_biguint = U256::from_string("888887777766666555554444433333222221111100000").unwrap();
    let c_biguint = a_biguint.midpoint(&b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "444443333322222555554444444444444444444444444444444444444444");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is odd number
    let a_biguint = U256::from_string("888886666644444222221111122222333334444455555666667777788888").unwrap();
    let b_biguint = U256::from_string("888887777766666555554444433333222221111100001").unwrap();
    let c_biguint = a_biguint.midpoint(&b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "444443333322222555554444444444444444444444444444444444444444");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is even number
    let a_biguint = U256::from_string("88888666664444422222111112222233333444445555566666777778888899999").unwrap();
    let b_biguint = U256::from_string("99999888887777766666555554444433333222221111100000").unwrap();
    let c_biguint = a_biguint.midpoint(&b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "44444333332222261110999999999999999999999999999999999999999999999");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is odd number
    let a_biguint = U256::from_string("88888666664444422222111112222233333444445555566666777778888899999").unwrap();
    let b_biguint = U256::from_string("22222444446666688888999998888877777666665555544444333332222211111").unwrap();
    let c_biguint = a_biguint.midpoint(&b_biguint);
    println!("The middle point of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "55555555555555555555555555555555555555555555555555555555555555555");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_midpoint_assign()
{
    println!("biguint_midpoint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // normal case
    let mut a_biguint = U256::from_string("88888666664444422222111112222233333444445555566666777778888899999").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("999998888877777666665555544444333332222211111").unwrap();
    a_biguint.midpoint_assign(&b_biguint);
    println!("After a_biguint.midpoint_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "44444333332222211111555555555555555555555555555555555555555555555");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is even number
    let mut a_biguint = U256::from_string("888886666644444222221111122222333334444455555666667777788888").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("888887777766666555554444433333222221111100000").unwrap();
    a_biguint.midpoint_assign(&b_biguint);
    println!("After a_biguint.midpoint_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "444443333322222555554444444444444444444444444444444444444444");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is even number and rhs is odd number
    let mut a_biguint = U256::from_string("888886666644444222221111122222333334444455555666667777788888").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("888887777766666555554444433333222221111100001").unwrap();
    a_biguint.midpoint_assign(&b_biguint);
    println!("After a_biguint.midpoint_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "444443333322222555554444444444444444444444444444444444444444");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is even number
    let mut a_biguint = U256::from_string("88888666664444422222111112222233333444445555566666777778888899999").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("99999888887777766666555554444433333222221111100000").unwrap();
    a_biguint.midpoint_assign(&b_biguint);
    println!("After a_biguint.midpoint_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "44444333332222261110999999999999999999999999999999999999999999999");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // case that self is odd number and rhs is odd number
    let mut a_biguint = U256::from_string("88888666664444422222111112222233333444445555566666777778888899999").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("22222444446666688888999998888877777666665555544444333332222211111").unwrap();
    a_biguint.midpoint_assign(&b_biguint);
    println!("After a_biguint.midpoint_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "55555555555555555555555555555555555555555555555555555555555555555");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_gcd()
{
    println!("biguint_gcd()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // normal case
    let a_biguint = U256::from_string("12345678911111222223333344444555556666677777888889999900000").unwrap();
    let b_biguint = U256::from_string("99999888887777766666555554444433333222221111100000123456789").unwrap();
    let c_biguint = a_biguint.gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "27");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    let c_biguint = a_biguint.gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999000001111122222333334444455555666667777788888999990000011111222223333344444555556666677777888889999900000").unwrap();
    let c_biguint = a_biguint.gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("999998888877777666665555544444333332222211111000009999988888777776666655555444443333322222111110000099999888887777766666555554444433333222221111100000").unwrap();
    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    let c_biguint = a_biguint.gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    let c_biguint = a_biguint.gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "111112222233333444445555566666777778888899999111112222233333444445555566666");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    let c_biguint = a_biguint.gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U256::from_uint(2_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(7_u8).pow_uint(63_u8));
    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // let b_biguint = U256::from_uint(3_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(5_u8).pow_uint(42_u8)).wrapping_mul(&U256::from_uint(11_u8).pow_uint(11_u8));
    let c_biguint = a_biguint.gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let _a_biguint = U256::zero();
    let _b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // It will panic!
    // let c_biguint = _a_biguint.gcd(&_b_biguint);

    let _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = U256::zero();
    // It will panic!
    // let c_biguint = _a_biguint.gcd(&_b_biguint);

    let _a_biguint = U256::zero();
    let _b_biguint = U256::zero();
    // It will panic!
    // let c_biguint = _a_biguint.gcd(&_b_biguint);
    println!("---------------------------");
}

fn biguint_gcd_assign()
{
    println!("biguint_gcd_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // normal case
    let mut a_biguint = U256::from_string("12345678911111222223333344444555556666677777888889999900000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("99999888887777766666555554444433333222221111100000123456789").unwrap();
    a_biguint.gcd_assign(&b_biguint);
    println!("After a_biguint.gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "27");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    a_biguint.gcd_assign(&b_biguint);
    println!("After a_biguint.gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999000001111122222333334444455555666667777788888999990000011111222223333344444555556666677777888889999900000").unwrap();
    a_biguint.gcd_assign(&b_biguint);
    println!("After a_biguint.gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("999998888877777666665555544444333332222211111000009999988888777776666655555444443333322222111110000099999888887777766666555554444433333222221111100000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    a_biguint.gcd_assign(&b_biguint);
    println!("After a_biguint.gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    a_biguint.gcd_assign(&b_biguint);
    println!("After a_biguint.gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "111112222233333444445555566666777778888899999111112222233333444445555566666");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    a_biguint.gcd_assign(&b_biguint);
    println!("After a_biguint.gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U256::from_uint(2_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(7_u8).pow_uint(63_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // let b_biguint = U256::from_uint(3_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(5_u8).pow_uint(42_u8)).wrapping_mul(&U256::from_uint(11_u8).pow_uint(11_u8));
    a_biguint.gcd_assign(&b_biguint);
    println!("After a_biguint.gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let mut _a_biguint = U256::zero();
    let _b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // It will panic!
    // _a_biguint.gcd_assign(&_b_biguint);

    let mut _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = U256::zero();
    // It will panic!
    // _a_biguint.gcd_assign(&_b_biguint);

    let mut _a_biguint = U256::zero();
    let _b_biguint = U256::zero();
    // It will panic!
    // _a_biguint.gcd_assign(&_b_biguint);
    println!("---------------------------");
}

fn biguint_panic_free_gcd()
{
    println!("biguint_panic_free_gcd()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // normal case
    let a_biguint = U256::from_string("12345678911111222223333344444555556666677777888889999900000").unwrap();
    let b_biguint = U256::from_string("99999888887777766666555554444433333222221111100000123456789").unwrap();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "27");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999000001111122222333334444455555666667777788888999990000011111222223333344444555556666677777888889999900000").unwrap();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("999998888877777666665555544444333332222211111000009999988888777776666655555444443333322222111110000099999888887777766666555554444433333222221111100000").unwrap();
    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "111112222233333444445555566666777778888899999111112222233333444445555566666");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U256::from_uint(2_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(7_u8).pow_uint(63_u8));
    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // let b_biguint = U256::from_uint(3_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(5_u8).pow_uint(42_u8)).wrapping_mul(&U256::from_uint(11_u8).pow_uint(11_u8));
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "1");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let a_biguint = U256::zero();
    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // non-zero and zero
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and zero
    let a_biguint = U256::zero();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.panic_free_gcd(&b_biguint);
    println!("The greatest common divisor of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_gcd_assign()
{
    println!("biguint_panic_free_gcd_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // normal case
    let mut a_biguint = U256::from_string("12345678911111222223333344444555556666677777888889999900000").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("99999888887777766666555554444433333222221111100000123456789").unwrap();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "27");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999000001111122222333334444455555666667777788888999990000011111222223333344444555556666677777888889999900000").unwrap();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("999998888877777666665555544444333332222211111000009999988888777776666655555444443333322222111110000099999888887777766666555554444433333222221111100000").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("8438991675438218095037710712144663668370976580551057770447200309276357957168036900503577855298223571234349459464291898319535238059076166186474530555556137").unwrap();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999111112222233333444445555566666").unwrap();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "111112222233333444445555566666777778888899999111112222233333444445555566666");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    // let a_biguint = U256::from_uint(2_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(7_u8).pow_uint(63_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // let b_biguint = U256::from_uint(3_u8).pow_uint(72_u8).wrapping_mul(&U256::from_uint(5_u8).pow_uint(42_u8)).wrapping_mul(&U256::from_uint(11_u8).pow_uint(11_u8));
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // non-zero and zero
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint.panic_free_gcd_assign(&b_biguint);
    println!("After a_biguint.panic_free_gcd_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_lcm()
{
    println!("biguint_lcm()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    // normal case
    let a_biguint = U256::from_string("11111222223333344444555556666677777").unwrap();
    let b_biguint = U256::from_string("77777666665555544444333332222211111").unwrap();
    let c_biguint = a_biguint.lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "77779222242222466669444474444755552444414444166664222202222077777");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    let c_biguint = a_biguint.lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "496760330648797086669060276530363892567042647622050102007522050937573974925310180061832952383308835602422640469199738486829665946972839212975403672017049");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999").unwrap();
    let c_biguint = a_biguint.lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "8274803816077825844928633065239507977211631334803000112653099668890202006953504399616683910703926797255292819444704102663");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    let c_biguint = a_biguint.lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "5188071408782660471579036145752463281986051988336775031832198742768814408395807276440197274193933124374007024568944703694");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    let c_biguint = a_biguint.lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "111112222233333444445555566666777778888899999");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = U512::from_string("787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807").unwrap();
    // let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    let c_biguint = a_biguint.lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U512::from_string("10842241695257098749029584685234126848").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    let b_biguint = U512::from_string("4502551836747118353130482137203216552734375").unwrap();
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    let c_biguint = a_biguint.lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "48817755259436040224079590140222715578041897690278400000000000000000000000000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let _a_biguint = U256::zero();
    let _b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // It will panic!
    // let c_biguint = _a_biguint.lcm(&_b_biguint);

    let _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = U256::zero();
    // It will panic!
    // let c_biguint = _a_biguint.lcm(&_b_biguint);

    let _a_biguint = U256::zero();
    let _b_biguint = U256::zero();
    // It will panic!
    // let c_biguint = _a_biguint.lcm(&_b_biguint);
    println!("---------------------------");
}

fn biguint_lcm_assign()
{
    println!("biguint_lcm_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    // normal case
    let mut a_biguint = U256::from_string("11111222223333344444555556666677777").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("77777666665555544444333332222211111").unwrap();
    a_biguint.lcm_assign(&b_biguint);
    println!("After a_biguint.lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "77779222242222466669444474444755552444414444166664222202222077777");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    a_biguint.lcm_assign(&b_biguint);
    println!("After a_biguint.lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "496760330648797086669060276530363892567042647622050102007522050937573974925310180061832952383308835602422640469199738486829665946972839212975403672017049");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999").unwrap();
    a_biguint.lcm_assign(&b_biguint);
    println!("After a_biguint.lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "8274803816077825844928633065239507977211631334803000112653099668890202006953504399616683910703926797255292819444704102663");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    a_biguint.lcm_assign(&b_biguint);
    println!("After a_biguint.lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "5188071408782660471579036145752463281986051988336775031832198742768814408395807276440197274193933124374007024568944703694");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    a_biguint.lcm_assign(&b_biguint);
    println!("After a_biguint.lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "111112222233333444445555566666777778888899999");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807").unwrap();
    // let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    a_biguint.lcm_assign(&b_biguint);
    println!("After a_biguint.lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U512::from_string("10842241695257098749029584685234126848").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("4502551836747118353130482137203216552734375").unwrap();
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    a_biguint.lcm_assign(&b_biguint);
    println!("After a_biguint.lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "48817755259436040224079590140222715578041897690278400000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Panic Examples
    let mut _a_biguint = U256::zero();
    let _b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    // It will panic!
    // _a_biguint.lcm_assign(&_b_biguint);

    let mut _a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let _b_biguint = U256::zero();
    // It will panic!
    // _a_biguint.lcm_assign(&_b_biguint);

    let mut _a_biguint = U256::zero();
    let _b_biguint = U256::zero();
    // It will panic!
    // _a_biguint.lcm_assign(&_b_biguint);
    println!("---------------------------");
}

fn biguint_panic_free_lcm()
{
    println!("biguint_panic_free_lcm()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    // normal case
    let a_biguint = U256::from_string("11111222223333344444555556666677777").unwrap();
    let b_biguint = U256::from_string("77777666665555544444333332222211111").unwrap();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "77779222242222466669444474444755552444414444166664222202222077777");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "496760330648797086669060276530363892567042647622050102007522050937573974925310180061832952383308835602422640469199738486829665946972839212975403672017049");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999").unwrap();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "8274803816077825844928633065239507977211631334803000112653099668890202006953504399616683910703926797255292819444704102663");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "5188071408782660471579036145752463281986051988336775031832198742768814408395807276440197274193933124374007024568944703694");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // Same numbers
    let a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "111112222233333444445555566666777778888899999");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b_biguint = U512::from_string("787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807").unwrap();
    // let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let a_biguint = U512::from_string("10842241695257098749029584685234126848").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    let b_biguint = U512::from_string("4502551836747118353130482137203216552734375").unwrap();
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "48817755259436040224079590140222715578041897690278400000000000000000000000000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let a_biguint = U256::zero();
    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // non-zero and zero
    let a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    // zero and zero
    let a_biguint = U256::zero();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.panic_free_lcm(&b_biguint);
    println!("The least common multiple of {} and {} is {}.", a_biguint, b_biguint, c_biguint);
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), true);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_panic_free_lcm_assign()
{
    println!("biguint_panic_free_lcm_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    // normal case
    let mut a_biguint = U256::from_string("11111222223333344444555556666677777").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("77777666665555544444333332222211111").unwrap();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "77779222242222466669444474444755552444414444166664222202222077777");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Two prime numbers
    let mut a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "496760330648797086669060276530363892567042647622050102007522050937573974925310180061832952383308835602422640469199738486829665946972839212975403672017049");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a prime number and other is a composite number
    let mut a_biguint = U512::from_string("74472489612356985600031654010179700239186733711125062343372502112654155197337").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("111112222233333444445555566666777778888899999").unwrap();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "8274803816077825844928633065239507977211631334803000112653099668890202006953504399616683910703926797255292819444704102663");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // self is a composite number and another is prime number
    let mut a_biguint = U512::from_string("777776666655555444443333322222111110000022222").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("6670387054797362513395707836449423967156351509862541368962968031208086533377").unwrap();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "5188071408782660471579036145752463281986051988336775031832198742768814408395807276440197274193933124374007024568944703694");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // Same numbers
    let mut a_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("111112222233333444445555566666777778888899999").unwrap();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "111112222233333444445555566666777778888899999");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // one prime number and its multiple
    let mut a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807").unwrap();
    // let b_biguint = a_biguint.wrapping_mul_uint(3_u8);
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "787760672551329645078144948052076751441184301699551191526778039880634535788587808079267450124018727724292049968038896231261583765900085599798828035839807");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // two relatively prime numbers
    let mut a_biguint = U512::from_string("10842241695257098749029584685234126848").unwrap();
    // let a_biguint = U512::from_uint(2_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(7_u8).pow_uint(31_u8));
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U512::from_string("4502551836747118353130482137203216552734375").unwrap();
    // let b_biguint = U512::from_uint(3_u8).pow_uint(36_u8).wrapping_mul(&U512::from_uint(5_u8).pow_uint(29_u8)).wrapping_mul(&U512::from_uint(11_u8).pow_uint(5_u8));
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "48817755259436040224079590140222715578041897690278400000000000000000000000000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and non-zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_string("1461470517451445635247458978672662721125232940494242939166724681854248046875").unwrap();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // non-zero and zero
    let mut a_biguint = U256::from_string("822879434848600686045915352446172654881155048801396400670057427986680905728").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    // zero and zero
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint.panic_free_lcm_assign(&b_biguint);
    println!("After a_biguint.panic_free_lcm_assign(), a_biguint = {}.", a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_prime_using_miller_rabin()
{
    println!("biguint_is_prime_using_miller_rabin()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    // prime numer case
    let a_biguint = U512::from_string("262586890850443215026048316017358917147061433899850397175592679960211511929529269359755816708006242574764016656012965410420527921966695199932942678613269").unwrap();
    let b = a_biguint.is_prime_using_miller_rabin(5_usize);
    println!("{} is {}a prime number", a_biguint, if b {""} else {"not "});
    assert_eq!(b, true);

    // composite number case
    let a_biguint = U512::from_string("111112222233333444445555566666777778888899999").unwrap();
    let b = a_biguint.is_prime_using_miller_rabin(5_usize);
    println!("{} is {}a prime number", a_biguint, if b {""} else {"not "});
    assert_eq!(b, false);
    println!("---------------------------");
}


fn biguint_bit_operation_main()
{
    biguint_shift_left();
    biguint_shift_left_assign();
    biguint_checked_shift_left();
    biguint_unchecked_shift_left();
    biguint_shift_right();
    biguint_shift_right_assign();
    biguint_checked_shift_right();
    biguint_unchecked_shift_right();
    biguint_rotate_left();
    biguint_rotate_left_assign();
    biguint_rotate_right();
    biguint_rotate_right_assign();
    biguint_and();
    biguint_and_assign();
    biguint_or();
    biguint_or_assign();
    biguint_xor();
    biguint_xor_assign();
    biguint_flip();
    biguint_flip_assign();
    biguint_reverse_bits();
    biguint_reverse_bits_assign();
    biguint_swap_bytes();
    biguint_swap_bytes_assign();
}

fn biguint_shift_left()
{
    println!("biguint_shift_left()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_u16;
    let res = a_biguint.shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_u16;
    let res = a_biguint.shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);
    println!("---------------------------");
}

fn biguint_shift_left_assign()
{
    println!("biguint_shift_left_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 3_u8;
    a_biguint.shift_left_assign(n);
    println!("After a_biguint.shift_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 4_u8;
    a_biguint.shift_left_assign(n);
    println!("After a_biguint.shift_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 128_u8;
    a_biguint.shift_left_assign(n);
    println!("After a_biguint.shift_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 256_u16;
    a_biguint.shift_left_assign(n);
    println!("After a_biguint.shift_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 512_u16;
    a_biguint.shift_left_assign(n);
    println!("After a_biguint.shift_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);
    println!("---------------------------");
}

fn biguint_checked_shift_left()
{
    println!("biguint_checked_shift_left()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.checked_shift_left(n);
    match res
    {
        Some(r) => {
                println!("{} << {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
                assert_eq!(r.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_left_carry(), true);
                assert_eq!(r.is_right_carry(), false);
            },
        None => {
                println!("All bits are gone!");
            }
    }

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.checked_shift_left(n);
    match res
    {
        Some(r) => {
                println!("{} << {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
                assert_eq!(r.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_left_carry(), false);
                assert_eq!(r.is_right_carry(), false);
            },
        None => {
                println!("All bits are gone!");
            }
    }

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.checked_shift_left(n);
    match res
    {
        Some(r) => {
                println!("{} << {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
                assert_eq!(r.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_left_carry(), true);
                assert_eq!(r.is_right_carry(), false);
            },
        None => {
                println!("All bits are gone!");
            }
    }

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_u16;
    let res = a_biguint.checked_shift_left(n);
    match res
    {
        Some(r) => {
                println!("{} << {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
            },
        None => {
                println!("All bits are gone!");
                assert_eq!(res, None);
            }
    }

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_u16;
    let res = a_biguint.checked_shift_left(n);
    match res
    {
        Some(r) => {
                println!("{} << {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
            },
        None => {
                println!("All bits are gone!");
                assert_eq!(res, None);
            }
    }
    println!("---------------------------");
}

fn biguint_unchecked_shift_left()
{
    println!("biguint_unchecked_shift_left()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.unchecked_shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.unchecked_shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.unchecked_shift_left(n);
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    #[cfg(test)] // It will panic!
    biguint_should_panic_unchecked_shift_left();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_unchecked_shift_left()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let _a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let _n = 256_u16;
    // It will panic!
    let _res = _a_biguint.unchecked_shift_left(_n);

    let _a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let _n = 512_u16;
    // It will panic!
    let _res = _a_biguint.unchecked_shift_left(_n);
}

fn biguint_shift_right()
{
    println!("biguint_shift_right()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_11110000", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10101111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_u16;
    let res = a_biguint.shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_u16;
    let res = a_biguint.shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);
    println!("---------------------------");
}

fn biguint_shift_right_assign()
{
    println!("biguint_shift_right_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 3_u8;
    a_biguint.shift_right_assign(n);
    println!("After a_biguint.shift_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11110000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 4_u8;
    a_biguint.shift_right_assign(n);
    println!("After a_biguint.shift_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00110000_00001111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 128_u8;
    a_biguint.shift_right_assign(n);
    println!("After a_biguint.shift_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 256_u16;
    a_biguint.shift_right_assign(n);
    println!("After a_biguint.shift_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 512_u16;
    a_biguint.shift_right_assign(n);
    println!("After a_biguint.shift_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);
    println!("---------------------------");
}

fn biguint_checked_shift_right()
{
    println!("biguint_checked_shift_right()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.checked_shift_right(n);
    match res
    {
        Some(r) => {
                println!("{} >> {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
                assert_eq!(r.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_left_carry(), false);
                assert_eq!(r.is_right_carry(), true);
            },
        None => {
                println!("All bits are gone!");
            }
    }

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11110000", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.checked_shift_right(n);
    match res
    {
        Some(r) => {
                println!("{} >> {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
                assert_eq!(r.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00110000_00001111");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_left_carry(), false);
                assert_eq!(r.is_right_carry(), false);
            },
        None => {
                println!("All bits are gone!");
            }
    }

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.checked_shift_right(n);
    match res
    {
        Some(r) => {
                println!("{} >> {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
                assert_eq!(r.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
                assert_eq!(r.is_overflow(), false);
                assert_eq!(r.is_underflow(), false);
                assert_eq!(r.is_infinity(), false);
                assert_eq!(r.is_undefined(), false);
                assert_eq!(r.is_divided_by_zero(), false);
                assert_eq!(r.is_left_carry(), false);
                assert_eq!(r.is_right_carry(), true);
            },
        None => {
                println!("All bits are gone!");
            }
    }

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 256_u16;
    let res = a_biguint.checked_shift_right(n);
    match res
    {
        Some(r) => {
                println!("{} >> {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
            },
        None => {
                println!("All bits are gone!");
                assert_eq!(res, None);
            }
    }

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 512_u16;
    let res = a_biguint.checked_shift_right(n);
    match res
    {
        Some(r) => {
                println!("{} >> {} = {}", r.to_string_with_radix_and_stride(2, 8).unwrap(), n, r.to_string_with_radix_and_stride(2, 8).unwrap());
            },
        None => {
                println!("All bits are gone!");
                assert_eq!(res, None);
            }
    }
    println!("---------------------------");
}

fn biguint_unchecked_shift_right()
{
    println!("biguint_unchecked_shift_right()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.unchecked_shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_11110000", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.unchecked_shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10101111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.unchecked_shift_right(n);
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    #[cfg(test)]
    biguint_should_panic_unchecked_shift_right();
    println!("---------------------------");
}

#[test]
#[should_panic]
fn biguint_should_panic_unchecked_shift_right()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let _a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let _n = 256_u16;
    // It will panic!
    let _res = _a_biguint.unchecked_shift_right(_n);

    let _a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let _n = 512_u16;
    // It will panic!
    let _res = _a_biguint.unchecked_shift_right(_n);
}

fn biguint_rotate_left()
{
    println!("biguint_rotate_left()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.rotate_left(n);
    println!("{} <<< {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1010110_01100111_10000111_11111000_00000111_11111111_11111000_00000000_00000111_11111111_11111111_11111000_00000000_00000000_00000111_11111111_11111111_11111111_11111000_00000000_00000000_00000000_00000101_10011100_01111000_01111100_00011111_10000001_11111100_00000111_11111000_00000101");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.rotate_left(n);
    println!("{} <<< {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101100_11001111_00001111_11110000_00001111_11111111_11110000_00000000_00001111_11111111_11111111_11110000_00000000_00000000_00001111_11111111_11111111_11111111_11110000_00000000_00000000_00000000_00001011_00111000_11110000_11111000_00111111_00000011_11111000_00001111_11110000_00001010");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.rotate_left(n);
    println!("{} <<< {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 256_u16;
    let res = a_biguint.rotate_left(n);
    println!("{} <<< {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 512_u16;
    let res = a_biguint.rotate_left(n);
    println!("{} <<< {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_rotate_left_assign()
{
    println!("biguint_rotate_left_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 3_u8;
    a_biguint.rotate_left_assign(n);
    println!("After a_biguint.rotate_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010110_01100111_10000111_11111000_00000111_11111111_11111000_00000000_00000111_11111111_11111111_11111000_00000000_00000000_00000111_11111111_11111111_11111111_11111000_00000000_00000000_00000000_00000101_10011100_01111000_01111100_00011111_10000001_11111100_00000111_11111000_00000101");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 4_u8;
    a_biguint.rotate_left_assign(n);
    println!("After a_biguint.rotate_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101100_11001111_00001111_11110000_00001111_11111111_11110000_00000000_00001111_11111111_11111111_11110000_00000000_00000000_00001111_11111111_11111111_11111111_11110000_00000000_00000000_00000000_00001011_00111000_11110000_11111000_00111111_00000011_11111000_00001111_11110000_00001010");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 128_u8;
    a_biguint.rotate_left_assign(n);
    println!("After a_biguint.rotate_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 256_u16;
    a_biguint.rotate_left_assign(n);
    println!("After a_biguint.rotate_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 512_u16;
    a_biguint.rotate_left_assign(n);
    println!("After a_biguint.rotate_left_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_rotate_right()
{
    println!("biguint_rotate_right()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.rotate_right(n);
    println!("{} >>> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101_01011001_10011110_00011111_11100000_00011111_11111111_11100000_00000000_00011111_11111111_11111111_11100000_00000000_00000000_00011111_11111111_11111111_11111111_11100000_00000000_00000000_00000000_00010110_01110001_11100001_11110000_01111110_00000111_11110000_00011111_11100000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 4_u8;
    let res = a_biguint.rotate_right(n);
    println!("{} >>> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1010_10101100_11001111_00001111_11110000_00001111_11111111_11110000_00000000_00001111_11111111_11111111_11110000_00000000_00000000_00001111_11111111_11111111_11111111_11110000_00000000_00000000_00000000_00001011_00111000_11110000_11111000_00111111_00000011_11111000_00001111_11110000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 128_u8;
    let res = a_biguint.rotate_right(n);
    println!("{} >>> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 256_u16;
    let res = a_biguint.rotate_right(n);
    println!("{} >>> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let n = 512_u16;
    let res = a_biguint.rotate_right(n);
    println!("{} >>> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_rotate_right_assign()
{
    println!("biguint_rotate_right_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    
    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 3_u8;
    a_biguint.rotate_right_assign(n);
    println!("After a_biguint.rotate_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101_01011001_10011110_00011111_11100000_00011111_11111111_11100000_00000000_00011111_11111111_11111111_11100000_00000000_00000000_00011111_11111111_11111111_11111111_11100000_00000000_00000000_00000000_00010110_01110001_11100001_11110000_01111110_00000111_11110000_00011111_11100000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 4_u8;
    a_biguint.rotate_right_assign(n);
    println!("After a_biguint.rotate_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010_10101100_11001111_00001111_11110000_00001111_11111111_11110000_00000000_00001111_11111111_11111111_11110000_00000000_00000000_00001111_11111111_11111111_11111111_11110000_00000000_00000000_00000000_00001011_00111000_11110000_11111000_00111111_00000011_11111000_00001111_11110000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 128_u8;
    a_biguint.rotate_right_assign(n);
    println!("After a_biguint.rotate_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 256_u16;
    a_biguint.rotate_right_assign(n);
    println!("After a_biguint.rotate_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let n = 512_u16;
    a_biguint.rotate_right_assign(n);
    println!("After a_biguint.rotate_right_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_and()
{
    println!("biguint_and()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let c_biguint = a_biguint.and(&b_biguint);
    
    println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_00000000_00000000_00000000_11111111_00000000_00000000_11111111_00000000_00000000_00000000_00000000_00000000_10001111_00001111_10000011_11110000_00000000_00000000_00000000_00000000_10100010_10001100_00000000_10000011_00000000_00111111_10000000_00000000_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let c_biguint = a_biguint.and(&b_biguint);
    
    println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.and(&b_biguint);
    
    println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_and_assign()
{
    println!("biguint_and_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint.and_assign(&b_biguint);
    println!("After a_biguint.and_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_00000000_00000000_00000000_11111111_00000000_00000000_11111111_00000000_00000000_00000000_00000000_00000000_10001111_00001111_10000011_11110000_00000000_00000000_00000000_00000000_10100010_10001100_00000000_10000011_00000000_00111111_10000000_00000000_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::max();
    a_biguint.and_assign(&b_biguint);
    println!("After a_biguint.and_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint.and_assign(&b_biguint);
    println!("After a_biguint.and_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_or()
{
    println!("biguint_bitor()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let c_biguint = a_biguint.or(&b_biguint);
    
    println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_00000000_11111111_11111111_11111111_11111111_11111111_11111111_11111111_00000000_00000000_10110011_11111111_11111111_11111111_11111111_00111111_10000000_11111111_00000000_10111011_11001111_11111111_11111111_11110000_11111111_11111111_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let c_biguint = a_biguint.or(&b_biguint);
    
    println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.or(&b_biguint);
    
    println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_or_assign()
{
    println!("biguint_or_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint.or_assign(&b_biguint);
    println!("After a_biguint.or_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_00000000_11111111_11111111_11111111_11111111_11111111_11111111_11111111_00000000_00000000_10110011_11111111_11111111_11111111_11111111_00111111_10000000_11111111_00000000_10111011_11001111_11111111_11111111_11110000_11111111_11111111_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::max();
    a_biguint.or_assign(&b_biguint);
    println!("After a_biguint.or_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint.or_assign(&b_biguint);
    println!("After a_biguint.or_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_xor()
{
    println!("biguint_xor()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let c_biguint = a_biguint.xor(&b_biguint);
    
    println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_11111111_00000000_11111111_00000000_11111111_11111111_00000000_11111111_11111111_00000000_00000000_10110011_01110000_11110000_01111100_00001111_00111111_10000000_11111111_00000000_00011001_01000011_11111111_01111100_11110000_11000000_01111111_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let c_biguint = a_biguint.xor(&b_biguint);
    
    println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_00000000_11111111_00000000_00000000_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_01001100_01110000_11110000_01111100_00001111_11000000_01111111_00000000_11111111");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.xor(&b_biguint);
    
    println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_xor_assign()
{
    println!("biguint_xor_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint.xor_assign(&b_biguint);
    println!("After a_biguint.xor_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_11111111_00000000_11111111_00000000_11111111_11111111_00000000_11111111_11111111_00000000_00000000_10110011_01110000_11110000_01111100_00001111_00111111_10000000_11111111_00000000_00011001_01000011_11111111_01111100_11110000_11000000_01111111_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::max();
    a_biguint.xor_assign(&b_biguint);
    println!("After a_biguint.xor_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_00000000_11111111_00000000_00000000_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_01001100_01110000_11110000_01111100_00001111_11000000_01111111_00000000_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint.xor_assign(&b_biguint);
    println!("After a_biguint.xor_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_flip()
{
    println!("biguint_flip()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = a_biguint.flip();
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_00000000_11111111_00000000_00000000_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_01001100_01110000_11110000_01111100_00001111_11000000_01111111_00000000_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::max();
    let res = a_biguint.flip();
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.flip();
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_flip_assign()
{
    println!("biguint_flip_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.flip_assign();
    println!("After a_biguint.flip_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_00000000_11111111_00000000_00000000_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_01001100_01110000_11110000_01111100_00001111_11000000_01111111_00000000_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::max();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.flip_assign();
    println!("After a_biguint.flip_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.flip_assign();
    println!("After a_biguint.flip_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reverse_bits()
{
    println!("biguint_reverse_bits()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = a_biguint.reverse_bits();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000001_11111100_00001111_11000001_11110000_11110001_11001101_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_00001111_00110011_01010101");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::max();
    let res = a_biguint.reverse_bits();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.reverse_bits();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reverse_bits_assign()
{
    println!("biguint_reverse_bits_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reverse_bits_assign();
    println!("After a_biguint.reverse_bits_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000001_11111100_00001111_11000001_11110000_11110001_11001101_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_00001111_00110011_01010101");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::max();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reverse_bits_assign();
    println!("After a_biguint.reverse_bits_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reverse_bits_assign();
    println!("After a_biguint.reverse_bits_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_swap_bytes()
{
    println!("biguint_swap_bytes()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = a_biguint.swap_bytes();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_10000000_00111111_11110000_10000011_00001111_10001111_10110011_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_11110000_11001100_10101010");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::max();
    let res = a_biguint.swap_bytes();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.swap_bytes();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_swap_bytes_assign()
{
    println!("biguint_swap_bytes_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.swap_bytes_assign();
    println!("After a_biguint.swap_bytes_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_10000000_00111111_11110000_10000011_00001111_10001111_10110011_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_11110000_11001100_10101010");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::max();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.swap_bytes_assign();
    println!("After a_biguint.swap_bytes_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.swap_bytes_assign();
    println!("After a_biguint.swap_bytes_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}


fn biguint_conversion_main()
{
    biguint_into_biguint();
    biguint_into_uint();
    biguint_into_u128();
    biguint_into_u64();
    biguint_into_u32();
    biguint_into_u16();
    biguint_into_u8();
    biguint_into_usize();
    biguint_to_be();
    biguint_to_be_assign();
    biguint_to_be_bytes();
    biguint_to_le();
    biguint_to_le_assign();
    biguint_to_le_bytes();
    biguint_to_string_with_radix_and_stride_and_delimiter();
    biguint_to_string_with_radix_and_stride();
    biguint_to_string_with_radix();
}

fn biguint_into_biguint()
{
    println!("biguint_into_biguint()");
    use cryptocol::number::BigUInt;
    use cryptocol::number::U256_with_u128;
    use cryptocol::number::U256_with_u8;
    use cryptocol::number::U512_with_u8;
    use cryptocol::number::U512_with_u128;
    use std::fmt::Write;

    let mut a_biguint = U256_with_u128::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    a_biguint.set_overflow();
    a_biguint.set_underflow();
    a_biguint.set_undefined();
    a_biguint.set_infinity();
    a_biguint.set_divided_by_zero();

    let b_biguint: BigUInt<u16, 32> = a_biguint.into_biguint();
    println!("a_biguint = {0} = {0:?}", a_biguint);
    println!("b_biguint = {0} = {0:?}", b_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    assert_eq!(b_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(b_biguint.is_overflow(), false);
    assert_eq!(b_biguint.is_underflow(), false);
    assert_eq!(b_biguint.is_infinity(), false);
    assert_eq!(b_biguint.is_undefined(), false);
    assert_eq!(b_biguint.is_divided_by_zero(), false);

    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", a_biguint)
    {
        Ok(_) =>    { assert_eq!(a_txt, "BigUInt { number: [340282346638528863123979975818481827584, 227032875824372601055702174981657985279], flag: 31 }"); },
        Err(_) =>   { panic!("Error"); },
    }
    let mut b_txt = String::new();
    match write!(&mut b_txt, "{:?}", b_biguint)
    {
        Ok(_) => { assert_eq!(b_txt, "BigUInt { number: [65280, 16256, 33776, 36623, 179, 0, 65280, 65535, 255, 0, 65535, 255, 65280, 255, 61695, 43724, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], flag: 0 }"); },
        Err(_) =>   { panic!("Error"); },
    }

    let mut a_biguint = U256_with_u128::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    a_biguint.set_overflow();
    a_biguint.set_underflow();
    a_biguint.set_undefined();
    a_biguint.set_infinity();
    a_biguint.set_divided_by_zero();

    let b_biguint: U512_with_u8 = a_biguint.into_biguint();
    println!("a_biguint = {0} = {0:?}", a_biguint);
    println!("b_biguint = {0} = {0:?}", b_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    assert_eq!(b_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(b_biguint.is_overflow(), false);
    assert_eq!(b_biguint.is_underflow(), false);
    assert_eq!(b_biguint.is_infinity(), false);
    assert_eq!(b_biguint.is_undefined(), false);
    assert_eq!(b_biguint.is_divided_by_zero(), false);

    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", a_biguint)
    {
        Ok(_) =>    { assert_eq!(a_txt, "BigUInt { number: [340282346638528863123979975818481827584, 227032875824372601055702174981657985279], flag: 31 }"); },
        Err(_) =>   { panic!("Error"); },
    }
    let mut b_txt = String::new();
    match write!(&mut b_txt, "{:?}", b_biguint)
    {
        Ok(_) =>    { assert_eq!(b_txt, "BigUInt { number: [0, 255, 128, 63, 240, 131, 15, 143, 179, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 0, 255, 240, 204, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], flag: 0 }"); },
        Err(_) =>   { panic!("Error"); },
    }

    let mut a_biguint = U512_with_u128::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    a_biguint.set_overflow();
    a_biguint.set_underflow();
    a_biguint.set_undefined();
    a_biguint.set_infinity();
    a_biguint.set_divided_by_zero();

    let b_biguint: U256_with_u8 = a_biguint.into_biguint();
    println!("a_biguint = {0} = {0:?}", a_biguint);
    println!("b_biguint = {0} = {0:?}", b_biguint);
    assert_eq!(a_biguint.to_string(), "8945550780017187584626056870222733452660064686360582980627279346698888314793843532145493214749705164311564838731068213948692682076110455767663905463140096");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    assert_eq!(b_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(b_biguint.is_overflow(), false);
    assert_eq!(b_biguint.is_underflow(), false);
    assert_eq!(b_biguint.is_infinity(), false);
    assert_eq!(b_biguint.is_undefined(), false);
    assert_eq!(b_biguint.is_divided_by_zero(), false);

    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", a_biguint)
    {
        Ok(_) => { assert_eq!(a_txt, "BigUInt { number: [340282346638528863123979975818481827584, 227032875824372601055702174981657985279, 340282346638528863123979975818481827584, 227032875824372601055702174981657985279], flag: 31 }"); },
        Err(_) =>   { panic!("Error"); },
    }
    let mut b_txt = String::new();
    match write!(&mut b_txt, "{:?}", b_biguint)
    {
        Ok(_) => { assert_eq!(b_txt, "BigUInt { number: [0, 255, 128, 63, 240, 131, 15, 143, 179, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 0, 255, 240, 204, 170], flag: 0 }"); },
        Err(_) =>   { panic!("Error"); },
    }
    println!("---------------------------");
}

fn biguint_into_uint()
{
    println!("biguint_into_uint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_uint(16384545419507531775_u64);
    let b_u128: u128 = a_biguint.into_uint();
    let b_u64: u64 = a_biguint.into_uint();
    let b_u32: u32 = a_biguint.into_uint();
    let b_u16: u16 = a_biguint.into_uint();
    let b_u8: u8 = a_biguint.into_uint();
    println!("u128 of {} = {}", a_biguint, b_u128);
    println!("u64 of {} = {}", a_biguint, b_u64);
    println!("u32 of {} = {}", a_biguint, b_u32);
    println!("u16 of {} = {}", a_biguint, b_u16);
    println!("u8 of {} = {}", a_biguint, b_u8);
    assert_eq!(b_u128, 16384545419507531775_u128);
    assert_eq!(b_u64, 16384545419507531775_u64);
    assert_eq!(b_u32, 4294967295_u32);
    assert_eq!(b_u16, 65535_u16);
    assert_eq!(b_u8, 255_u8);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    let b_u128: u128 = a_biguint.into_uint();
    let b_u64: u64 = a_biguint.into_uint();
    let b_u32: u32 = a_biguint.into_uint();
    let b_u16: u16 = a_biguint.into_uint();
    let b_u8: u8 = a_biguint.into_uint();
    println!("u128 of {} = {}", a_biguint, b_u128);
    println!("u64 of {} = {}", a_biguint, b_u64);
    println!("u32 of {} = {}", a_biguint, b_u32);
    println!("u16 of {} = {}", a_biguint, b_u16);
    println!("u8 of {} = {}", a_biguint, b_u8);
    assert_eq!(b_u128, 340282346638528863123979975818481827584_u128);
    assert_eq!(b_u64, 10308603139955162880_u64);
    assert_eq!(b_u32, 1065418496_u32);
    assert_eq!(b_u16, 65280_u16);
    assert_eq!(b_u8, 0_u8);
    println!("---------------------------");
}

fn biguint_into_u128()
{
    println!("biguint_into_u128()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_uint(16384545419507531775_u64);
    let b_u128 = a_biguint.into_u128();
    println!("u128 of {} = {}", a_biguint, b_u128);
    assert_eq!(b_u128, 16384545419507531775_u128);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    let b_u128: u128 = a_biguint.into_u128();
    println!("u128 of {} = {}", a_biguint, b_u128);
    assert_eq!(b_u128, 340282346638528863123979975818481827584_u128);
    println!("---------------------------");
}

fn biguint_into_u64()
{
    println!("biguint_into_u64()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_uint(16384545419507531775_u64);
    let b_u64: u64 = a_biguint.into_u64();
    println!("u64 of {} = {}", a_biguint, b_u64);
    assert_eq!(b_u64, 16384545419507531775_u64);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    let b_u64: u64 = a_biguint.into_u64();
    println!("u64 of {} = {}", a_biguint, b_u64);
    assert_eq!(b_u64, 10308603139955162880_u64);
    println!("---------------------------");
}

fn biguint_into_u32()
{
    println!("biguint_into_u32()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_uint(163_u8);
    let b_u32 = a_biguint.into_u32();
    println!("u32 of {} = {}", a_biguint, b_u32);
    assert_eq!(b_u32, 163_u32);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    let b_u32 = a_biguint.into_u32();
    println!("u32 of {} = {}", a_biguint, b_u32);
    assert_eq!(b_u32, 1065418496_u32);
    println!("---------------------------");
}

fn biguint_into_u16()
{
    println!("biguint_into_u16()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_uint(163_u8);
    let b_u16 = a_biguint.into_u16();
    println!("u16 of {} = {}", a_biguint, b_u16);
    assert_eq!(b_u16, 163_u16);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    let b_u16 = a_biguint.into_u16();
    println!("u16 of {} = {}", a_biguint, b_u16);
    assert_eq!(b_u16, 65280_u16);
    println!("---------------------------");
}

fn biguint_into_u8()
{
    println!("biguint_into_u8()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_uint(163_u8);
    let b_u8: u8 = a_biguint.into_u8();
    println!("u8 of {} = {}", a_biguint, b_u8);
    assert_eq!(b_u8, 163_u8);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    let b_u8: u8 = a_biguint.into_u8();
    println!("u8 of {} = {}", a_biguint, b_u8);
    assert_eq!(b_u8, 0_u8);
    println!("---------------------------");
}

fn biguint_into_usize()
{
    println!("biguint_into_usize()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_uint(65280_u16);
    let b_usize = a_biguint.into_usize();
    println!("usize of {} = {}", a_biguint, b_usize);
    assert_eq!(b_usize, 65280_usize);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    let b_usize = a_biguint.into_usize();
    println!("usize of {} = {}", a_biguint, b_usize);
    #[cfg(target_pointer_width = "64")] assert_eq!(b_usize, 10308603139955162880_usize);
    #[cfg(target_pointer_width = "32")] assert_eq!(b_usize, 1065418496_usize);
    #[cfg(target_pointer_width = "16")] assert_eq!(b_usize, 65280_usize);
    println!("---------------------------");
}

fn biguint_to_be()
{
    println!("biguint_to_be()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = a_biguint.to_be();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    #[cfg(target_endian = "little")]    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_10000000_00111111_11110000_10000011_00001111_10001111_10110011_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_11110000_11001100_10101010");
    #[cfg(target_endian = "big")]       assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::max();
    let res = a_biguint.to_be();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.to_be();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_to_be_assign()
{
    println!("biguint_to_be_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.to_be_assign();
    println!("After a_biguint.to_be_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    #[cfg(target_endian = "little")]    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_10000000_00111111_11110000_10000011_00001111_10001111_10110011_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_11110000_11001100_10101010");
    #[cfg(target_endian = "big")]       assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::max();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.to_be_assign();
    println!("After a_biguint.to_be_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.to_be_assign();
    println!("After a_biguint.to_be_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_to_be_bytes()
{
    println!("biguint_to_be_bytes()");
    use std::fmt::Write;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = a_biguint.to_be_bytes();
    println!("{:?} => {:?}", a_biguint, res);
    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", res)
    {
        Ok(_) => {
                #[cfg(target_endian = "little")]    assert_eq!(a_txt, "[170, 204, 240, 255, 0, 255, 255, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 179, 143, 15, 131, 240, 63, 128, 255, 0]");
                #[cfg(target_endian = "big")]       assert_eq!(a_txt, "[0, 255, 128, 63, 240, 131, 15, 143, 179, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 0, 255, 240, 204, 170]");
            },
        Err(_) => { panic!("Error"); },
    }

    let a_biguint = U256::max();
    let res = a_biguint.to_be_bytes();
    println!("{:?} => {:?}", a_biguint, res);
    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", res)
    {
        Ok(_) => { assert_eq!(a_txt, "[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]"); },
        Err(_) => { panic!("Error"); },
    }

    let a_biguint = U256::zero();
    let res = a_biguint.to_be_bytes();
    println!("{:?} => {:?}", a_biguint, res);
    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", res)
    {
        Ok(_) => { assert_eq!(a_txt, "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"); },
        Err(_) => { panic!("Error"); },
    }
    println!("---------------------------");
}

fn biguint_to_le()
{
    println!("biguint_to_le()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = a_biguint.to_le();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    #[cfg(target_endian = "little")]    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    #[cfg(target_endian = "big")]       assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_10000000_00111111_11110000_10000011_00001111_10001111_10110011_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_11110000_11001100_10101010");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::max();
    let res = a_biguint.to_le();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = a_biguint.to_le();
    println!("{} => {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_to_le_assign()
{
    println!("biguint_to_le_assign()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.to_le_assign();
    println!("After a_biguint.to_le_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    #[cfg(target_endian = "little")]    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    #[cfg(target_endian = "big")]       assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_10000000_00111111_11110000_10000011_00001111_10001111_10110011_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_11111111_11111111_00000000_11111111_11110000_11001100_10101010");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::max();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.to_le_assign();
    println!("After a_biguint.to_le_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.to_le_assign();
    println!("After a_biguint.to_le_assign(), a_biguint = {}.", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_to_le_bytes()
{
    println!("biguint_to_le_bytes()");
    use std::fmt::Write;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = a_biguint.to_le_bytes();
    println!("{:?} => {:?}", a_biguint, res);
    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", res)
    {
        Ok(_) => {
                #[cfg(target_endian = "little")]    assert_eq!(a_txt, "[0, 255, 128, 63, 240, 131, 15, 143, 179, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 0, 255, 240, 204, 170]");
                #[cfg(target_endian = "big")]       assert_eq!(a_txt, "[170, 204, 240, 255, 0, 255, 255, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 179, 143, 15, 131, 240, 63, 128, 255, 0]");
            },
        Err(_) => { panic!("Error"); },
    }

    let a_biguint = U256::max();
    let res = a_biguint.to_le_bytes();
    println!("{:?} => {:?}", a_biguint, res);
    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", res)
    {
        Ok(_) => { assert_eq!(a_txt, "[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]"); },
        Err(_) => { panic!("Error"); },
    }

    let a_biguint = U256::zero();
    let res = a_biguint.to_le_bytes();
    println!("{:?} => {:?}", a_biguint, res);
    let mut a_txt = String::new();
    match write!(&mut a_txt, "{:?}", res)
    {
        Ok(_) => { assert_eq!(a_txt, "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"); },
        Err(_) => { panic!("Error"); },
    }
    println!("---------------------------");
}

fn biguint_to_string_with_radix_and_stride_and_delimiter()
{
    println!("biguint_to_string_with_radix_and_stride_and_delimiter()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    use cryptocol::number::NumberErr;
    define_utypes_with!(u64);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride_and_delimiter(10, 3, ",").unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride_and_delimiter(10, 3, ",").unwrap(), "77,255,284,354,385,016,970,177,264,758,879,158,019,392,010,587,479,561,699,232,008,238,232,688,983,808");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride_and_delimiter(16, 4, "-").unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride_and_delimiter(16, 4, "-").unwrap(), "AACC-F0FF-00FF-FF00-00FF-FFFF-0000-00FF-FFFF-FF00-0000-00B3-8F0F-83F0-3F80-FF00");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride_and_delimiter(2, 8, "_").unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride_and_delimiter(2, 8, "_").unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride_and_delimiter(36, 4, ":").unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride_and_delimiter(36, 4, ":").unwrap(), "49:93ID:4SD9:M4DT:2QO9:EF7V:ZKGD:LH3S:Y0SO:W4CH:RKE5:CQA4:0MPS");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride_and_delimiter(62, 4, "~").unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride_and_delimiter(62, 4, ":").unwrap(), "eV7:xhnH:Dmgs:yLnq:m5P9:ZaJf:dOP0:7xlq:S2Da:BiV2:F7dg");

    match a_biguint.to_string_with_radix_and_stride_and_delimiter(1, 4, "$")
    {
        Ok(txt) => { println!("a_biguint = {}", txt); },
        Err(e) => { assert_eq!(e, NumberErr::OutOfValidRadixRange) },
    }

    match a_biguint.to_string_with_radix_and_stride_and_delimiter(63, 4, "~")
    {
        Ok(txt) => { println!("a_biguint = {}", txt); },
        Err(e) => { assert_eq!(e, NumberErr::OutOfValidRadixRange) },
    }
    println!("---------------------------");
}

fn biguint_to_string_with_radix_and_stride()
{
    println!("biguint_to_string_with_radix_and_stride()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    use cryptocol::number::NumberErr;
    define_utypes_with!(u128);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride(10, 3).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(10, 3).unwrap(), "77_255_284_354_385_016_970_177_264_758_879_158_019_392_010_587_479_561_699_232_008_238_232_688_983_808");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride(16, 4).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(16, 4).unwrap(), "AACC_F0FF_00FF_FF00_00FF_FFFF_0000_00FF_FFFF_FF00_0000_00B3_8F0F_83F0_3F80_FF00");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride(36, 6).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(36, 6).unwrap(), "49_93ID4S_D9M4DT_2QO9EF_7VZKGD_LH3SY0_SOW4CH_RKE5CQ_A40MPS");

    println!("a_biguint = {}", a_biguint.to_string_with_radix_and_stride(62, 5).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(62, 5).unwrap(), "eV7_xhnHD_mgsyL_nqm5P_9ZaJf_dOP07_xlqS2_DaBiV_2F7dg");
  
    match a_biguint.to_string_with_radix_and_stride(1, 4)
    {
        Ok(txt) => { println!("a_biguint = {}", txt); },
        Err(e) => { assert_eq!(e, NumberErr::OutOfValidRadixRange) },
    }

    match a_biguint.to_string_with_radix_and_stride(63, 5)
    {
        Ok(txt) => { println!("a_biguint = {}", txt); },
        Err(e) => { assert_eq!(e, NumberErr::OutOfValidRadixRange) },
    }
    println!("---------------------------");
}

fn biguint_to_string_with_radix()
{
    println!("biguint_to_string_with_radix()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    use cryptocol::number::NumberErr;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");

    println!("a_biguint = {}", a_biguint.to_string_with_radix(10).unwrap());
    assert_eq!(a_biguint.to_string_with_radix(10).unwrap(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");

    println!("a_biguint = {}", a_biguint.to_string_with_radix(16).unwrap());
    assert_eq!(a_biguint.to_string_with_radix(16).unwrap(), "AACCF0FF00FFFF0000FFFFFF000000FFFFFFFF00000000B38F0F83F03F80FF00");

    println!("a_biguint = {}", a_biguint.to_string_with_radix(2).unwrap());
    assert_eq!(a_biguint.to_string_with_radix(2).unwrap(), "1010101011001100111100001111111100000000111111111111111100000000000000001111111111111111111111110000000000000000000000001111111111111111111111111111111100000000000000000000000000000000101100111000111100001111100000111111000000111111100000001111111100000000");

    println!("a_biguint = {}", a_biguint.to_string_with_radix(36).unwrap());
    assert_eq!(a_biguint.to_string_with_radix(36).unwrap(), "4993ID4SD9M4DT2QO9EF7VZKGDLH3SY0SOW4CHRKE5CQA40MPS");

    println!("a_biguint = {}", a_biguint.to_string_with_radix(62).unwrap());
    assert_eq!(a_biguint.to_string_with_radix(62).unwrap(), "eV7xhnHDmgsyLnqm5P9ZaJfdOP07xlqS2DaBiV2F7dg");
  
    match a_biguint.to_string_with_radix(1)
    {
        Ok(txt) => { println!("a_biguint = {}", txt); },
        Err(e) => { assert_eq!(e, NumberErr::OutOfValidRadixRange) },
    }

    match a_biguint.to_string_with_radix(63)
    {
        Ok(txt) => { println!("a_biguint = {}", txt); },
        Err(e) => { assert_eq!(e, NumberErr::OutOfValidRadixRange) },
    }
    println!("---------------------------");
}


fn biguint_flag_manipulation_main()
{
    biguint_set_overflow();
    biguint_reset_overflow();
    biguint_is_overflow();
    biguint_set_underflow();
    biguint_reset_underflow();
    biguint_is_underflow();
    biguint_set_infinity();
    biguint_reset_infinity();
    biguint_is_infinity();
    biguint_set_divided_by_zero();
    biguint_reset_divided_by_zero();
    biguint_is_divided_by_zero();
    biguint_set_undefined();
    biguint_reset_undefined();
    biguint_is_undefined();
    biguint_set_left_carry();
    biguint_reset_left_carry();
    biguint_is_left_carry();
    biguint_set_right_carry();
    biguint_reset_right_carry();
    biguint_is_right_carry();
}

fn biguint_set_overflow()
{
    println!("biguint_set_overflow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_overflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reset_overflow()
{
    println!("biguint_reset_overflow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_overflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reset_overflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_overflow()
{
    println!("biguint_is_overflow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_overflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_set_underflow()
{
    println!("biguint_set_underflow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_underflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reset_underflow()
{
    println!("biguint_reset_underflow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_underflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reset_underflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_underflow()
{
    println!("biguint_is_underflow()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_underflow();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_set_infinity()
{
    println!("biguint_set_infinity()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_infinity();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reset_infinity()
{
    println!("biguint_reset_infinity()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_infinity();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reset_infinity();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_infinity()
{
    println!("biguint_is_infinity()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_infinity();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), true);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_set_divided_by_zero()
{
    println!("biguint_set_divided_by_zero()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_divided_by_zero();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_reset_divided_by_zero()
{
    println!("biguint_reset_divided_by_zero()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_divided_by_zero();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);

    a_biguint.reset_divided_by_zero();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_divided_by_zero()
{
    println!("biguint_is_divided_by_zero()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_divided_by_zero();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), true);
    println!("---------------------------");
}

fn biguint_set_undefined()
{
    println!("biguint_set_undefined()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reset_undefined()
{
    println!("biguint_reset_undefined()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reset_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_undefined()
{
    println!("biguint_is_undefined()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}





fn biguint_set_left_carry()
{
    println!("biguint_set_left_carry()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reset_left_carry()
{
    println!("biguint_reset_left_carry()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reset_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_left_carry()
{
    println!("biguint_is_left_carry()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_set_right_carry()
{
    println!("biguint_set_right_carry()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_reset_right_carry()
{
    println!("biguint_reset_right_carry()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.reset_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}

fn biguint_is_right_carry()
{
    println!("biguint_is_right_carry()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("77255284354385016970177264758879158019392010587479561699232008238232688983808").unwrap();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    a_biguint.set_undefined();
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "77255284354385016970177264758879158019392010587479561699232008238232688983808");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), true);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    println!("---------------------------");
}


fn biguint_operators_arithmatic_main()
{
    biguint_op_add();
    biguint_op_add_uint();
    biguint_op_add_assign();
    biguint_op_add_assign_uint();
    biguint_op_sub();
    biguint_op_sub_uint();
    biguint_op_sub_assign();
    biguint_op_sub_assign_uint();
    biguint_op_mul();
    biguint_op_mul_uint();
    biguint_op_mul_assign();
    biguint_op_mul_assign_uint();
    biguint_op_div();
    biguint_op_div_uint();
    biguint_op_div_assign();
    biguint_op_div_assign_uint();
    biguint_op_rem();
    biguint_op_rem_uint();
    biguint_op_rem_assign();
    biguint_op_rem_assign_uint();
}

fn biguint_op_add()
{
    println!("biguint_op_add()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    
    let a_biguint = U512::max() - 1_u8;
    let one_biguint = U512::one();
    let res = a_biguint.clone() + one_biguint.clone();
    println!("{} + {} = {}", a_biguint, one_biguint, res);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);
    
    let a_biguint = U512::max() - 1_u8;
    let two_biguint = U512::from_uint(2_u8);
    let res = a_biguint.clone() + two_biguint.clone();
    println!("{} + {} = {}", a_biguint, two_biguint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);
    
    let a_biguint = U512::max() - 1_u8;
    let three_biguint = U512::from_uint(3_u8);
    let res = a_biguint.clone() + three_biguint.clone();
    println!("{} + {} = {}", a_biguint, three_biguint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max() - 1_u8;
    let one_biguint = U512::one();
    let _res = a_biguint + one_biguint;
    // It cannot be compiled!
    // println!("{} + {} = {}", a_biguint, one_biguint, _res);
    // The operator '+' swallowed (took the ownership of) a_biguint and one_biguint.

    let a_biguint = U512::max() - 1_u8;
    let two_biguint = U512::from_uint(2_u8);
    let _res = a_biguint + two_biguint;
    // It cannot be compiled!
    // println!("{} + {} = {}", a_biguint, two_biguint, _res);
    // The operator '+' swallowed (took the ownership of) a_biguint and two_biguint.

    let a_biguint = U512::max() - 1_u8;
    let three_biguint = U512::from_uint(3_u8);
    let _res = a_biguint + three_biguint;
    // It cannot be compiled!
    // println!("{} + {} = {}", a_biguint, three_biguint, _res);
    // The operator '+' swallowed (took the ownership of) a_biguint and three_biguint.
    println!("---------------------------");
}

fn biguint_op_add_uint()
{
    println!("biguint_op_add_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U512::max() - 1_u16;
    let one_uint = 1_u16;
    let res = a_biguint.clone() + one_uint;
    println!("{} + {} = {}", a_biguint, one_uint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max() - 1_u16;
    let two_uint = 2_u16;
    let res = a_biguint.clone() + two_uint;
    println!("{} + {} = {}", a_biguint, two_uint, res);
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max() - 1_u16;
    let three_uint = 3_u16;
    let res = a_biguint.clone() + three_uint;
    println!("{} + {} = {}", a_biguint, three_uint, res);
    assert_eq!(res.to_string(), "1");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::max() - 1_u16;
    let one_uint = 1_u16;
    let _res = a_biguint + one_uint;
    // It cannot be compiled!
    // println!("{} + {} = {}", a_biguint, one_uint, _res);
    // The operator '+' swallowed (took the ownership of) a_biguint.

    let a_biguint = U512::max() - 1_u16;
    let two_uint = 2_u16;
    let _res = a_biguint + two_uint;
    // It cannot be compiled!
    // println!("{} + {} = {}", a_biguint, two_uint, _res);
    // The operator '+' swallowed (took the ownership of) a_biguint.

    let a_biguint = U512::max() - 1_u16;
    let three_uint = 3_u16;
    let _res = a_biguint + three_uint;
    // It cannot be compiled!
    // println!("{} + {} = {}", a_biguint, three_uint, _res);
    // The operator '+' swallowed (took the ownership of) a_biguint.
    println!("---------------------------");
}

fn biguint_op_add_assign()
{
    println!("biguint_op_add_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);
    
    let mut a_biguint = U512::max() - 1_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    a_biguint += one_biguint.clone();
    println!("After a_biguint += {}, a_biguint = {}", one_biguint, a_biguint);
    assert_eq!(a_biguint, U512::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::max() - 1_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let two_biguint = U512::from_uint(2_u8);
    a_biguint += two_biguint.clone();
    println!("After a_biguint += {}, a_biguint = {}", two_biguint, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::max() - 1_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let three_biguint = U512::from_uint(3_u8);
    a_biguint += three_biguint.clone();
    println!("After a_biguint += {},\ta_biguint = {}", three_biguint, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::max() - 1_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    let one_biguint = U512::one();
    a_biguint += one_biguint;
    // It cannot be compiled!
    // println!("After a_biguint += {}, a_biguint = {}", one_biguint, a_biguint);
    // The operator '+=' swallowed (took the ownership of) one_biguint.

    let mut a_biguint = U512::max() - 1_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    let two_biguint = U512::from_uint(2_u8);
    a_biguint += two_biguint.clone();
    // It cannot be compiled!
    // println!("After a_biguint += {}, a_biguint = {}", two_biguint, a_biguint);
    // The operator '+=' swallowed (took the ownership of) two_biguint.

    let mut a_biguint = U512::max() - 1_u32;
    println!("Originally, a_biguint = {}", a_biguint);
    let three_biguint = U512::from_uint(3_u8);
    a_biguint += three_biguint.clone();
    // It cannot be compiled!
    // println!("After a_biguint += {}, a_biguint = {}", three_biguint, a_biguint);
    // The operator '+=' swallowed (took the ownership of) three_biguint.
    println!("---------------------------");
}

fn biguint_op_add_assign_uint()
{
    println!("biguint_op_add_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = UU64::max() - 1_u64;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_uint = 1_u64;
    a_biguint += one_uint;
    println!("After a_biguint += {}, a_biguint = {}", one_uint, a_biguint);
    assert_eq!(a_biguint, UU64::max());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    
    let mut a_biguint = UU64::max() - 1_u64;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let two_uint = 2_u64;
    a_biguint += two_uint;
    println!("After a_biguint += {}, a_biguint = {}", two_uint, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::max() - 1_u64;
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let three_uint = 3_u64;
    a_biguint += three_uint;
    println!("After a_biguint += {}, a_biguint = {}", three_uint, a_biguint);
    assert_eq!(a_biguint.to_string(), "1");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_op_sub()
{
    println!("biguint_op_sub");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U512::one();
    let one_biguint = U512::one();
    let res = a_biguint.clone() - one_biguint.clone();
    println!("{} - {} = {}", a_biguint, one_biguint, res);
    assert_eq!(res, U512::zero());
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let two_biguint = U512::from_uint(2_u8);
    let res = a_biguint.clone() - two_biguint.clone();
    println!("{} - {} = {}", a_biguint, two_biguint, res);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let three_biguint = U512::from_uint(3_u8);
    let res = a_biguint.clone() - three_biguint.clone();
    println!("{} - {} = {}", a_biguint, three_biguint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let one_biguint = U512::one();
    let _res = a_biguint - one_biguint;
    // It cannot be compiled!
    // println!("{} - {} = {}", a_biguint, one_biguint, _res);
    // The operator '-' swallowed (took the ownership of) a_biguint and one_biguint.

    let a_biguint = U512::one();
    let two_biguint = U512::from_uint(2_u8);
    let _res = a_biguint - two_biguint;
    // It cannot be compiled!
    // println!("{} - {} = {}", a_biguint, one_biguint, _res);
    // The operator '-' swallowed (took the ownership of) a_biguint and two_biguint.

    let a_biguint = U512::one();
    let three_biguint = U512::from_uint(3_u8);
    let _res = a_biguint - three_biguint;
    // It cannot be compiled!
    // println!("{} - {} = {}", a_biguint, one_biguint, _res);
    // The operator '-' swallowed (took the ownership of) a_biguint and three_biguint.
    println!("---------------------------");
}

fn biguint_op_sub_uint()
{
    println!("biguint_op_sub_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U512::one();
    let one_uint = 1_u8;
    let res = a_biguint.clone() - one_uint.clone();
    println!("{} - {} = {}", a_biguint, one_uint, res);
    assert_eq!(res, U512::zero());
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let two_uint = 2_u8;
    let res = a_biguint.clone() - two_uint.clone();
    println!("{} - {} = {}", a_biguint, two_uint, res);
    assert_eq!(res, U512::max());
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let three_uint = 3_u8;
    let res = a_biguint.clone() - three_uint.clone();
    println!("{} - {} = {}", a_biguint, three_uint, res);
    assert_eq!(res.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(res.is_underflow(), true);
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U512::one();
    let one_uint = 1_8;
    let _res = a_biguint - one_uint;
    // It cannot be compiled!
    // println!("{} - {} = {}", a_biguint, one_uint, _res);
    // The operator '-' swallowed (took the ownership of) a_biguint.

    let a_biguint = U512::one();
    let two_uint = 2_u8;
    let _res = a_biguint - two_uint;
    // It cannot be compiled!
    // println!("{} - {} = {}", a_biguint, one_uint, _res);
    // The operator '-' swallowed (took the ownership of) a_biguint.

    let a_biguint = U512::one();
    let three_uint = 3_u8;
    let _res = a_biguint - three_uint;
    // It cannot be compiled!
    // println!("{} - {} = {}", a_biguint, one_uint, _res);
    // The operator '-' swallowed (took the ownership of) a_biguint.
    println!("---------------------------");
}

fn biguint_op_sub_assign()
{
    println!("biguint_op_sub_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_biguint = U512::one();
    a_biguint -= one_biguint.clone();
    println!("After a_biguint -= {}, a_biguint = {}", one_biguint, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let two_biguint = U512::from_uint(2_u8);
    a_biguint -= two_biguint.clone();
    println!("After a_biguint -= {}, a_biguint = {}", two_biguint, a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let three_biguint = U512::from_uint(3_u8);
    a_biguint -= three_biguint.clone();
    println!("After a_biguint -= {}, a_biguint = {}", three_biguint, a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    let one_biguint = U512::one();
    a_biguint -= one_biguint;
    // It cannot be compiled!
    // println!("After a_biguint -= {}, a_biguint = {}", one_biguint, a_biguint);
    // The operator '-=' swallowed (took the ownership of) one_biguint.

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    let two_biguint = U512::from_uint(2_u8);
    a_biguint -= two_biguint.clone();
    // It cannot be compiled!
    // println!("After a_biguint -= {}, a_biguint = {}", two_biguint, a_biguint);
    // The operator '-=' swallowed (took the ownership of) two_biguint.

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    let three_biguint = U512::from_uint(3_u8);
    a_biguint -= three_biguint.clone();
    // It cannot be compiled!
    // println!("After a_biguint -= {}, a_biguint = {}", three_biguint, a_biguint);
    // The operator '-=' swallowed (took the ownership of) three_biguint.
    println!("---------------------------");
}

fn biguint_op_sub_assign_uint()
{
    println!("biguint_op_sub_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let one_uint = 1_u32;
    a_biguint -= one_uint;
    println!("After a_biguint -= {}, a_biguint = {}", one_uint, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let two_uint = 2_u32;
    a_biguint -= two_uint;
    println!("After a_biguint -= {}, a_biguint = {}", two_uint, a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U512::one();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let three_uint = 3_u32;
    a_biguint -= three_uint;
    println!("After a_biguint -= {}, a_biguint = {}", three_uint, a_biguint);
    assert_eq!(a_biguint.to_string(), "13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_underflow(), true);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_op_mul()
{
    println!("biguint_op_mul");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let res = a_biguint.clone() * b_biguint.clone();
    println!("{} X {} = {}", a_biguint, b_biguint, res);
    assert_eq!(res.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let res = a_biguint.clone() * b_biguint.clone();
    println!("{} X {} = {}", a_biguint, b_biguint, res);
    assert_eq!(res.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U256::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let _res = a_biguint * b_biguint;
    // It cannot be compiled!
    // println!("{} X {} = {}", a_biguint, b_biguint, res);
    // The operator '*' swallowed (took the ownership of) a_biguint and b_biguint.
    
    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_biguint = U256::from_uint(248_u8);
    let _res = a_biguint * b_biguint;
    // It cannot be compiled!
    // println!("{} X {} = {}", a_biguint, b_biguint, res);
    // The operator '*' swallowed (took the ownership of) a_biguint and b_biguint.
    println!("---------------------------");
}

fn biguint_op_mul_uint()
{
    println!("biguint_op_mul_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_uint = 248_u128;
    let res = a_biguint.clone() * b_uint;
    println!("{} X {} = {}", a_biguint, b_uint, res);
    assert_eq!(res.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_uint = 248_u128;
    let res = a_biguint.clone() * b_uint;
    println!("{} X {} = {}", a_biguint, b_uint, res);
    assert_eq!(res.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(res.is_overflow(), true);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);

    let a_biguint = U256::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    let b_uint = 248_u128;
    let _res = a_biguint * b_uint;
    // It cannot be compiled!
    // println!("{} X {} = {}", a_biguint, b_uint, _res);
    // The operator '*' swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    let b_uint = 248_u128;
    let _res = a_biguint * b_uint;
    // It cannot be compiled!
    // println!("{} X {} = {}", b_biguint, b_uint, _res);
    // The operator '*' swallowed (took the ownership of) a_biguint.
    println!("---------------------------");
}

fn biguint_op_mul_assign()
{
    println!("biguint_op_mul_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU32::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let b_biguint = U256::from_uint(248_u8);
    a_biguint *= b_biguint.clone();
    println!("After a_biguint *= {}, a_biguint = {}", b_biguint, a_biguint);
    assert_eq!(a_biguint.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let b_biguint = U256::from_uint(248_u8);
    a_biguint *= b_biguint.clone();
    println!("After a_biguint *= {}, a_biguint = {}", b_biguint, a_biguint);
    assert_eq!(a_biguint.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = U256::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    let b_biguint = U256::from_uint(248_u8);
    a_biguint *= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint *= {}, a_biguint = {}", b_biguint, a_biguint);
    // The operator '*' swallowed (took the ownership of) a_biguint and b_biguint.
    
    let mut a_biguint = U256::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    let b_biguint = U256::from_uint(248_u8);
    a_biguint *= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint *= {}, a_biguint = {}", b_biguint, a_biguint);
    // The operator '*' swallowed (took the ownership of) a_biguint and b_biguint.
    println!("---------------------------");
}

fn biguint_op_mul_assign_uint()
{
    println!("biguint_op_mul_assign_uint");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = UU32::from_string("12380187429816690342769003185818648605085375388281194656994643364900608").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "12380187429816690342769003185818648605085375388281194656994643364900608");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let b_uint = 248_u16;
    a_biguint *= b_uint;
    println!("After a_biguint *= {}, a_biguint = {}", b_uint, a_biguint);
    assert_eq!(a_biguint.to_string(), "3070286482594539205006712790083024854061173096293736274934671554495350784");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let mut a_biguint = UU32::from_string("876801874298166903427690031858186486050853753882811946569946433649006084094").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "876801874298166903427690031858186486050853753882811946569946433649006084094");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);

    let b_uint = 248_u16;
    a_biguint *= b_uint;
    println!("After a_biguint *= {}, a_biguint = {}", b_uint, a_biguint);
    assert_eq!(a_biguint.to_string(), "101654775588629196626496142892142340687341746297296798709889131537040379215376");
    assert_eq!(a_biguint.is_overflow(), true);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    println!("---------------------------");
}

fn biguint_op_div()
{
    println!("biguint_op_div");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.clone() / divisor.clone();
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = U256::zero();
    let divisor = U256::from_uint(87_u8);
    let quotient = dividend.clone() / divisor.clone();
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = U256::zero();
    // It will panic!
    // let quotient = _dividend.clone() / _divisor.clone();

    let _dividend = U256::zero();
    let _divisor = U256::zero();
    // It will panic!
    // let quotient = _dividend.clone() / _divisor.clone();

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = U256::from_uint(87_u8);
    let _quotient = dividend / divisor;
    // It cannot be compiled!
    // println!("{} / {} = {}", dividend, divisor, _quotient);
    // The operator '/' swallowed (took the ownership of) dividend and divisor.

    let dividend = U256::zero();
    let divisor = U256::from_uint(87_u8);
    let _quotient = dividend / divisor;
    // It cannot be compiled!
    // println!("{} / {} = {}", dividend, divisor, _quotient);
    // The operator '/' swallowed (took the ownership of) dividend and divisor.
    println!("---------------------------");
}

fn biguint_op_div_uint()
{
    println!("biguint_op_div_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u64;
    let quotient = dividend.clone() / divisor;
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let dividend = U256::zero();
    let divisor = 87_u64;
    let quotient = dividend.clone() / divisor;
    println!("{} / {} = {}", dividend, divisor, quotient);
    assert_eq!(quotient.to_string(), "0");
    assert_eq!(quotient.is_overflow(), false);
    assert_eq!(quotient.is_underflow(), false);
    assert_eq!(quotient.is_infinity(), false);
    assert_eq!(quotient.is_undefined(), false);
    assert_eq!(quotient.is_divided_by_zero(), false);

    let _dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u64;
    // It will panic!
    // let quotient = _dividend.clone() / _divisor;

    let _dividend = U256::zero();
    let _divisor = 0_u64;
    // It will panic!
    // let quotient = _dividend.clone() / _divisor;

    let dividend = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u64;
    let _quotient = dividend / divisor;
    // It cannot be compiled!
    // println!("{} / {} = {}", dividend, divisor, _quotient);
    // The operator '/' swallowed (took the ownership of) dividend.

    let dividend = U256::zero();
    let divisor = 87_u64;
    let _quotient = dividend / divisor;
    // It cannot be compiled!
    // println!("{} / {} = {}", dividend, divisor, _quotient);
    // The operator '/' swallowed (took the ownership of) dividend.
    println!("---------------------------");
}

fn biguint_op_div_assign()
{
    println!("biguint_op_div_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(87_u8);
    a_biguint /= divisor.clone();
    println!("After a_biguint /= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = UU32::from_uint(87_u8);
    a_biguint /= divisor.clone();
    println!("After a_biguint /= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = UU32::zero();
    // It will panic!
    // _a_biguint /= _divisor.clone();

    let mut _a_biguint = UU32::zero();
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    let _divisor = UU32::zero();
    // It will panic!
    // _a_biguint /= _divisor.clone();

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    let divisor = UU32::from_uint(87_u8);
    a_biguint /= divisor;
    // It cannot be compiled!
    // println!("After a_biguint /= {}, a_biguint = {}", divisor, a_biguint);
    // The operator '/=' swallowed (took the ownership of) divisor.

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    let divisor = UU32::from_uint(87_u8);
    a_biguint /= divisor;
    // It cannot be compiled!
    // println!("After a_biguint /= {}, a_biguint = {}", divisor, a_biguint);
    // The operator '/=' swallowed (took the ownership of) divisor.
    println!("---------------------------");
}

fn biguint_op_div_assign_uint()
{
    println!("biguint_op_div_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u8;
    a_biguint /= divisor;
    println!("After a_biguint /= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "1419043551905275201680884938348044216837079832");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = UU32::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u8;
    a_biguint /= divisor;
    println!("After a_biguint /= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u8;
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.wrapping_div_assign_uint(_divisor);

    let mut _a_biguint = UU32::zero();
    let _divisor = 0_u8;
    println!("Originally,\n_a_biguint = {}", _a_biguint);
    // It will panic!
    // _a_biguint.wrapping_div_assign_uint(_divisor);
    println!("---------------------------");
}

fn biguint_op_rem()
{
    println!("biguint_op_rem");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.clone() % divisor.clone();
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let remainder = dividend.clone() % divisor.clone();
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");
    assert_eq!(remainder.is_overflow(), false);
    assert_eq!(remainder.is_underflow(), false);
    assert_eq!(remainder.is_infinity(), false);
    assert_eq!(remainder.is_undefined(), false);
    assert_eq!(remainder.is_divided_by_zero(), false);

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = UU32::zero();
    // It will panic!
    // let remainder = _dividend.wrapping_rem(&_divisor);

    let _dividend = UU32::zero();
    let _divisor = UU32::zero();
    // It will panic!
    // let remainder = _dividend.wrapping_rem(&_divisor);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = UU32::from_uint(87_u8);
    let _remainder = dividend % divisor;
    // It cannot be compiled!
    // println!("{} % {} = {}", dividend, divisor, _remainder);
    // The operator '%' swallowed (took the ownership of) dividend and divisor.

    let dividend = UU32::zero();
    let divisor = UU32::from_uint(87_u8);
    let _remainder = dividend % divisor;
    // It cannot be compiled!
    // println!("{} % {} = {}", dividend, divisor, _remainder);
    // The operator '%' swallowed (took the ownership of) dividend and divisor.
    println!("---------------------------");
}

fn biguint_op_rem_uint()
{
    println!("biguint_op_rem_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u32;
    let remainder = dividend.clone() % divisor;
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "8");

    let dividend = UU32::zero();
    let divisor = 87_u32;
    let remainder = dividend.clone() % divisor;
    println!("{} % {} = {}", dividend, divisor, remainder);
    assert_eq!(remainder.to_string(), "0");

    let _dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let _divisor = 0_u32;
    // It will panic!
    // let remainder = _dividend.clone() % _divisor;

    let _dividend = UU32::zero();
    let _divisor = 0_u32;
    // It will panic!
    // let remainder = _dividend.clone() % _divisor;

    let dividend = UU32::from_str("123456789015758942546236989636279846864825945392").unwrap();
    let divisor = 87_u32;
    let _remainder = dividend % divisor;
    // It cannot be compiled!
    // println!("{} % {} = {}", dividend, divisor, _remainder);
    // The operator '%' swallowed (took the ownership of) dividend.

    let dividend = UU32::zero();
    let divisor = 87_u32;
    let _remainder = dividend % divisor;
    // It cannot be compiled!
    // println!("{} % {} = {}", dividend, divisor, _remainder);
    // The operator '%' swallowed (took the ownership of) dividend.
    println!("---------------------------");
}

fn biguint_op_rem_assign()
{
    println!("biguint_op_rem_assign");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint %= divisor.clone();
    println!("After a_biguint %= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = U256::from_uint(87_u8);
    a_biguint %= divisor.clone();
    println!("After a_biguint %= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _divisor = U256::zero();
    // It will panic!
    // _a_biguint %= _divisor.clone();

    let mut _a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _divisor = U256::zero();
    // It will panic!
    // _a_biguint %= _divisor.clone();

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    let divisor = U256::from_uint(87_u8);
    a_biguint %= divisor;
    // It cannot be compiled!
    // println!("After a_biguint =/ {}, a_biguint = {}", divisor, a_biguint);
    // The operator %= swallowed (took the ownership of) divisor.
    
    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    let divisor = U256::from_uint(87_u8);
    a_biguint %= divisor;
    // It cannot be compiled!
    // println!("After a_biguint =/ {}, a_biguint = {}", divisor, a_biguint);
    // The operator %= swallowed (took the ownership of) divisor.
    println!("---------------------------");
}

fn biguint_op_rem_assign_uint()
{
    println!("biguint_op_rem_assign_uint");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u128;
    a_biguint %= divisor;
    println!("After a_biguint %= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "8");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::zero();
    println!("Originally, a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let divisor = 87_u128;
    a_biguint %= divisor;
    println!("After a_biguint %= {}, a_biguint = {}", divisor, a_biguint);
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut _a_biguint = U256::from_str("123456789015758942546236989636279846864825945392").unwrap();
    println!("Originally, a_biguint = {}", _a_biguint);
    let _divisor = 0_u128;
    // It will panic!
    // _a_biguint %= _divisor;

    let mut _a_biguint = U256::zero();
    println!("Originally, _a_biguint = {}", _a_biguint);
    let _divisor = 0_u128;
    // It will panic!
    // _a_biguint %= _divisor;
    println!("---------------------------");
}


fn biguint_operators_bit_operation_main()
{
    biguint_operator_shift_left();
    biguint_operator_shift_left_assign();
    biguint_operator_shift_right();
    biguint_operator_shift_right_assign();
    biguint_operator_and();
    biguint_operator_and_assign();
    biguint_operator_or();
    biguint_operator_or_assign();
    biguint_operator_xor();
    biguint_operator_xor_assign();
    biguint_operator_flip();
}

fn biguint_operator_shift_left()
{
    println!("biguint_operator_shift_left");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_u16;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_u32;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_u64;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_u128;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 1024_usize;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_i8;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_i16;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_i32;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_i64;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_i128;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 1024_isize;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = -3_i8;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_11110000", 2).unwrap();
    let n = -4_i16;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10101111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = -128_i32;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -256_i64;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -512_i128;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -1024_isize;
    let res = a_biguint.clone() << n;
    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    #[cfg(test)]
    biguint_compile_fail_operator_shift_left();
    println!("---------------------------");
}

#[test]
fn biguint_compile_fail_operator_shift_left()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_u8;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_u16;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_u32;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_u64;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_u128;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 1024_usize;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_i8;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_i16;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_i32;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_i64;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_i128;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 1024_isize;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = -3_i8;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_11110000", 2).unwrap();
    let n = -4_i16;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = -128_i32;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -256_i64;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -512_i128;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -1024_isize;
    let _res = a_biguint << n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} << {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator << swallowed (took the ownership of) a_biguint.
}

fn biguint_operator_shift_left_assign()
{
    println!("biguint_operator_shift_left_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 3_u8;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 4_u16;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 128_u32;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 256_u64;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 512_u128;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 1024_usize;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);
    
    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 3_i8;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011000_00000111_11111000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 4_i16;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 128_i32;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 256_i64;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 512_i128;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 1024_isize;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);
    
    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -3_i8;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11110000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -4_i16;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00110000_00001111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -128_i32;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -256_i64;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -512_i128;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -1024_isize;
    a_biguint <<= n;
    println!("After a_biguint <<= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);
    println!("---------------------------");
}

fn biguint_operator_shift_right()
{
    println!("biguint_operator_shift_right");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 3_u8;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_11110000", 2).unwrap();
    let n = 4_u16;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10101111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 128_u32;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_u64;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_u128;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 1024_usize;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 3_i8;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_11110000", 2).unwrap();
    let n = 4_i16;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10101111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = 128_i32;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_i64;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_i128;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 1024_isize;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), true);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -3_i8;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -4_i16;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), false);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -128_i32;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -256_i64;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -512_i128;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -1024_isize;
    let res = a_biguint.clone() >> n;
    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);
    assert_eq!(res.is_left_carry(), true);
    assert_eq!(res.is_right_carry(), false);

    #[cfg(test)]
    biguint_compile_fail_operator_shift_right();
    println!("---------------------------");
}

#[test]
fn biguint_compile_fail_operator_shift_right()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 3_u8;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 4_u16;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 128_u32;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 256_u64;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 512_u128;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = 1024_usize;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = -3_i8;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_11110000", 2).unwrap();
    let n = -4_i16;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    let n = -128_i32;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -256_i64;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -512_i128;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let n = -1024_isize;
    let _res = a_biguint >> n;
    // It cannot be compiled!
    #[cfg(compile_fail)]    println!("{} >> {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), n, res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator >> swallowed (took the ownership of) a_biguint.
}

fn biguint_operator_shift_right_assign()
{
    println!("biguint_operator_shift_right_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    
    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 3_u8;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11110000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 4_u16;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00110000_00001111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 128_u32;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 256_u64;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 512_u128;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 1024_usize;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);
    
    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11111111", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 3_i8;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01110101_01001010_10111111_11100000_00011110_00000001_11111001_10000110_01100000_00011111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_00000000_11110000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 4_i16;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00110000_00001111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 128_i32;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 256_i64;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 512_i128;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = 1024_isize;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), true);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -3_i8;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101111_11111000_00000111_10000000_01111110_01100001_10011101_01010010_10101000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -4_i16;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01011111_11110000_00001111_00000000_11111100_11000011_00111010_10100101_01010000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -128_i32;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("00001111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -256_i64;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -512_i128;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);

    let mut a_biguint = U256::from_str_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), false);
    assert_eq!(a_biguint.is_right_carry(), false);

    let n = -1024_isize;
    a_biguint >>= n;
    println!("After a_biguint >>= {}, a_biguint = {}.", n, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);
    assert_eq!(a_biguint.is_left_carry(), true);
    assert_eq!(a_biguint.is_right_carry(), false);
    println!("---------------------------");
}

fn biguint_operator_and()
{
    println!("biguint_operator_and");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    
    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let c_biguint = a_biguint.clone() & b_biguint.clone();
    
    println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_00000000_00000000_00000000_11111111_00000000_00000000_11111111_00000000_00000000_00000000_00000000_00000000_10001111_00001111_10000011_11110000_00000000_00000000_00000000_00000000_10100010_10001100_00000000_10000011_00000000_00111111_10000000_00000000_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let c_biguint = a_biguint.clone() & b_biguint.clone();
    
    println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint, a_biguint);
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.clone() & b_biguint.clone();
    
    println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string(), "0");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let _c_biguint = a_biguint & b_biguint;
    // It cannot be compiled!
    // println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator & swallowed (took the ownership of) a_biguint and b_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let _c_biguint = a_biguint & b_biguint;
    // It cannot be compiled!
    // println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator & swallowed (took the ownership of) a_biguint and b_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let _c_biguint = a_biguint & b_biguint;
    // It cannot be compiled!
    // println!("{} & {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator & swallowed (took the ownership of) a_biguint and b_biguint.
    println!("---------------------------");
}

fn biguint_operator_and_assign()
{
    println!("biguint_operator_and_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint &= b_biguint.clone();
    println!("After a_biguint &= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_00000000_00000000_00000000_11111111_00000000_00000000_11111111_00000000_00000000_00000000_00000000_00000000_10001111_00001111_10000011_11110000_00000000_00000000_00000000_00000000_10100010_10001100_00000000_10000011_00000000_00111111_10000000_00000000_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::max();
    a_biguint &= b_biguint.clone();
    println!("After a_biguint &= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint &= b_biguint.clone();
    println!("After a_biguint &= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string(), "0");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint &= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint &= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator &= swallowed (took the ownership of) b_biguint.

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::max();
    a_biguint &= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint &= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator &= swallowed (took the ownership of) b_biguint.

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::zero();
    a_biguint &= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint &= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator &= swallowed (took the ownership of) b_biguint.
    println!("---------------------------");
}

fn biguint_operator_or()
{
    println!("biguint_operator_or");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let c_biguint = a_biguint.clone() | b_biguint.clone();
    
    println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_00000000_11111111_11111111_11111111_11111111_11111111_11111111_11111111_00000000_00000000_10110011_11111111_11111111_11111111_11111111_00111111_10000000_11111111_00000000_10111011_11001111_11111111_11111111_11110000_11111111_11111111_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let c_biguint = a_biguint.clone() | b_biguint.clone();
    
    println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.clone() | b_biguint.clone();
    
    println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let _c_biguint = a_biguint | b_biguint;
    // It cannot be compiled!
    // println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator | swallowed (took the ownership of) a_biguint and b_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let _c_biguint = a_biguint | b_biguint;
    // It cannot be compiled!
    // println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator | swallowed (took the ownership of) a_biguint and b_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let _c_biguint = a_biguint | b_biguint;
    // It cannot be compiled!
    // println!("{} | {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator | swallowed (took the ownership of) a_biguint and b_biguint.
    println!("---------------------------");
}

fn biguint_operator_or_assign()
{
    println!("biguint_operator_or_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint |= b_biguint.clone();
    println!("After a_biguint |= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_00000000_11111111_11111111_11111111_11111111_11111111_11111111_11111111_00000000_00000000_10110011_11111111_11111111_11111111_11111111_00111111_10000000_11111111_00000000_10111011_11001111_11111111_11111111_11110000_11111111_11111111_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::max();
    a_biguint |= b_biguint.clone();
    println!("After a_biguint |= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint |= b_biguint.clone();
    println!("After a_biguint |= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint |= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint |= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator |= swallowed (took the ownership of) b_biguint.

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::max();
    a_biguint |= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint |= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator |= swallowed (took the ownership of) b_biguint.

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::zero();
    a_biguint |= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint |= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator |= swallowed (took the ownership of) b_biguint.
    println!("---------------------------");
}

fn biguint_operator_xor()
{
    println!("biguint_operator_xor");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let c_biguint = a_biguint.clone() ^ b_biguint.clone();
    
    println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_11111111_00000000_11111111_00000000_11111111_11111111_00000000_11111111_11111111_00000000_00000000_10110011_01110000_11110000_01111100_00001111_00111111_10000000_11111111_00000000_00011001_01000011_11111111_01111100_11110000_11000000_01111111_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let c_biguint = a_biguint.clone() ^ b_biguint.clone();
    
    println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_00000000_11111111_00000000_00000000_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_01001100_01110000_11110000_01111100_00001111_11000000_01111111_00000000_11111111");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let c_biguint = a_biguint.clone() ^ b_biguint.clone();
    
    println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(c_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(c_biguint.is_overflow(), false);
    assert_eq!(c_biguint.is_underflow(), false);
    assert_eq!(c_biguint.is_infinity(), false);
    assert_eq!(c_biguint.is_undefined(), false);
    assert_eq!(c_biguint.is_divided_by_zero(), false);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    let _c_biguint = a_biguint ^ b_biguint;
    // It cannot be compiled!
    // println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ^ swallowed (took the ownership of) a_biguint and b_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::max();
    let _c_biguint = a_biguint ^ b_biguint;
    // It cannot be compiled!
    // println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ^ swallowed (took the ownership of) a_biguint and b_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let b_biguint = U256::zero();
    let _c_biguint = a_biguint ^ b_biguint;
    // It cannot be compiled!
    // println!("{} ^ {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), b_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _c_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ^ swallowed (took the ownership of) a_biguint and b_biguint.
    println!("---------------------------");
}

fn biguint_operator_xor_assign()
{
    println!("biguint_operator_xor_assign");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint ^= b_biguint.clone();
    println!("After a_biguint ^= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_11111111_00000000_11111111_00000000_11111111_11111111_00000000_11111111_11111111_00000000_00000000_10110011_01110000_11110000_01111100_00001111_00111111_10000000_11111111_00000000_00011001_01000011_11111111_01111100_11110000_11000000_01111111_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::max();
    a_biguint ^= b_biguint.clone();
    println!("After a_biguint ^= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_00000000_11111111_00000000_00000000_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_01001100_01110000_11110000_01111100_00001111_11000000_01111111_00000000_11111111");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let b_biguint = U256::zero();
    a_biguint ^= b_biguint.clone();
    println!("After a_biguint ^= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), "10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000");
    assert_eq!(a_biguint.is_overflow(), false);
    assert_eq!(a_biguint.is_underflow(), false);
    assert_eq!(a_biguint.is_infinity(), false);
    assert_eq!(a_biguint.is_undefined(), false);
    assert_eq!(a_biguint.is_divided_by_zero(), false);

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::from_str_radix("11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000_10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000", 2).unwrap();
    a_biguint ^= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint ^= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ^= swallowed (took the ownership of) b_biguint.

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::max();
    a_biguint ^= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint ^= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ^= swallowed (took the ownership of) b_biguint.

    let mut a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    println!("Originally, a_biguint = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    let b_biguint = U256::zero();
    a_biguint ^= b_biguint;
    // It cannot be compiled!
    // println!("After a_biguint ^= {}, a_biguint = {}.", b_biguint, a_biguint.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ^= swallowed (took the ownership of) b_biguint.
    println!("---------------------------");
}

fn biguint_operator_flip()
{
    println!("biguint_operator_flip");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let res = !a_biguint.clone();
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "1010101_00110011_00001111_00000000_11111111_00000000_00000000_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_00000000_11111111_11111111_11111111_11111111_01001100_01110000_11110000_01111100_00001111_11000000_01111111_00000000_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::max();
    let res = !a_biguint.clone();
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string(), "0");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    let a_biguint = U256::zero();
    let res = !a_biguint.clone();
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), res.to_string_with_radix_and_stride(2, 8).unwrap());
    assert_eq!(res.to_string_with_radix_and_stride(2, 8).unwrap(), "11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111");
    assert_eq!(res.is_overflow(), false);
    assert_eq!(res.is_underflow(), false);
    assert_eq!(res.is_infinity(), false);
    assert_eq!(res.is_undefined(), false);
    assert_eq!(res.is_divided_by_zero(), false);

    #[cfg(test)] // It cannot be compiled!
    biguint_compile_fail_operator_flip();
    println!("---------------------------");
}

#[test]
fn biguint_compile_fail_operator_flip()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let _res = !a_biguint;

    #[cfg(compile_fail)]
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ! swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let _res = !a_biguint;
    
    #[cfg(compile_fail)]
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ! swallowed (took the ownership of) a_biguint.

    let a_biguint = U256::from_str_radix("10101010_11001100_11110000_11111111_00000000_11111111_11111111_00000000_00000000_11111111_11111111_11111111_00000000_00000000_00000000_11111111_11111111_11111111_11111111_00000000_00000000_00000000_00000000_10110011_10001111_00001111_10000011_11110000_00111111_10000000_11111111_00000000", 2).unwrap();
    let _res = !a_biguint;
    
    #[cfg(compile_fail)]
    println!("! {} = {}", a_biguint.to_string_with_radix_and_stride(2, 8).unwrap(), _res.to_string_with_radix_and_stride(2, 8).unwrap());
    // The operator ! swallowed (took the ownership of) a_biguint.
}



fn biguint_operators_miscellaneous_main()
{
    biguint_operator_eq();
    biguint_operator_lt();
    biguint_operator_gt();
    biguint_operator_le();
    biguint_operator_ge();
}

fn biguint_operator_eq()
{
    println!("biguint_operator_eq");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint == b_uint;
    if res
        { println!("{} == {}", a_biguint, b_uint); }
    else
        { println!("{} != {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint == b_uint;
    if res
        { println!("{} == {}", a_biguint, b_uint); }
    else
        { println!("{} != {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint != b_uint;
    if res
        { println!("{} != {}", a_biguint, b_uint); }
    else
        { println!("{} == {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint != b_uint;
    if res
        { println!("{} != {}", a_biguint, b_uint); }
    else
        { println!("{} == {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint == b_biguint;
    if res
        { println!("{} = {}", a_biguint, b_biguint); }
    else
        { println!("{} != {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint == b_biguint;
    if res
        { println!("{} = {}", a_biguint, b_biguint); }
    else
        { println!("{} != {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint != b_biguint;
    if res
        { println!("{} != {}", a_biguint, b_biguint); }
    else
        { println!("{} == {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint != b_biguint;
    if res
        { println!("{} != {}", a_biguint, b_biguint); }
    else
        { println!("{} == {}", a_biguint, b_biguint); }
    assert_eq!(res, true);
    println!("---------------------------");
}

fn biguint_operator_lt()
{
    println!("biguint_operator_lt");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint < b_uint;
    if res
        { println!("{} < {}", a_biguint, b_uint); }
    else
        { println!("{} >= {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint < b_uint;
    if res
        { println!("{} < {}", a_biguint, b_uint); }
    else
        { println!("{} >= {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint < b_uint;
    if res
        { println!("{} < {}", a_biguint, b_uint); }
    else
        { println!("{} >= {}", a_biguint, b_uint); }
    assert_eq!(res, false);
    
    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint < b_biguint;
    if res
        { println!("{} < {}", a_biguint, b_biguint); }
    else
        { println!("{} >= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint < b_biguint;
    if res
        { println!("{} < {}", a_biguint, b_biguint); }
    else
        { println!("{} >= {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint < b_biguint;
    if res
        { println!("{} < {}", a_biguint, b_biguint); }
    else
        { println!("{} >= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);
    println!("---------------------------");
}

fn biguint_operator_gt()
{
    println!("biguint_operator_gt");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint > b_uint;
    if res
        { println!("{} > {}", a_biguint, b_uint); }
    else
        { println!("{} <= {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint > b_uint;
    if res
        { println!("{} > {}", a_biguint, b_uint); }
    else
        { println!("{} <= {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint > b_uint;
    if res
        { println!("{} > {}", a_biguint, b_uint); }
    else
        { println!("{} <= {}", a_biguint, b_uint); }
    assert_eq!(res, false);
    
    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint > b_biguint;
    if res
        { println!("{} > {}", a_biguint, b_biguint); }
    else
        { println!("{} <= {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint > b_biguint;
    if res
        { println!("{} > {}", a_biguint, b_biguint); }
    else
        { println!("{} <= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint > b_biguint;
    if res
        { println!("{} > {}", a_biguint, b_biguint); }
    else
        { println!("{} <= {}", a_biguint, b_biguint); }
    assert_eq!(res, false);
    println!("---------------------------");
}

fn biguint_operator_le()
{
    println!("biguint_operator_le");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    
    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint <= b_uint;
    if res
        { println!("{} <= {}", a_biguint, b_uint); }
    else
        { println!("{} > {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint <= b_uint;
    if res
        { println!("{} <= {}", a_biguint, b_uint); }
    else
        { println!("{} > {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint <= b_uint;
    if res
        { println!("{} <= {}", a_biguint, b_uint); }
    else
        { println!("{} > {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint <= b_biguint;
    if res
        { println!("{} <= {}", a_biguint, b_biguint); }
    else
        { println!("{} > {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint <= b_biguint;
    if res
        { println!("{} <= {}", a_biguint, b_biguint); }
    else
        { println!("{} > {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint <= b_biguint;
    if res
        { println!("{} <= {}", a_biguint, b_biguint); }
    else
        { println!("{} > {}", a_biguint, b_biguint); }
    assert_eq!(res, true);
    println!("---------------------------");
}

fn biguint_operator_ge()
{
    println!("biguint_operator_ge");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = UU32::from_uint(200_u8);
    let b_uint = 100_u8;
    let res = a_biguint >= b_uint;
    if res
        { println!("{} >= {}", a_biguint, b_uint); }
    else
        { println!("{} < {}", a_biguint, b_uint); }
    assert_eq!(res, true);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 200_u8;
    let res = a_biguint >= b_uint;
    if res
        { println!("{} >= {}", a_biguint, b_uint); }
    else
        { println!("{} < {}", a_biguint, b_uint); }
    assert_eq!(res, false);

    let a_biguint = UU32::from_uint(100_u8);
    let b_uint = 100_u8;
    let res = a_biguint >= b_uint;
    if res
        { println!("{} >= {}", a_biguint, b_uint); }
    else
        { println!("{} < {}", a_biguint, b_uint); }
    assert_eq!(res, true);
    
    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_uint(100_u8);
    let res = a_biguint >= b_biguint;
    if res
        { println!("{} >= {}", a_biguint, b_biguint); }
    else
        { println!("{} < {}", a_biguint, b_biguint); }
    assert_eq!(res, true);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_uint(100_u8);
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint >= b_biguint;
    if res
        { println!("{} >= {}", a_biguint, b_biguint); }
    else
        { println!("{} < {}", a_biguint, b_biguint); }
    assert_eq!(res, false);

    let num_str = "69743176821145534028236692093846345739169743176821145534028236692093846345739";
    let a_biguint = UU32::from_string(num_str).unwrap();
    let b_biguint = UU32::from_string(num_str).unwrap();
    let res = a_biguint >= b_biguint;
    if res
        { println!("{} >= {}", a_biguint, b_biguint); }
    else
        { println!("{} < {}", a_biguint, b_biguint); }
    assert_eq!(res, true);
    println!("---------------------------");
}


fn biguint_implementation_miscellaneous_main()
{
    biguint_display_fmt_for_biguint();
    biguint_upperhex_fmt_for_biguint();
    biguint_lowerhex_fmt_for_biguint();
    biguint_binary_fmt_for_biguint();
    biguint_octal_fmt_for_biguint();
    biguint_upperexp_fmt_for_biguint();
    biguint_lowerexp_fmt_for_biguint();
    biguint_pointer_fmt_for_biguint();
    biguint_from_from_uint();
    biguint_from_from();
    biguint_from_from_str();
    biguint_number_err();
    biguint_display_fmt_for_numbererr();
}

fn biguint_display_fmt_for_biguint()
{
    println!("biguint_display_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{}", a_biguint);
    assert_eq!(a_biguint.to_string(), "69743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>80}", a_biguint);
    let txt = format!("{:>80}", a_biguint);
    assert_eq!(txt, "   69743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>080}", a_biguint);
    let txt = format!("{:>080}", a_biguint);
    assert_eq!(txt, "00069743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^80}", a_biguint);
    let txt = format!("{:^80}", a_biguint);
    assert_eq!(txt, " 69743176821145534028236692093846345739169743176821145534028236692093846345739  ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^080}", a_biguint);
    let txt = format!("{:^080}", a_biguint);
    assert_eq!(txt, "00069743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<80}", a_biguint);
    let txt = format!("{:<80}", a_biguint);
    assert_eq!(txt, "69743176821145534028236692093846345739169743176821145534028236692093846345739   ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<080}", a_biguint);
    let txt = format!("{:<080}", a_biguint);
    assert_eq!(txt, "00069743176821145534028236692093846345739169743176821145534028236692093846345739");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>80}", a_biguint);
    let txt = format!("{:!>80}", a_biguint);
    assert_eq!(txt, "!!!69743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>080}", a_biguint);
    let txt = format!("{:@>080}", a_biguint);
    assert_eq!(txt, "00069743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^80}", a_biguint);
    let txt = format!("{:#^80}", a_biguint);
    assert_eq!(txt, "#69743176821145534028236692093846345739169743176821145534028236692093846345739##");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^080}", a_biguint);
    let txt = format!("{:$^080}", a_biguint);
    assert_eq!(txt, "00069743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<80}", a_biguint);
    let txt = format!("{:%<80}", a_biguint);
    assert_eq!(txt, "69743176821145534028236692093846345739169743176821145534028236692093846345739%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^<080}", a_biguint);
    let txt = format!("{:^<080}", a_biguint);
    assert_eq!(txt, "00069743176821145534028236692093846345739169743176821145534028236692093846345739");

    let a_biguint = U256::from_str("1234567_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890").unwrap();
    let txt = a_biguint.to_string();
    println!("{}", txt);
    assert_eq!(txt, "12345671234567890123456789012345678901234567890123456789012345678901234567890");
    println!("---------------------------");
}


fn biguint_upperhex_fmt_for_biguint()
{
    println!("biguint_upperhex_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:X}", a_biguint);
    let txt = format!("{:X}", a_biguint);
    assert_eq!(txt, "9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:80X}", a_biguint);
    let txt = format!("{:80X}", a_biguint);
    assert_eq!(txt, "9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B                ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:080X}", a_biguint);
    let txt = format!("{:080X}", a_biguint);
    assert_eq!(txt, "00000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#X}", a_biguint);
    let txt = format!("{:#X}", a_biguint);
    assert_eq!(txt, "0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#80X}", a_biguint);
    let txt = format!("{:#80X}", a_biguint);
    assert_eq!(txt, "0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#080X}", a_biguint);
    let txt = format!("{:#080X}", a_biguint);
    assert_eq!(txt, "0X000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>80X}", a_biguint);
    let txt = format!("{:>80X}", a_biguint);
    assert_eq!(txt, "                9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>080X}", a_biguint);
    let txt = format!("{:>080X}", a_biguint);
    assert_eq!(txt, "00000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^80X}", a_biguint);
    let txt = format!("{:^80X}", a_biguint);
    assert_eq!(txt, "        9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B        ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^080X}", a_biguint);
    let txt = format!("{:^080X}", a_biguint);
    assert_eq!(txt, "00000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<80X}", a_biguint);
    let txt = format!("{:<80X}", a_biguint);
    assert_eq!(txt, "9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B                ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<080X}", a_biguint);
    let txt = format!("{:<080X}", a_biguint);
    assert_eq!(txt, "00000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>80X}", a_biguint);
    let txt = format!("{:!>80X}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!!!9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>080X}", a_biguint);
    let txt = format!("{:@>080X}", a_biguint);
    assert_eq!(txt, "00000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^80X}", a_biguint);
    let txt = format!("{:#^80X}", a_biguint);
    assert_eq!(txt, "########9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B########");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^080X}", a_biguint);
    let txt = format!("{:$^080X}", a_biguint);
    assert_eq!(txt, "00000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<80X}", a_biguint);
    let txt = format!("{:%<80X}", a_biguint);
    assert_eq!(txt, "9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B%%%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:*<080X}", a_biguint);
    let txt = format!("{:*<080X}", a_biguint);
    assert_eq!(txt, "00000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#80X}", a_biguint);
    let txt = format!("{:>#80X}", a_biguint);
    assert_eq!(txt, "              0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#080X}", a_biguint);
    let txt = format!("{:>#080X}", a_biguint);
    assert_eq!(txt, "0X000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#80X}", a_biguint);
    let txt = format!("{:^#80X}", a_biguint);
    assert_eq!(txt, "       0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B       ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#080X}", a_biguint);
    let txt = format!("{:^#080X}", a_biguint);
    assert_eq!(txt, "0X000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#80X}", a_biguint);
    let txt = format!("{:<#80X}", a_biguint);
    assert_eq!(txt, "0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#080X}", a_biguint);
    let txt = format!("{:<#080X}", a_biguint);
    assert_eq!(txt, "0X000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>#80X}", a_biguint);
    let txt = format!("{:!>#80X}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>#080X}", a_biguint);
    let txt = format!("{:@>#080X}", a_biguint);
    assert_eq!(txt, "0X000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^#80X}", a_biguint);
    let txt = format!("{:#^#80X}", a_biguint);
    assert_eq!(txt, "#######0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B#######");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^#080X}", a_biguint);
    let txt = format!("{:$^#080X}", a_biguint);
    assert_eq!(txt, "0X000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<#80X}", a_biguint);
    let txt = format!("{:%<#80X}", a_biguint);
    assert_eq!(txt, "0X9A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^<#080X}", a_biguint);
    let txt = format!("{:^<#080X}", a_biguint);
    assert_eq!(txt, "0X000000000000009A313D3C55B12353228024CDBE156C443888E78AD3E424DBC43036A7788AD80B");
    println!("---------------------------");
}

fn biguint_lowerhex_fmt_for_biguint()
{
    println!("biguint_lowerhex_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:x}", a_biguint);
    let txt = format!("{:x}", a_biguint);
    assert_eq!(txt, "9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:80x}", a_biguint);
    let txt = format!("{:80x}", a_biguint);
    assert_eq!(txt, "9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b                ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:080x}", a_biguint);
    let txt = format!("{:080x}", a_biguint);
    assert_eq!(txt, "00000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#x}", a_biguint);
    let txt = format!("{:#x}", a_biguint);
    assert_eq!(txt, "0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#80x}", a_biguint);
    let txt = format!("{:#80x}", a_biguint);
    assert_eq!(txt, "0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#080x}", a_biguint);
    let txt = format!("{:#080x}", a_biguint);
    assert_eq!(txt, "0x000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>80x}", a_biguint);
    let txt = format!("{:>80x}", a_biguint);
    assert_eq!(txt, "                9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>080x}", a_biguint);
    let txt = format!("{:>080x}", a_biguint);
    assert_eq!(txt, "00000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^80x}", a_biguint);
    let txt = format!("{:^80x}", a_biguint);
    assert_eq!(txt, "        9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b        ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^080x}", a_biguint);
    let txt = format!("{:^080x}", a_biguint);
    assert_eq!(txt, "00000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<80x}", a_biguint);
    let txt = format!("{:<80x}", a_biguint);
    assert_eq!(txt, "9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b                ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<080x}", a_biguint);
    let txt = format!("{:<080x}", a_biguint);
    assert_eq!(txt, "00000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>80x}", a_biguint);
    let txt = format!("{:!>80x}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!!!9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>080x}", a_biguint);
    let txt = format!("{:@>080x}", a_biguint);
    assert_eq!(txt, "00000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^80x}", a_biguint);
    let txt = format!("{:#^80x}", a_biguint);
    assert_eq!(txt, "########9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b########");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^080x}", a_biguint);
    let txt = format!("{:$^080x}", a_biguint);
    assert_eq!(txt, "00000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<80x}", a_biguint);
    let txt = format!("{:%<80x}", a_biguint);
    assert_eq!(txt, "9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b%%%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:*<080x}", a_biguint);
    let txt = format!("{:*<080x}", a_biguint);
    assert_eq!(txt, "00000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#80x}", a_biguint);
    let txt = format!("{:>#80x}", a_biguint);
    assert_eq!(txt, "              0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#080x}", a_biguint);
    let txt = format!("{:>#080x}", a_biguint);
    assert_eq!(txt, "0x000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#80x}", a_biguint);
    let txt = format!("{:^#80x}", a_biguint);
    assert_eq!(txt, "       0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b       ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#080x}", a_biguint);
    let txt = format!("{:^#080x}", a_biguint);
    assert_eq!(txt, "0x000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#80x}", a_biguint);
    let txt = format!("{:<#80x}", a_biguint);
    assert_eq!(txt, "0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#080x}", a_biguint);
    let txt = format!("{:<#080x}", a_biguint);
    assert_eq!(txt, "0x000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>#80x}", a_biguint);
    let txt = format!("{:!>#80x}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>#080x}", a_biguint);
    let txt = format!("{:@>#080x}", a_biguint);
    assert_eq!(txt, "0x000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^#80x}", a_biguint);
    let txt = format!("{:#^#80x}", a_biguint);
    assert_eq!(txt, "#######0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b#######");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^#080x}", a_biguint);
    let txt = format!("{:$^#080x}", a_biguint);
    assert_eq!(txt, "0x000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<#80x}", a_biguint);
    let txt = format!("{:%<#80x}", a_biguint);
    assert_eq!(txt, "0x9a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^<#080x}", a_biguint);
    let txt = format!("{:^<#080x}", a_biguint);
    assert_eq!(txt, "0x000000000000009a313d3c55b12353228024cdbe156c443888e78ad3e424dbc43036a7788ad80b");
    println!("---------------------------");
}

fn biguint_binary_fmt_for_biguint()
{
    println!("biguint_binary_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:b}", a_biguint);
    let txt = format!("{:b}", a_biguint);
    assert_eq!(txt, "1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap(); 
    println!("{:272b}", a_biguint);
    let txt = format!("{:272b}", a_biguint);
    assert_eq!(txt, "1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011                ");
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:0272b}", a_biguint);
    let txt = format!("{:0272b}", a_biguint);
    assert_eq!(txt, "00000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#b}", a_biguint);
    let txt = format!("{:#b}", a_biguint);
    assert_eq!(txt, "0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#272b}", a_biguint);
    let txt = format!("{:#272b}", a_biguint);
    assert_eq!(txt, "0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#0272b}", a_biguint);
    let txt = format!("{:#0272b}", a_biguint);
    assert_eq!(txt, "0b000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>272b}", a_biguint);
    let txt = format!("{:>272b}", a_biguint);
    assert_eq!(txt, "                1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>0272b}", a_biguint);
    let txt = format!("{:>0272b}", a_biguint);
    assert_eq!(txt, "00000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^272b}", a_biguint);
    let txt = format!("{:^272b}", a_biguint);
    assert_eq!(txt, "        1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011        ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^0272b}", a_biguint);
    let txt = format!("{:^0272b}", a_biguint);
    assert_eq!(txt, "00000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<272b}", a_biguint);
    let txt = format!("{:<272b}", a_biguint);
    assert_eq!(txt, "1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011                ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<0272b}", a_biguint);
    let txt = format!("{:<0272b}", a_biguint);
    assert_eq!(txt, "00000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>272b}", a_biguint);
    let txt = format!("{:!>272b}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!!!1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>0272b}", a_biguint);
    let txt = format!("{:@>0272b}", a_biguint);
    assert_eq!(txt, "00000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^272b}", a_biguint);
    let txt = format!("{:#^272b}", a_biguint);
    assert_eq!(txt, "########1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011########");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^0272b}", a_biguint);
    let txt = format!("{:$^0272b}", a_biguint);
    assert_eq!(txt, "00000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<272b}", a_biguint);
    let txt = format!("{:%<272b}", a_biguint);
    assert_eq!(txt, "1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011%%%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:*<0272b}", a_biguint);
    let txt = format!("{:*<0272b}", a_biguint);
    assert_eq!(txt, "00000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#272b}", a_biguint);
    let txt = format!("{:>#272b}", a_biguint);
    assert_eq!(txt, "              0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#0272b}", a_biguint);
    let txt = format!("{:>#0272b}", a_biguint);
    assert_eq!(txt, "0b000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#272b}", a_biguint);
    let txt = format!("{:^#272b}", a_biguint);
    assert_eq!(txt, "       0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011       ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#0272b}", a_biguint);
    let txt = format!("{:^#0272b}", a_biguint);
    assert_eq!(txt, "0b000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#272b}", a_biguint);
    let txt = format!("{:<#272b}", a_biguint);
    assert_eq!(txt, "0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#0272b}", a_biguint);
    let txt = format!("{:<#0272b}", a_biguint);
    assert_eq!(txt, "0b000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>#272b}", a_biguint);
    let txt = format!("{:!>#272b}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>#0272b}", a_biguint);
    let txt = format!("{:@>#0272b}", a_biguint);
    assert_eq!(txt, "0b000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^#272b}", a_biguint);
    let txt = format!("{:#^#272b}", a_biguint);
    assert_eq!(txt, "#######0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011#######");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^#0272b}", a_biguint);
    let txt = format!("{:$^#0272b}", a_biguint);
    assert_eq!(txt, "0b000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<#272b}", a_biguint);
    let txt = format!("{:%<#272b}", a_biguint);
    assert_eq!(txt, "0b1001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^<#0272b}", a_biguint);
    let txt = format!("{:^<#0272b}", a_biguint);
    assert_eq!(txt, "0b000000000000001001101000110001001111010011110001010101101100010010001101010011001000101000000000100100110011011011111000010101011011000100010000111000100010001110011110001010110100111110010000100100110110111100010000110000001101101010011101111000100010101101100000001011");
    println!("---------------------------");
}

fn biguint_octal_fmt_for_biguint()
{
    println!("biguint_octal_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:o}", a_biguint);
    let txt = format!("{:o}", a_biguint);
    assert_eq!(txt, "11506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap(); 
    println!("{:102o}", a_biguint);
    let txt = format!("{:102o}", a_biguint);
    assert_eq!(txt, "11506117236125542215231050004463337025330420704216361264762044667420601552357042554013                ");
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:0102o}", a_biguint);
    let txt = format!("{:0102o}", a_biguint);
    assert_eq!(txt, "000000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#o}", a_biguint);
    let txt = format!("{:#o}", a_biguint);
    assert_eq!(txt, "0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#102o}", a_biguint);
    let txt = format!("{:#102o}", a_biguint);
    assert_eq!(txt, "0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#0102o}", a_biguint);
    let txt = format!("{:#0102o}", a_biguint);
    assert_eq!(txt, "0o0000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>102o}", a_biguint);
    let txt = format!("{:>102o}", a_biguint);
    assert_eq!(txt, "                11506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>0102o}", a_biguint);
    let txt = format!("{:>0102o}", a_biguint);
    assert_eq!(txt, "000000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^102o}", a_biguint);
    let txt = format!("{:^102o}", a_biguint);
    assert_eq!(txt, "        11506117236125542215231050004463337025330420704216361264762044667420601552357042554013        ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^0102o}", a_biguint);
    let txt = format!("{:^0102o}", a_biguint);
    assert_eq!(txt, "000000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<102o}", a_biguint);
    let txt = format!("{:<102o}", a_biguint);
    assert_eq!(txt, "11506117236125542215231050004463337025330420704216361264762044667420601552357042554013                ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<0102o}", a_biguint);
    let txt = format!("{:<0102o}", a_biguint);
    assert_eq!(txt, "000000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>102o}", a_biguint);
    let txt = format!("{:!>102o}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!!!11506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>0102o}", a_biguint);
    let txt = format!("{:@>0102o}", a_biguint);
    assert_eq!(txt, "000000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^102o}", a_biguint);
    let txt = format!("{:#^102o}", a_biguint);
    assert_eq!(txt, "########11506117236125542215231050004463337025330420704216361264762044667420601552357042554013########");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^0102o}", a_biguint);
    let txt = format!("{:$^0102o}", a_biguint);
    assert_eq!(txt, "000000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<102o}", a_biguint);
    let txt = format!("{:%<102o}", a_biguint);
    assert_eq!(txt, "11506117236125542215231050004463337025330420704216361264762044667420601552357042554013%%%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:*<0102o}", a_biguint);
    let txt = format!("{:*<0102o}", a_biguint);
    assert_eq!(txt, "000000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#102o}", a_biguint);
    let txt = format!("{:>#102o}", a_biguint);
    assert_eq!(txt, "              0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:>#0102o}", a_biguint);
    let txt = format!("{:>#0102o}", a_biguint);
    assert_eq!(txt, "0o0000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#102o}", a_biguint);
    let txt = format!("{:^#102o}", a_biguint);
    assert_eq!(txt, "       0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013       ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^#0102o}", a_biguint);
    let txt = format!("{:^#0102o}", a_biguint);
    assert_eq!(txt, "0o0000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#102o}", a_biguint);
    let txt = format!("{:<#102o}", a_biguint);
    assert_eq!(txt, "0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013              ");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:<#0102o}", a_biguint);
    let txt = format!("{:<#0102o}", a_biguint);
    assert_eq!(txt, "0o0000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");
    
    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:!>#102o}", a_biguint);
    let txt = format!("{:!>#102o}", a_biguint);
    assert_eq!(txt, "!!!!!!!!!!!!!!0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:@>#0102o}", a_biguint);
    let txt = format!("{:@>#0102o}", a_biguint);
    assert_eq!(txt, "0o0000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:#^#102o}", a_biguint);
    let txt = format!("{:#^#102o}", a_biguint);
    assert_eq!(txt, "#######0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013#######");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:$^#0102o}", a_biguint);
    let txt = format!("{:$^#0102o}", a_biguint);
    assert_eq!(txt, "0o0000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:%<#102o}", a_biguint);
    let txt = format!("{:%<#102o}", a_biguint);
    assert_eq!(txt, "0o11506117236125542215231050004463337025330420704216361264762044667420601552357042554013%%%%%%%%%%%%%%");

    let a_biguint = U256::from_str("69743176821145534028236692093846345739169743176821145534028236692093846345739").unwrap();
    println!("{:^<#0102o}", a_biguint);
    let txt = format!("{:^<#0102o}", a_biguint);
    assert_eq!(txt, "0o0000000000000011506117236125542215231050004463337025330420704216361264762044667420601552357042554013");
    println!("---------------------------");
}

fn biguint_upperexp_fmt_for_biguint()
{
    println!("biguint_upperexp_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:E}", a_biguint);
    let txt = format!("{:E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:100E}", a_biguint);
    let txt = format!("{:100E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76                   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:0100E}", a_biguint);
    let txt = format!("{:0100E}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:20.9E}", a_biguint);
    let txt = format!("{:20.9E}", a_biguint);
    assert_eq!(txt, "1.234567890E76      ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:020.9E}", a_biguint);
    let txt = format!("{:020.9E}", a_biguint);
    assert_eq!(txt, "0000001.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:21.13E}", a_biguint);
    let txt = format!("{:21.13E}", a_biguint);
    assert_eq!(txt, "1.2345678901235E76   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:021.13E}", a_biguint);
    let txt = format!("{:021.13E}", a_biguint);
    assert_eq!(txt, "0001.2345678901235E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<E}", a_biguint);
    let txt = format!("{:<E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<100E}", a_biguint);
    let txt = format!("{:<100E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76                   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<0100E}", a_biguint);
    let txt = format!("{:<0100E}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<20.9E}", a_biguint);
    let txt = format!("{:<20.9E}", a_biguint);
    assert_eq!(txt, "1.234567890E76      ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<020.9E}", a_biguint);
    let txt = format!("{:<020.9E}", a_biguint);
    assert_eq!(txt, "0000001.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<21.13E}", a_biguint);
    let txt = format!("{:<21.13E}", a_biguint);
    assert_eq!(txt, "1.2345678901235E76   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<021.13E}", a_biguint);
    let txt = format!("{:<021.13E}", a_biguint);
    assert_eq!(txt, "0001.2345678901235E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:!<E}", a_biguint);
    let txt = format!("{:<E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:@<100E}", a_biguint);
    let txt = format!("{:@<100E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76@@@@@@@@@@@@@@@@@@@");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:#<0100E}", a_biguint);
    let txt = format!("{:#<0100E}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:$<20.9E}", a_biguint);
    let txt = format!("{:$<20.9E}", a_biguint);
    assert_eq!(txt, "1.234567890E76$$$$$$");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:%<020.9E}", a_biguint);
    let txt = format!("{:%<020.9E}", a_biguint);
    assert_eq!(txt, "0000001.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^<21.13E}", a_biguint);
    let txt = format!("{:^<21.13E}", a_biguint);
    assert_eq!(txt, "1.2345678901235E76^^^");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:&<021.13E}", a_biguint);
    let txt = format!("{:&<021.13E}", a_biguint);
    assert_eq!(txt, "0001.2345678901235E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>E}", a_biguint);
    let txt = format!("{:>E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>100E}", a_biguint);
    let txt = format!("{:>100E}", a_biguint);
    assert_eq!(txt, "                   1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>0100E}", a_biguint);
    let txt = format!("{:>0100E}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>20.9E}", a_biguint);
    let txt = format!("{:>20.9E}", a_biguint);
    assert_eq!(txt, "      1.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>020.9E}", a_biguint);
    let txt = format!("{:>020.9E}", a_biguint);
    assert_eq!(txt, "0000001.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>21.13E}", a_biguint);
    let txt = format!("{:>21.13E}", a_biguint);
    assert_eq!(txt, "   1.2345678901235E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>021.13E}", a_biguint);
    let txt = format!("{:>021.13E}", a_biguint);
    assert_eq!(txt, "0001.2345678901235E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:!>E}", a_biguint);
    let txt = format!("{:>E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:@>100E}", a_biguint);
    let txt = format!("{:@>100E}", a_biguint);
    assert_eq!(txt, "@@@@@@@@@@@@@@@@@@@1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:#>0100E}", a_biguint);
    let txt = format!("{:#>0100E}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:$>20.9E}", a_biguint);
    let txt = format!("{:$>20.9E}", a_biguint);
    assert_eq!(txt, "$$$$$$1.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:%>020.9E}", a_biguint);
    let txt = format!("{:%>020.9E}", a_biguint);
    assert_eq!(txt, "0000001.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^>21.13E}", a_biguint);
    let txt = format!("{:^>21.13E}", a_biguint);
    assert_eq!(txt, "^^^1.2345678901235E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:&>021.13E}", a_biguint);
    let txt = format!("{:&>021.13E}", a_biguint);
    assert_eq!(txt, "0001.2345678901235E76");
    
    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^E}", a_biguint);
    let txt = format!("{:^E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^100E}", a_biguint);
    let txt = format!("{:^100E}", a_biguint);
    assert_eq!(txt, "         1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76          ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^0100E}", a_biguint);
    let txt = format!("{:^0100E}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^20.9E}", a_biguint);
    let txt = format!("{:^20.9E}", a_biguint);
    assert_eq!(txt, "   1.234567890E76   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^020.9E}", a_biguint);
    let txt = format!("{:^020.9E}", a_biguint);
    assert_eq!(txt, "0000001.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^21.13E}", a_biguint);
    let txt = format!("{:^21.13E}", a_biguint);
    assert_eq!(txt, " 1.2345678901235E76  ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^021.13E}", a_biguint);
    let txt = format!("{:^021.13E}", a_biguint);
    assert_eq!(txt, "0001.2345678901235E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:!^E}", a_biguint);
    let txt = format!("{:^E}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:@^100E}", a_biguint);
    let txt = format!("{:@^100E}", a_biguint);
    assert_eq!(txt, "@@@@@@@@@1.2345678901234567890123456789012345678901234567890123456789012345678901234567E76@@@@@@@@@@");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:#^0100E}", a_biguint);
    let txt = format!("{:#^0100E}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:$^20.9E}", a_biguint);
    let txt = format!("{:$^20.9E}", a_biguint);
    assert_eq!(txt, "$$$1.234567890E76$$$");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:%^020.9E}", a_biguint);
    let txt = format!("{:%^020.9E}", a_biguint);
    assert_eq!(txt, "0000001.234567890E76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^^21.13E}", a_biguint);
    let txt = format!("{:^^21.13E}", a_biguint);
    assert_eq!(txt, "^1.2345678901235E76^^");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:&^021.13E}", a_biguint);
    let txt = format!("{:&^021.13E}", a_biguint);
    assert_eq!(txt, "0001.2345678901235E76");
    println!("---------------------------");
}
fn biguint_lowerexp_fmt_for_biguint()
{
    println!("biguint_lowerexp_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:e}", a_biguint);
    let txt = format!("{:e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:100e}", a_biguint);
    let txt = format!("{:100e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76                   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:0100e}", a_biguint);
    let txt = format!("{:0100e}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:20.9e}", a_biguint);
    let txt = format!("{:20.9e}", a_biguint);
    assert_eq!(txt, "1.234567890e76      ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:020.9e}", a_biguint);
    let txt = format!("{:020.9e}", a_biguint);
    assert_eq!(txt, "0000001.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:21.13e}", a_biguint);
    let txt = format!("{:21.13e}", a_biguint);
    assert_eq!(txt, "1.2345678901235e76   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:021.13e}", a_biguint);
    let txt = format!("{:021.13e}", a_biguint);
    assert_eq!(txt, "0001.2345678901235e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<e}", a_biguint);
    let txt = format!("{:<e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<100e}", a_biguint);
    let txt = format!("{:<100e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76                   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<0100e}", a_biguint);
    let txt = format!("{:<0100e}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<20.9e}", a_biguint);
    let txt = format!("{:<20.9e}", a_biguint);
    assert_eq!(txt, "1.234567890e76      ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<020.9e}", a_biguint);
    let txt = format!("{:<020.9e}", a_biguint);
    assert_eq!(txt, "0000001.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<21.13e}", a_biguint);
    let txt = format!("{:<21.13e}", a_biguint);
    assert_eq!(txt, "1.2345678901235e76   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<021.13e}", a_biguint);
    let txt = format!("{:<021.13e}", a_biguint);
    assert_eq!(txt, "0001.2345678901235e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:!<e}", a_biguint);
    let txt = format!("{:<e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:@<100e}", a_biguint);
    let txt = format!("{:@<100e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76@@@@@@@@@@@@@@@@@@@");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:#<0100e}", a_biguint);
    let txt = format!("{:#<0100e}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:$<20.9e}", a_biguint);
    let txt = format!("{:$<20.9e}", a_biguint);
    assert_eq!(txt, "1.234567890e76$$$$$$");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:%<020.9e}", a_biguint);
    let txt = format!("{:%<020.9e}", a_biguint);
    assert_eq!(txt, "0000001.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^<21.13e}", a_biguint);
    let txt = format!("{:^<21.13e}", a_biguint);
    assert_eq!(txt, "1.2345678901235e76^^^");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:&<021.13e}", a_biguint);
    let txt = format!("{:&<021.13e}", a_biguint);
    assert_eq!(txt, "0001.2345678901235e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>e}", a_biguint);
    let txt = format!("{:>e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>100e}", a_biguint);
    let txt = format!("{:>100e}", a_biguint);
    assert_eq!(txt, "                   1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>0100e}", a_biguint);
    let txt = format!("{:>0100e}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>20.9e}", a_biguint);
    let txt = format!("{:>20.9e}", a_biguint);
    assert_eq!(txt, "      1.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>020.9e}", a_biguint);
    let txt = format!("{:>020.9e}", a_biguint);
    assert_eq!(txt, "0000001.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>21.13e}", a_biguint);
    let txt = format!("{:>21.13e}", a_biguint);
    assert_eq!(txt, "   1.2345678901235e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>021.13e}", a_biguint);
    let txt = format!("{:>021.13e}", a_biguint);
    assert_eq!(txt, "0001.2345678901235e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:!>e}", a_biguint);
    let txt = format!("{:>e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:@>100e}", a_biguint);
    let txt = format!("{:@>100e}", a_biguint);
    assert_eq!(txt, "@@@@@@@@@@@@@@@@@@@1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:#>0100e}", a_biguint);
    let txt = format!("{:#>0100e}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:$>20.9e}", a_biguint);
    let txt = format!("{:$>20.9e}", a_biguint);
    assert_eq!(txt, "$$$$$$1.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:%>020.9e}", a_biguint);
    let txt = format!("{:%>020.9e}", a_biguint);
    assert_eq!(txt, "0000001.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^>21.13e}", a_biguint);
    let txt = format!("{:^>21.13e}", a_biguint);
    assert_eq!(txt, "^^^1.2345678901235e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:&>021.13e}", a_biguint);
    let txt = format!("{:&>021.13e}", a_biguint);
    assert_eq!(txt, "0001.2345678901235e76");
    
    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^e}", a_biguint);
    let txt = format!("{:^e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^100e}", a_biguint);
    let txt = format!("{:^100e}", a_biguint);
    assert_eq!(txt, "         1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76          ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^0100e}", a_biguint);
    let txt = format!("{:^0100e}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^20.9e}", a_biguint);
    let txt = format!("{:^20.9e}", a_biguint);
    assert_eq!(txt, "   1.234567890e76   ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^020.9e}", a_biguint);
    let txt = format!("{:^020.9e}", a_biguint);
    assert_eq!(txt, "0000001.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^21.13e}", a_biguint);
    let txt = format!("{:^21.13e}", a_biguint);
    assert_eq!(txt, " 1.2345678901235e76  ");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^021.13e}", a_biguint);
    let txt = format!("{:^021.13e}", a_biguint);
    assert_eq!(txt, "0001.2345678901235e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:!^e}", a_biguint);
    let txt = format!("{:^e}", a_biguint);
    assert_eq!(txt, "1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:@^100e}", a_biguint);
    let txt = format!("{:@^100e}", a_biguint);
    assert_eq!(txt, "@@@@@@@@@1.2345678901234567890123456789012345678901234567890123456789012345678901234567e76@@@@@@@@@@");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:#^0100e}", a_biguint);
    let txt = format!("{:#^0100e}", a_biguint);
    assert_eq!(txt, "00000000000000000001.2345678901234567890123456789012345678901234567890123456789012345678901234567e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:$^20.9e}", a_biguint);
    let txt = format!("{:$^20.9e}", a_biguint);
    assert_eq!(txt, "$$$1.234567890e76$$$");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:%^020.9e}", a_biguint);
    let txt = format!("{:%^020.9e}", a_biguint);
    assert_eq!(txt, "0000001.234567890e76");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^^21.13e}", a_biguint);
    let txt = format!("{:^^21.13e}", a_biguint);
    assert_eq!(txt, "^1.2345678901235e76^^");

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:&^021.13e}", a_biguint);
    let txt = format!("{:&^021.13e}", a_biguint);
    assert_eq!(txt, "0001.2345678901235e76");
    println!("---------------------------");
}
fn biguint_pointer_fmt_for_biguint()
{
    println!("biguint_pointer_fmt_for_biguint()");
    use std::str::FromStr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:p}", a_biguint);
    let txt = format!("{:p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958aab0"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:20p}", a_biguint);
    let txt = format!("{:20p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958b0b0      "); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:020p}", a_biguint);
    let txt = format!("{:020p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x0000007ffcd958aae0"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<p}", a_biguint);
    let txt = format!("{:<p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958b0e0"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<20p}", a_biguint);
    let txt = format!("{:<20p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958ab10      "); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:<020p}", a_biguint);
    let txt = format!("{:<020p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x0000007ffcd958b1a0"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:!<p}", a_biguint);
    let txt = format!("{:!<p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958ab40"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:@<20p}", a_biguint);
    let txt = format!("{:@<20p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958b1d0@@@@@@"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:#<020p}", a_biguint);
    let txt = format!("{:#<020p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x0000007ffcd958ab70"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>p}", a_biguint);
    let txt = format!("{:>p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958b200"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>20p}", a_biguint);
    let txt = format!("{:>20p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "      0x7ffcd958aba0"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:>020p}", a_biguint);
    let txt = format!("{:>020p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x0000007ffcd958b230"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:$>p}", a_biguint);
    let txt = format!("{:$>p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958abd0"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:%>20p}", a_biguint);
    let txt = format!("{:%>20p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "%%%%%%0x7ffcd958b110"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^>020p}", a_biguint);
    let txt = format!("{:^>020p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "00x0000007ffcd958a750"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^p}", a_biguint);
    let txt = format!("{:^p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958a850"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^20p}", a_biguint);
    let txt = format!("{:^20p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "   0x7ffcd958b140   "); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:^020p}", a_biguint);
    let txt = format!("{:^020p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x0000007ffcd958b170"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:&^p}", a_biguint);
    let txt = format!("{:&^p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x7ffcd958af40"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:*^20p}", a_biguint);
    let txt = format!("{:*^20p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "***0x7ffcd958af70***"); // can be different everytime

    let a_biguint = U256::from_str("12345678901234567890123456789012345678901234567890123456789012345678901234567").unwrap();
    println!("{:_^020p}", a_biguint);
    let txt = format!("{:_^020p}", a_biguint);
    println!("{}", txt);
    // assert_eq!(txt, "0x0000007ffcd958afa0"); // can be different everytime
    println!("---------------------------");
}

fn biguint_from_from_uint()
{
    println!("biguint_from_from_uint()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let a_biguint = U256::from(123456789123456789123456789123456789_u128);
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "123456789123456789123456789123456789");
    println!("---------------------------");
}

fn biguint_from_from()
{
    println!("biguint_from_from()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let a_biguint = U256::from([1, 2, 3, 4, 5, 6, 7, 8]);
    println!("a_biguint = {}", a_biguint);
    assert_eq!(a_biguint.to_string(), "215679573381144830513811895868694400695694534256768036697775454289921");
    println!("---------------------------");
}

fn biguint_from_from_str()
{
    println!("biguint_from_from_str()");
    use std::str::FromStr;
    use cryptocol::number::NumberErr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);

    let a_biguint_wrapped = U256::from_str("215679573381144830513811895868694400695694534256768036697775454289921");
    match a_biguint_wrapped
    {
        Ok(a_biguint) => {
                println!("a_biguint = {}", a_biguint);
                assert_eq!(a_biguint.to_string(), "215679573381144830513811895868694400695694534256768036697775454289921");
            },
        Err(e) => { println!("Error: {}", e); }
    }
    
    let a_biguint_wrapped = U256::from_str("@!#$%^&*()_+=-|-/?><`~");
    match a_biguint_wrapped
    {
        Ok(a_biguint) => { println!("a_biguint = {}", a_biguint); },
        Err(e) => {
                println!("Error: {}", e);
                assert_eq!(e, NumberErr::NotAlphaNumeric);
            }
    }

    let a_biguint_wrapped = "215679573381144830513811895868694400695694534256768036697775454289921".parse::<U256>();
    match a_biguint_wrapped
    {
        Ok(a_biguint) => {
                println!("a_biguint = {}", a_biguint);
                assert_eq!(a_biguint.to_string(), "215679573381144830513811895868694400695694534256768036697775454289921");
            },
        Err(e) => { println!("Error: {}", e); }
    }

    let a_biguint_wrapped = "@!#$%^&*()_+=-|-/?><`~".parse::<U256>();
    match a_biguint_wrapped
    {
        Ok(a_biguint) => { println!("a_biguint = {}", a_biguint); },
        Err(e) => {
                println!("Error: {}", e);
                assert_eq!(e, NumberErr::NotAlphaNumeric);
            }
    }
    println!("---------------------------");
}

fn biguint_number_err()
{
    println!("biguint_number_err()");
    use std::str::FromStr;
    use cryptocol::number::NumberErr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint_wrapped = U256::from_str_radix("1234567890_ABCDEF_GHIJKLMN", 100);
    match a_biguint_wrapped
    {
        Ok(a_biguint) => { println!("a_biguint = {}", a_biguint); },
        Err(e) => {
                println!("Error: {}", e);
                assert_eq!(e.to_string(), "The given radix is out of the valid range. It should be in the range from binary up to 62-ary, inclusively.");
                assert_eq!(e, NumberErr::OutOfValidRadixRange);
            }
    }

    let a_biguint_wrapped = U256::from_str("@!#$%^&*()_+=-|-/?><`~");
    match a_biguint_wrapped
    {
        Ok(a_biguint) => { println!("a_biguint = {}", a_biguint); },
        Err(e) => {
                println!("Error: {}", e);
                assert_eq!(e.to_string(), "The string or the character is not alphanumeric.");
                assert_eq!(e, NumberErr::NotAlphaNumeric);
            }
    }
    
    let a_biguint_wrapped = U256::from_str_radix("1234567890_ABCDEF_GHIJKLMN", 16);
    match a_biguint_wrapped
    {
        Ok(a_biguint) => { println!("a_biguint = {}", a_biguint); },
        Err(e) => {
                println!("Error: {}", e);
                assert_eq!(e.to_string(), "The string or the character is not fit to the given radix.");
                assert_eq!(e, NumberErr::NotFitToRadix);
            }
    }

    let a_biguint_wrapped = U256::from_str("1234567891234567879123456789111111111222222222333333333444444444555555555666666666777777777888888888999999999000000000");
    match a_biguint_wrapped
    {
        Ok(a_biguint) => { println!("a_biguint = {}", a_biguint); },
        Err(e) => {
                println!("Error: {}", e);
                assert_eq!(e.to_string(), "The number that the string represents is too big for the created object to contain.");
                assert_eq!(e, NumberErr::TooBigNumber);
            }
    }
    println!("---------------------------");
}

fn biguint_display_fmt_for_numbererr()
{
    println!("biguint_display_fmt_for_numbererr()");
    use cryptocol::number::NumberErr;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a_biguint_wrapped = U256::from_str_radix("1234567890_ABCDEF_GHIJKLMN", 100);
    match a_biguint_wrapped
    {
        Ok(a_biguint) => { println!("a_biguint = {}", a_biguint); },
        Err(e) => {
                println!("Error: {}", e);
                assert_eq!(e.to_string(), "The given radix is out of the valid range. It should be in the range from binary up to 62-ary, inclusively.");
                assert_eq!(e, NumberErr::OutOfValidRadixRange);
            }
    }

    println!("NumberErr::NotAlphaNumeric: {}", NumberErr::NotAlphaNumeric);
    assert_eq!(NumberErr::NotAlphaNumeric.to_string(), "The string or the character is not alphanumeric.");

    let txt = NumberErr::TooBigNumber.to_string();
    println!("Error: {}", txt);
    assert_eq!(txt, "The number that the string represents is too big for the created object to contain.");

    let error = NumberErr::NotFitToRadix;
    println!("NumberErr::NotFitToRadix: {}", error);
    assert_eq!(NumberErr::NotFitToRadix.to_string(), "The string or the character is not fit to the given radix.");
    println!("---------------------------");
}



/*
pub fn find_maximum()
{
    println!("find_maximum()");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);

    let a = U256::from_uint(123_u8);
    let mut exp = U256::one();
    loop {
        let b = a.pow(&exp);
        if b.is_overflow()
        {
            println!("Maximum i is {}", exp);
            break;
        }
        exp.wrapping_add_assign_uint(1_u8);
    }
    println!("---------------------------");
}

pub fn test()
{
    println!("test()");
    use cryptocol::number::*;
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);

    let a = 128_u8;
    let b = a << 1;
    println!("b = {}", b);
    let p = U256::from_uint(12345678901234567890123456789_u128);
    let q = U256::from_uint(12345678901234567890_u128);
    let r = p.gcd(&q);

    println!("{} , {} => {}", p, q, r);

    let a = U256::from_uint(254_u8);
    let b = U256::from_uint(123_u8);
    let c = a.divide_fully(&b);
    let d = a.divide_fully_uint(123_u8);
    let aa = LongerUnion::new_with(254_u128);
    let bb = LongerUnion::new_with(123_u128);

    let cc = aa % bb;

    println!("c: {}  {}", c.0, c.1);
    println!("d: {}  {}", d.0, d.1);
    println!("{}", cc);

    let e = a.divide_fully_uint(4_u8);
    println!("{:?} {:?}", e.0, e.1);

    println!("a == b {}", a == b);
    println!("a != b {}", a != b);
    println!("a > b {}", a > b);
    println!("a >= b {}", a >= b);
    println!("a < b {}", a < b);
    println!("a <= b {}", a <= b);
}




fn biguint_random_number_main()
{
    biguint_any();
    biguint_any_odd();
    biguint_any_less_than();
    biguint_any_odd_less_than();
    biguint_any_with_MSB_set();
    biguint_any_odd_with_MSB_set();
    biguint_any_prime_using_Miller_Rabin();
    biguint_turn_any();
    biguint_random();
    biguint_random_odd();
    biguint_random_less_than();
    biguint_random_odd_less_than();
    biguint_random_with_MSB_set();
    biguint_random_odd_with_MSB_set();
    biguint_random_prime_using_Miller_Rabin();
    biguint_randomize();
    biguint_is_prime_using_miller_rabin();
}

fn biguint_any()
{
    println!("biguint_any");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    println!("Random Number: {}", U1024::any());
    println!("---------------------------");
}

fn biguint_any_odd()
{
    println!("biguint_any_odd");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    let r = U1024::any_odd();
    println!("Random Odd Number: {}", r);
    assert!(r.is_odd());
    println!("---------------------------");
}

fn biguint_any_less_than()
{
    println!("biguint_any_less_than");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);
    let ceiling = U1024::max() / U1024::from_uint::<u32>(3);
    let r = U1024::any_less_than(&ceiling);
    println!("Random Number less than {} is {}", ceiling, r);
    assert!(r < ceiling);
    println!("---------------------------");
}

fn biguint_any_odd_less_than()
{
    println!("biguint_any_odd_less_than");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);
    let ceiling = U1024::max() / U1024::from_uint::<u32>(3);
    let r = U1024::any_odd_less_than(&ceiling);
    println!("Random Odd Number less than {} is {}", ceiling, r);
    assert!(r < ceiling);
    assert!(r.is_odd());
    println!("---------------------------");
}

fn biguint_any_with_MSB_set()
{
    println!("biguint_any_with_MSB_set");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    let num = U1024::any_with_MSB_set();
    println!("Random Number = {}", U1024::any());
    println!("1024-bit Random Number = {}", num);
    assert!(num > U1024::submax(1023));
    println!("---------------------------");
}

fn biguint_any_odd_with_MSB_set()
{
    println!("biguint_any_odd_with_MSB_set");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    let num = U1024::any_odd_with_MSB_set();
    println!("Random Number = {}", U1024::any());
    println!("1024-bit Random Odd Number = {}", num);
    assert!(num > U1024::submax(1023));
    assert!(num.is_odd());
    println!("---------------------------");
}

fn biguint_any_prime_using_Miller_Rabin()
{
    println!("biguint_any_prime_using_Miller_Rabin");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    let num = U256::any_prime_using_Miller_Rabin(5);
    println!("Random Prime Number = {}", num);
    assert!(num.is_prime_using_miller_rabin(5));
    println!("---------------------------");
    
}

fn biguint_turn_any()
{
    println!("biguint_turn_any");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);
    let mut r = U256::new();
    println!("original number = {}", r);
    assert_eq!(r, U256::zero());
    r.turn_any();
    println!("random number = {}", r);
    assert_ne!(r, U256::zero());
    println!("---------------------------");
}


fn biguint_random()
{
    println!("biguint_random");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    println!("Random Number: {}", U1024::random());
    println!("---------------------------");
}

fn biguint_random_odd()
{
    println!("biguint_random_odd");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    let r = U1024::random_odd();
    println!("Random Odd Number: {}", r);
    assert!(r.is_odd());
    println!("---------------------------");
}

fn biguint_random_less_than()
{
    println!("biguint_random_less_than");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);
    let ceiling = U1024::max() / U1024::from_uint::<u32>(3);
    let r = U1024::random_less_than(&ceiling);
    println!("Random Number less than {} is {}", ceiling, r);
    assert!(r < ceiling);
    println!("---------------------------");
}

fn biguint_random_odd_less_than()
{
    println!("biguint_random_odd_less_than");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let ceiling = U1024::max() / U1024::from_uint::<u32>(3);
    let r = U1024::random_odd_less_than(&ceiling);
    println!("Random Odd Number less than {} is {}", ceiling, U1024::random_odd_less_than(&ceiling));
    assert!(r < ceiling);
    assert!(r.is_odd());
    println!("---------------------------");
}

fn biguint_random_with_MSB_set()
{
    println!("biguint_random_with_MSB_set");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    let num = U1024::random_with_MSB_set();
    println!("Random Number = {}", U1024::random());
    println!("1024-bit Random Number = {}", num);
    assert!(num > U1024::submax(1023));
    println!("---------------------------");
}

fn biguint_random_odd_with_MSB_set()
{
    println!("biguint_random_odd_with_MSB_set");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u128);
    let num = U1024::random_odd_with_MSB_set();
    println!("Random Number = {}", U1024::random());
    println!("1024-bit Random Odd Number = {}", num);
    assert!(num > U1024::submax(1023));
    assert!(num.is_odd());
    println!("---------------------------");
}

fn biguint_random_prime_using_Miller_Rabin()
{
    println!("biguint_random_prime_using_Miller_Rabin");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u64);
    let num = U1024::random_prime_using_Miller_Rabin(5);
    assert!(num.is_prime_using_miller_rabin(5));
    println!("Random Prime Number = {}", num);
    println!("---------------------------");
}

fn biguint_randomize()
{
    println!("biguint_randomize");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u32);

    let mut r = U1024::new();
    println!("original number = {}", r);
    assert_eq!(r, U1024::zero());
    r.randomize();
    println!("random number = {}", r);
    assert_ne!(r, U1024::zero());
    println!("---------------------------");
}

fn biguint_is_prime_using_miller_rabin()
{
    println!("biguint_is_prime_using_miller_rabin");
    use cryptocol::define_utypes_with;
    define_utypes_with!(u16);

    let num = U1024::from_string("157847659859841049478697210209054499132116730052547470511818639401226705057924429751936169954758794979780692256039595351594450957429818931145981533862363167515145703012676459279601554094177152095755375227908501443524236048737351327752857335149319939532219166843564206337168180636940438709755340632429325500479").unwrap();
    let yes = num.is_prime_using_miller_rabin(5);
    println!("Is {} a prime number? => {}", num, yes);
    if yes  { assert!(yes); }
    else    { assert!(!yes); }
    println!("---------------------------");
}
*/

/*
fn f()
{
    use cryptocol::define_utypes_with;
    define_utypes_with!(u8);
    let divisor = 87_u8;
    let dividend = 1234567890157589425462369896584689254_u128;
    let dd = U256::from_uint(dividend);
    let (quotient, remainder) = dd.divide_fully_uint(divisor);
    println!("{} - {}", quotient, remainder);
    let (quotient, remainder) = dd.divide_fully(&U256::from_uint(divisor));
    println!("{} - {}", quotient, remainder);

}

fn t_1024()
{
    define_utypes_with!(u128);
    let a = U1024::random();
    println!("{} 비트짜리 난수: {}", 1024, a);
    let b = U1024::from(1_u128);
    println!("{} 비트짜리 1: {}", 1024, b);
    let c = a + b;
    println!("{} + {} = {}", a, b, c);
}

fn t_2048()
{
    define_utypes_with!(u128);
    let a = U2048::random();
    println!("{} 비트짜리 난수: {}", 2048, a);
    let b = U2048::from(1_u128);
    println!("{} 비트짜리 1: {}", 2048, b);
    let c = a + b;
    println!("{} + {} = {}", a, b, c);
}

fn t_4096()
{
    define_utypes_with!(u128);
    let a = U4096::random();
    println!("{} 비트짜리 난수: {}", 4096, a);
    let b = U4096::from(1_u128);
    println!("{} 비트짜리 1: {}", 4096, b);
    let c = a + b;
    println!("{} + {} = {}", a, b, c);
}



fn func<T: Uint + Add<Output = T>>(lhs: T, rhs: T) -> T
{
    lhs + rhs
}
fn func2<T: Uint>(lhs: T, rhs: T) -> T
{
    lhs.wrapping_add(rhs)
}

fn main()
{



    let a = 100;
    let b = a % -3;
    let c = "123456789012".parse::<U256>().unwrap();
    let e = c.to_string_with_radix_and_stride(10, 4);
    let d: u128 = c.into_u128();
    println!("a = {}, b = {}, c = {}, e = {}", a, b, c, e);
    let a = "123_4566".parse::<U256>().unwrap();
    println!("a = {}", a);
    let ss = UShort { byte: [101, 100] };
    unsafe { println!("ss.short = {}", ss.ushort ); }
    println!("{}", (25700_u16 + 25800_u16));

    // a: u16 === (a_high, a_low) == (100_u8, 101u8) == 25701_u16
    let a_high = 100_u8;
    let a_low = 101_u8;
    // b: u16 === (b_high, b_low) == (100_u8, 200u8) == 51300_u16
    let b_high = 100_u8;
    let b_low = 200_u8;
    // c: u16 === (c_high, c_low)
    let c_high: u8;
    let c_low: u8;
    let mut carry: bool;
    // (100_u8, 101_u8) + (100_u8, 200_u8) == 25701_u16 + 25800_u16 == 51501_u16
    (c_high, c_low, carry) = add_long(a_high, a_low, b_high, b_low);
    println!("{}-{}, {}", c_high, c_low, carry);
    assert_eq!(c_high, 201);
    assert_eq!(c_low, 45);
    assert_eq!(carry, false);

    let d_high: u128;
    let d_low: u128;
    let e = BigUInt::<u128, 2>::from_array(&[6789012345678919134, 12345678901234569124]);
    println!("big = {}", e);
    (d_high, d_low, carry) = add_long(12345678901234567890_u128, 6789012345678912345_u128, 1234_u128, 6789_u128);
    println!("{}-{}, {}", d_high, d_low, carry);
    assert_eq!(d_high, 12345678901234569124);
    assert_eq!(d_low, 6789012345678919134);
    assert_eq!(carry, false);
}

fn add_long<T: Uint>(lhs_high: T, lhs_low: T, rhs_high: T, rhs_low: T) -> (T, T, bool)
{
    let mut carry = false;
    let mut sum_high: T;
    let mut sum_low: T;
    (sum_low, carry) = lhs_low.carrying_add(rhs_low, carry);
    (sum_high, carry) = lhs_high.carrying_add(rhs_high, carry);
    (sum_high, sum_low, carry)
}

fn main()
{
    let a = func(50_u128, 4_u128);
    println!("50 + 4 = {}", a);
    assert_eq!(a, 54_u128);

    let b = func2(u8::MAX, u8::MAX);
    println!("{} * 15_u64 = {}", u128::MAX, b);
    assert_eq!(b, 254_u8);
    
    // U256::new();
    // let a = 100_u8;
    // let b = 100_u8;
    // let c = func(a, b);
    // let d = func(c, 57);
    // println!("a + b = {}", c);
    // println!("c + 57 = {}", d);
    // assert_eq!(c, 200_u8);
    // assert_eq!(d, 1_u8);
    
    let mut a = U256::from_string_with_radix("11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101", 2).unwrap();
    let b = U256::from_string_with_radix("11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000_11110000_00001111_11001100_00110011_10101010_01010101_11111111_00000000", 2).unwrap();
    let d = U256::max();
    let c = !a | a;
    println!("c = {}", c.to_string_with_radix(2));
    assert_eq!(c, U256::max());

    // let mut sum = U1024::new();
    // sum.set_max();
    // println!("sum = {}", sum);

    // let mut a = U256::from_string("1234567_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890_1234567890").unwrap();
    // println!("{}", a);
    // a >>= 2;
    // println!("a = {}\n{}", a, a.is_underflow());
    // assert_eq!(a.is_underflow(), true);
}
*/